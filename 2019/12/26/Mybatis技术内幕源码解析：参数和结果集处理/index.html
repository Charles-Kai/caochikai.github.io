<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Mybatis技术内幕源码解析：参数和结果集处理 | 天道酬勤 | 劳逸结合</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Mybatis">
    <meta name="description" content="2.8、binding 模块 org.apache.ibatis.binding模块是为了解决Mapper类接口和对应Xml配置文件之间映射，通常Mapper接口定义了SQL语句对应的方法，而xml里面配置了对应的SQL语句，所以在Mybatis初始化的时候编译器会检查配置Mapper和xml，并关联起来。特别在参数处理那块非常复杂，需要给位看官的耐心分析，下面就要先从核心组件关系入手：">
<meta property="og:type" content="article">
<meta property="og:title" content="Mybatis技术内幕源码解析：参数和结果集处理">
<meta property="og:url" content="https:&#x2F;&#x2F;caochikai.github.io&#x2F;2019&#x2F;12&#x2F;26&#x2F;Mybatis%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%8F%82%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%9C%E9%9B%86%E5%A4%84%E7%90%86&#x2F;index.html">
<meta property="og:site_name" content="天道酬勤">
<meta property="og:description" content="2.8、binding 模块 org.apache.ibatis.binding模块是为了解决Mapper类接口和对应Xml配置文件之间映射，通常Mapper接口定义了SQL语句对应的方法，而xml里面配置了对应的SQL语句，所以在Mybatis初始化的时候编译器会检查配置Mapper和xml，并关联起来。特别在参数处理那块非常复杂，需要给位看官的耐心分析，下面就要先从核心组件关系入手：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https:&#x2F;&#x2F;caochikai.github.io&#x2F;images&#x2F;MapperRegistry.png">
<meta property="article:published_time" content="2019-12-26T10:28:00.000Z">
<meta property="article:modified_time" content="2019-12-26T10:30:17.338Z">
<meta property="article:author" content="ChiKai">
<meta property="article:tag" content="Mybatis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;caochikai.github.io&#x2F;images&#x2F;MapperRegistry.png">
    
        <link rel="alternate" type="application/atom+xml" title="天道酬勤" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">ChiKai</h5>
          <a href="mailto:992691009@qq.com" title="992691009@qq.com" class="mail">992691009@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/caochikai" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://caochikai.github.io/" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Mybatis技术内幕源码解析：参数和结果集处理</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Mybatis技术内幕源码解析：参数和结果集处理</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-12-26T10:28:00.000Z" itemprop="datePublished" class="page-time">
  2019-12-26
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Mybatis/">Mybatis</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-8、binding-模块"><span class="post-toc-number">1.</span> <span class="post-toc-text">2.8、binding 模块</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-8-1-MapperRegistry-amp-MapperProxyFactory"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">2.8.1 MapperRegistry&amp;MapperProxyFactory</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-8-2-MapperProxy代理"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">2.8.2 MapperProxy代理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-8-3-MapperMethod"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">2.8.3 MapperMethod</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Mybatis技术内幕源码解析：参数和结果集处理"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Mybatis技术内幕源码解析：参数和结果集处理</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-12-26 18:28:00" datetime="2019-12-26T10:28:00.000Z"  itemprop="datePublished">2019-12-26</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Mybatis/">Mybatis</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="2-8、binding-模块"><a href="#2-8、binding-模块" class="headerlink" title="2.8、binding 模块"></a>2.8、binding 模块</h1><blockquote>
<p>org.apache.ibatis.binding模块是为了解决Mapper类接口和对应Xml配置文件之间映射，通常Mapper接口定义了SQL语句对应的方法，而xml里面配置了对应的SQL语句，所以在Mybatis初始化的时候编译器会检查配置Mapper和xml，并关联起来。特别在参数处理那块非常复杂，需要给位看官的耐心分析，下面就要先从核心组件关系入手：</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/MapperRegistry.png" alt="upload successful" title="">
                </div>
                <div class="image-caption">upload successful</div>
            </figure>

<h2 id="2-8-1-MapperRegistry-amp-MapperProxyFactory"><a href="#2-8-1-MapperRegistry-amp-MapperProxyFactory" class="headerlink" title="2.8.1 MapperRegistry&amp;MapperProxyFactory"></a>2.8.1 MapperRegistry&amp;MapperProxyFactory</h2><blockquote>
<p>XXXRegistry看后缀命名风格就知道又是个注册类，MapperRegistry是Mapper接口及其对应的代理对象工厂的注册中心。Configuration是MyBatis 全局性的配置对象，在MyBatis初始化的过程中，所有配置信息会被解析成相应的对象并记录到Configuration对象中，后面介绍MyBatis初始化过程时会详细介绍Configuration。我重点要关注Configuration.mapperRegistry属性，它记录当前使用的MapperRegistry对象，下面就让就进行源码导读：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.binding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</span><br><span class="line"><span class="comment">//Configuration对象全局唯一的配置对象，包含所有的配置信息</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line"><span class="comment">//记录Mapper接口与MapperProxyFactory之间的对应关系,</span></span><br><span class="line"><span class="comment">//key为Mapper接口Class，value对应的代理工厂对象MapperProxyFactory</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperRegistry</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Class type获取MapperProxyFactory工厂对象</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//传入sqlSession为Mapper接口创建jdk动态代理对象，下面会详细分析mapperProxyFactory创建过程</span></span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//Class类型判断knownMappers是否存在该Mapper接口</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> knownMappers.containsKey(type);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//加载完配置文件和类上注解，将解析的mapper接口通过addMapper方法添加到MapperRegistry.knownMappers,</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断是否是接口</span></span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line"><span class="comment">//检查是否已经存在，避免重复读取</span></span><br><span class="line">      <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//标志是否完成load加载</span></span><br><span class="line">      <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//将Mapper接口对应的Class对象和MapperproxyFactory对象添加到knownMappers集合</span></span><br><span class="line">        knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">        <span class="comment">// It's important that the type is added before the parser is run</span></span><br><span class="line">        <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">        <span class="comment">// mapper parser. If the type is already known, it won't try.</span></span><br><span class="line"><span class="comment">//这个涉及到xml解析和注解方面的处理，后面再详细解答</span></span><br><span class="line">        MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**通过knownMappers获取Class集合，该集合为不可变容器unmodifiableCollection，避免被修改只能被读取</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 3.2.2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> Collection&lt;Class&lt;?&gt;&gt; getMappers() &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableCollection(knownMappers.keySet());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**通过包名路径读取指定superType父类的mapper（包扫描）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 3.2.2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span> </span>&#123;</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> ResolverUtil&lt;&gt;();</span><br><span class="line">    resolverUtil.find(<span class="keyword">new</span> ResolverUtil.IsA(superType), packageName);</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; mapperClass : mapperSet) &#123;</span><br><span class="line">      addMapper(mapperClass);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...addMappers重载</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.apache.ibatis.binding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//当前MapperProxyFactory工厂对应的产品mapperInterface接口</span></span><br><span class="line"><span class="comment">//换而言之就是一个工厂只能生产一种产品</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"><span class="comment">//该mapperInterface接口下对应的方法集合，key为java.lang.reflect.Method，value为MapperMethod对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//...geter/setter方法和构造器</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//创建实现了mapperInterface接口的代理对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-8-2-MapperProxy代理"><a href="#2-8-2-MapperProxy代理" class="headerlink" title="2.8.2 MapperProxy代理"></a>2.8.2 MapperProxy代理</h2><blockquote>
<p>MapperProxy实现了InvocationHandler接口，接口实现方法就是JDK动态代理的核心方法逻辑，下面认真分析针对mapper代理逻辑：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.binding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">//java.lang.invoke.MethodHandles.Lookup是被允许访问的成员类型（访问权限修饰符）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALLOWED_MODES = MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED</span><br><span class="line">      | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC;</span><br><span class="line"><span class="comment">//动态代理Constructor</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Constructor&lt;Lookup&gt; lookupConstructor;</span><br><span class="line"><span class="comment">//私有访问类型的方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method privateLookupInMethod;</span><br><span class="line"><span class="comment">//全局引用的sqlSession对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line"><span class="comment">//接口对应的Class对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"><span class="comment">//methodCache缓存方法集合key为Method对象，value为对应的MapperMethod</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略构造器</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//如果目标方法继承自object，则直接调用目标方法</span></span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;<span class="comment">//是否的默认方法（public non-abstract）</span></span><br><span class="line">        <span class="keyword">if</span> (privateLookupInMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//针对jdk8版本默认方法处理</span></span><br><span class="line">          <span class="keyword">return</span> invokeDefaultMethodJava8(proxy, method, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//针对jdk9版本默认方法处理</span></span><br><span class="line">          <span class="keyword">return</span> invokeDefaultMethodJava9(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//优先在缓存中获取，如果没有就new一个，具体看下面cachedMapperMethod方法</span></span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//新版本的mybatis</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache.computeIfAbsent(method,</span><br><span class="line">        k -&gt; <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略方法invokeDefaultMethodJava8和invokeDefaultMethodJava9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-8-3-MapperMethod"><a href="#2-8-3-MapperMethod" class="headerlink" title="2.8.3 MapperMethod"></a>2.8.3 MapperMethod</h2><blockquote>
<p>MapperMethod封装了接口中对应的方法的元信息，以及对应的SQL语句，与开发者息息相关。另一个比较重要的SqlCommand是MapperMethod中定义的内部类，它使用name字段记录了SQL语句的名称，使用type字段（SqlCommandType类型）记录了SQL语句的类型。SqlCommandType是枚举类型，有效取值为UNKNOWN、INSERT、UPDATE、DELETE、SELECT、FLUSH。MapperMethod源码比较复杂，先分析MapperMethod字段信息，后面会拆分SqlCommand、MethodSignature和ParamNameResolver分析：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">declaringClasspackage org.apache.ibatis.binding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperMethod</span> </span>&#123;</span><br><span class="line"><span class="comment">//SqlCommand记录SQL语句的名称和类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlCommand command;</span><br><span class="line"><span class="comment">//Mapper接口中的方法签名和相关信息，MethodSignature也是MapperMethod的内部类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MethodSignature method;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.command = <span class="keyword">new</span> SqlCommand(config, mapperInterface, method);</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, mapperInterface, method);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span> </span>&#123;</span><br><span class="line"><span class="comment">//SQL语句的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="comment">//SqlCommandType枚举类型：UNKNOWN、INSERT、UPDATE、DELETE、SELECT、FLUSH</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlCommandType type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SqlCommand</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>&#123;</span><br><span class="line"><span class="comment">//初步是先获取方法名称</span></span><br><span class="line">      <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line"><span class="comment">//方法的Method.clazz属性，主要用来判断是否为父接口信息</span></span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">      MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass,</span><br><span class="line">          configuration);</span><br><span class="line"><span class="comment">//检查MappedStatement是否创建成功</span></span><br><span class="line">      <span class="keyword">if</span> (ms == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//处理@Flush注解</span></span><br><span class="line">        <span class="keyword">if</span> (method.getAnnotation(Flush<span class="class">.<span class="keyword">class</span>) !</span>= <span class="keyword">null</span>) &#123;</span><br><span class="line">          name = <span class="keyword">null</span>;</span><br><span class="line">          type = SqlCommandType.FLUSH;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Invalid bound statement (not found): "</span></span><br><span class="line">              + mapperInterface.getName() + <span class="string">"."</span> + methodName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//初始化name和type</span></span><br><span class="line">        name = ms.getId();</span><br><span class="line">        type = ms.getSqlCommandType();</span><br><span class="line">        <span class="keyword">if</span> (type == SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//解析创建MappedStatement（SQL语句全部具体信息），后面再重点介绍</span></span><br><span class="line">		<span class="function"><span class="keyword">private</span> MappedStatement <span class="title">resolveMappedStatement</span><span class="params">(Class&lt;?&gt; mapperInterface, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; declaringClass, Configuration configuration)</span> </span>&#123;</span><br><span class="line"><span class="comment">//SQL语句的名称是由Mapper接口的名称与对应的方法名称组成的</span></span><br><span class="line">      String statementId = mapperInterface.getName() + <span class="string">"."</span> + methodName;</span><br><span class="line"><span class="comment">//先从Configuration.mappedStatements集合查询缓存</span></span><br><span class="line">      <span class="keyword">if</span> (configuration.hasStatement(statementId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> configuration.getMappedStatement(statementId);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mapperInterface.equals(declaringClass)) &#123;</span><br><span class="line"><span class="comment">//如果没有父类接口，也没有该sql、方法记录，那就没有了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//MappperMethod在父接口里面</span></span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) &#123;</span><br><span class="line"><span class="comment">//递归查找父接口类型是declaringClass的MappedStatement </span></span><br><span class="line">        <span class="keyword">if</span> (declaringClass.isAssignableFrom(superInterface)) &#123;</span><br><span class="line">          MappedStatement ms = resolveMappedStatement(superInterface, methodName,</span><br><span class="line">              declaringClass, configuration);</span><br><span class="line">          <span class="keyword">if</span> (ms != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ms;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...先省略具体方法后面再分析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MapperMethod另一个比较重要的内部类MethodSignature，通过ParamNameResolver处理接口方法的参数列表。ParamNameResolver的name字段（SortedMap&lt;Integer，String&gt;类型），其中key表示参数在参数列表中的索引位置，value 表示参数名称，参数名称可以通过<strong>@Param</strong>注解指定，如果没有指定<strong>@Param</strong>注解，则使用参数索引作为其名称。如果参数列表中包含RowBounds或ResultHandler类型的参数，则这两种类型的参数并不会被记录到name集合中，这就会导致参数的索引与名称不一致。下面源码导读中讲解到例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamNameResolver</span> </span>&#123;</span><br><span class="line"><span class="comment">//下标值的前缀名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GENERIC_NAME_PREFIX = <span class="string">"param"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;key为index索引（区别于真实索引，换而言之为按照真正的参数args下标来）</span></span><br><span class="line"><span class="comment">   * value为参数变量名(通过)</span></span><br><span class="line"><span class="comment">   * The key is the index and the value is the name of the parameter.&lt;br /&gt;</span></span><br><span class="line"><span class="comment">   * The name is obtained from &#123;<span class="doctag">@link</span> Param&#125; if specified. When &#123;<span class="doctag">@link</span> Param&#125; is not specified,</span></span><br><span class="line"><span class="comment">   * the parameter index is used. Note that this index could be different from the actual index</span></span><br><span class="line"><span class="comment">   * when the method has special parameters (i.e. &#123;<span class="doctag">@link</span> RowBounds&#125; or &#123;<span class="doctag">@link</span> ResultHandler&#125;).</span></span><br><span class="line"><span class="comment">   * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">   * &lt;ul&gt;官方的举例：</span></span><br><span class="line"><span class="comment">   * &lt;li&gt;aMethod(<span class="doctag">@Param</span>("M") int a, <span class="doctag">@Param</span>("N") int b) -&amp;gt; &#123;&#123;0, "M"&#125;, &#123;1, "N"&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   * &lt;li&gt;aMethod(int a, int b) -&amp;gt; &#123;&#123;0, "0"&#125;, &#123;1, "1"&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   * &lt;li&gt;aMethod(int a, **RowBounds rb**, int b) -&amp;gt; &#123;&#123;0, "0"&#125;, &#123;2, "1"&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; names;</span><br><span class="line"><span class="comment">//标志是否使用了**@Param注解**</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> hasParamAnnotation;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过反射获取参数类型数组</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"><span class="comment">//获取方法上的二维数组注解</span></span><br><span class="line">    <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line"><span class="comment">//这个map会在最后转化成不可变容器集合unmodifiableSortedMap</span></span><br><span class="line">    <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> paramCount = paramAnnotations.length;</span><br><span class="line">    <span class="comment">//遍历注解 get names from @Param annotations</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line"><span class="comment">//判断特殊类型RowBounds或者ResultHandler，发现则直接跳过本次遍历</span></span><br><span class="line">      <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">        <span class="comment">// skip special parameters</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      String name = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line"><span class="comment">//只要出现Param注解一次立刻设置标志hasParamAnnotation，结束遍历返回指定的name</span></span><br><span class="line">          hasParamAnnotation = <span class="keyword">true</span>;</span><br><span class="line">          name = ((Param) annotation).value();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//判断是否有特殊name</span></span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// @Param没有指定，根据Configuration.useActualParamName（默认true）是否使用实际名称</span></span><br><span class="line">        <span class="keyword">if</span> (config.isUseActualParamName()) &#123;</span><br><span class="line"><span class="comment">//getActualParamName在下面解析，ParamNameUtil.getParamNames(method).get(paramIndex);</span></span><br><span class="line">          name = getActualParamName(method, paramIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 使用索引值use the parameter index as the name ("0", "1", ...)</span></span><br><span class="line">          name = String.valueOf(map.size());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//记录到map集合</span></span><br><span class="line">      map.put(paramIndex, name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始化成不可变集合</span></span><br><span class="line">    names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//判断是否是RowBounds和ResultHandler两种类型的参数</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSpecialParameter</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RowBounds<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>) || <span class="title">ResultHandler</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.apache.ibatis.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"><span class="comment">//获取参数名称的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamNameUtil</span> </span>&#123;</span><br><span class="line"><span class="comment">//Method和Constructor的父类都是Executable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getParamNames</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getParameterNames(method);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getParamNames</span><span class="params">(Constructor&lt;?&gt; constructor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getParameterNames(constructor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getParameterNames</span><span class="params">(Executable executable)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过父类Executable获取参数列表的名字集合</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(executable.getParameters()).map(Parameter::getName).collect(Collectors.toList());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ParamNameUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解析完ParamNameResolver的功能，回到MethodSignature继续研究。MethodSignature也是MapperMethod中定义的内部类，其中封装了Mapper接口中定义的方法的相关信息：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSignature</span> </span>&#123;</span><br><span class="line"><span class="comment">//...省略字段下面介绍</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MethodSignature</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//解析方法类型信息，具体在之前反射工具箱一章提及</span></span><br><span class="line">	      Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);</span><br><span class="line">	      <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line">	        <span class="keyword">this</span>.returnType = (Class&lt;?&gt;) resolvedReturnType;</span><br><span class="line">	      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">	        <span class="keyword">this</span>.returnType = (Class&lt;?&gt;) ((ParameterizedType) resolvedReturnType).getRawType();</span><br><span class="line">	      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="keyword">this</span>.returnType = method.getReturnType();</span><br><span class="line">	      &#125;</span><br><span class="line"><span class="comment">//返回值类型是否为void</span></span><br><span class="line">	      <span class="keyword">this</span>.returnsVoid = <span class="keyword">void</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">this</span>.<span class="title">returnType</span>)</span>;</span><br><span class="line"><span class="comment">//返回值类型是否为Collection或者数组</span></span><br><span class="line">	      <span class="keyword">this</span>.returnsMany = configuration.getObjectFactory().isCollection(<span class="keyword">this</span>.returnType) || <span class="keyword">this</span>.returnType.isArray();</span><br><span class="line"><span class="comment">//返回值是否为Cursor类型</span></span><br><span class="line">	      <span class="keyword">this</span>.returnsCursor = Cursor<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">this</span>.<span class="title">returnType</span>)</span>;</span><br><span class="line"><span class="comment">//是否Optional值容器</span></span><br><span class="line">	      <span class="keyword">this</span>.returnsOptional = Optional<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">this</span>.<span class="title">returnType</span>)</span>;</span><br><span class="line"><span class="comment">//若Methodsignature对应方法的返回值是Map且指定了@MapKey 注解，则使用getMapKey（）方法处理</span></span><br><span class="line">	      <span class="keyword">this</span>.mapKey = getMapKey(method);</span><br><span class="line">	      <span class="keyword">this</span>.returnsMap = <span class="keyword">this</span>.mapKey != <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//rowBoundsIndex(RowBounds参数位置)和 resultHandlerIndex（ResultHandler参数位置）字段</span></span><br><span class="line">	      <span class="keyword">this</span>.rowBoundsIndex = getUniqueParamIndex(method, RowBounds<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	      <span class="keyword">this</span>.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//创建ParamNameResolver对象,后面会重点介绍getNamedParams方法</span></span><br><span class="line">	      <span class="keyword">this</span>.paramNameResolver = <span class="keyword">new</span> ParamNameResolver(configuration, method);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getUniqueParamIndex主要功能是查找指定参数类型在方法参数的索引位置</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Integer <span class="title">getUniqueParamIndex</span><span class="params">(Method method, Class&lt;?&gt; paramType)</span> </span>&#123;</span><br><span class="line">      Integer index = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt;[] argTypes = method.getParameterTypes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (paramType.isAssignableFrom(argTypes[i])) &#123;</span><br><span class="line">          <span class="keyword">if</span> (index == <span class="keyword">null</span>) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//RowBounds和ResultHandler类型的参数只能有一个，不能重复出现</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(method.getName() + <span class="string">" cannot have multiple "</span> + paramType.getSimpleName() + <span class="string">" parameters"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与语法有重要关系过程就在这里，ParamNameResolver有一个非常重要的方法getNamedParams，负责将args[]数组（用户传入的实参列表）转换成SQL语句对应的参数列表。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * A single non-special parameter is returned without a name.</span></span><br><span class="line"><span class="comment">   * Multiple parameters are named using the naming rule.</span></span><br><span class="line"><span class="comment">   * In addition to the default names, this method also adds the generic names (param1, param2,</span></span><br><span class="line"><span class="comment">   * ...).</span></span><br><span class="line"><span class="comment">   * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line"><span class="comment">//没有任何参数</span></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//如果没有指定@Param或者参数只有一个，直接返回第一个参数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line"><span class="comment">//将names属性SortedMap&lt;Integer，String&gt;类型反转</span></span><br><span class="line"><span class="comment">//names的value（参数名）为param新集合的key，names的key（参数索引）为param新集合的value</span></span><br><span class="line">        param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">        <span class="comment">//参数索引添加前缀、并且从i + 1（1、2、3开始）</span></span><br><span class="line"><span class="comment">//例子：add generic param names (param1, param2, ...)</span></span><br><span class="line">        <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ensure not to overwrite parameter named with @Param</span></span><br><span class="line"><span class="comment">//确保不会覆盖@Param指定的特殊参数名，换而言之就是通过param1或者@Param都可以取到同样的参数</span></span><br><span class="line">        <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">          param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后就是结果集处理，也是MapperMethod重要的方法execute，它会根据SQL语句的类型调用SqlSession对应的方法完成数据库操作。如果是是指定了ResultHandler，那就通过org.apache.ibatis.binding.MapperMethod#executeWithResultHandler处理结果集。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line"><span class="comment">//method.convertArgsToSqlCommandParam会调用上面解释到的ParamNameResolver.getNamedParams</span></span><br><span class="line"><span class="comment">//rowCountResult处理方法返回值影响行数rowCount，进行结果类型转换</span></span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//返回的是Collection接口实现类或者数组，由executeForMany方法处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line"><span class="comment">//返回的是Map集合结果，由executeForMap方法处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line"><span class="comment">//返回的是Cursor结果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//最后查询结果只有一条</span></span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line"><span class="comment">//如果是Optional包装返回值</span></span><br><span class="line">          <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line"><span class="comment">//那就进行Optional包装</span></span><br><span class="line">            result = Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//边界检查</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName()</span><br><span class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeWithResultHandler</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取SOL语句对应的MappedStatement对象，MappedStatement中记录了SQL语句相关信息，</span></span><br><span class="line">    MappedStatement ms = sqlSession.getConfiguration().getMappedStatement(command.getName());</span><br><span class="line"><span class="comment">//StatementType不是存储过程（CALLABLE），并且没有指定ResultMap或ResultType，直接抛出BindingException</span></span><br><span class="line">    <span class="keyword">if</span> (!StatementType.CALLABLE.equals(ms.getStatementType())</span><br><span class="line">        &amp;&amp; <span class="keyword">void</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">ms</span>.<span class="title">getResultMaps</span>().<span class="title">get</span>(0).<span class="title">getType</span>())) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"method "</span> + command.getName()</span><br><span class="line">          + <span class="string">" needs either a @ResultMap annotation, a @ResultType annotation,"</span></span><br><span class="line">          + <span class="string">" or a resultType attribute in XML so a ResultHandler can be used as a parameter."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line"><span class="comment">//该方法是否有RowBounds类型参数</span></span><br><span class="line">    <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line"><span class="comment">//获取指定RowBounds类型的参数</span></span><br><span class="line">      RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line"><span class="comment">//通过sqlSession.select查询方法指定查询，并由指定的ResultHandler处理结果对象</span></span><br><span class="line">      sqlSession.select(command.getName(), param, rowBounds, method.extractResultHandler(args));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sqlSession.select(command.getName(), param, method.extractResultHandler(args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Collection接口实现类或者数组处理过程</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;E&gt; result;</span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line"><span class="comment">//参考上几句</span></span><br><span class="line">    <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">      RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">      result = sqlSession.selectList(command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = sqlSession.selectList(command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将结果集转换为数组或Collection集合 issue #510 Collections &amp; arrays support</span></span><br><span class="line">    <span class="keyword">if</span> (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.getReturnType().isArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToArray(result);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//根据Configuration对结果对象的转换类型</span></span><br><span class="line">        <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">convertToDeclaredCollection</span><span class="params">(Configuration config, List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用前面介绍的ObjectFactory对象工厂，通过反射方式创建集合对象</span></span><br><span class="line">    Object collection = config.getObjectFactory().create(method.getReturnType());</span><br><span class="line"><span class="comment">//创建collection集合反射对象MetaObject，实际上还是调用的CCollection接口的addAll方法</span></span><br><span class="line">    MetaObject metaObject = config.newMetaObject(collection);</span><br><span class="line">    metaObject.addAll(list);</span><br><span class="line">    <span class="keyword">return</span> collection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">convertToArray</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取数组的元素类型</span></span><br><span class="line">    Class&lt;?&gt; arrayComponentType = method.getReturnType().getComponentType();</span><br><span class="line"><span class="comment">//创建数组对象</span></span><br><span class="line">    Object array = Array.newInstance(arrayComponentType, list.size());</span><br><span class="line"><span class="comment">//判断数组元素是否基本原始类型的</span></span><br><span class="line">    <span class="keyword">if</span> (arrayComponentType.isPrimitive()) &#123;</span><br><span class="line"><span class="comment">//将list每一项数据都放置到数组中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        Array.set(array, i, list.get(i));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//否直接转数组</span></span><br><span class="line">      <span class="keyword">return</span> list.toArray((E[])array);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//返回的是Map集合结果，由executeForMap方法处理，Cursor处理方法是sqlSession.selectCursor</span></span><br><span class="line"><span class="keyword">private</span> &lt;K, V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">executeForMap</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;K, V&gt; result;</span><br><span class="line"><span class="comment">//转化成实参</span></span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">      RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line"><span class="comment">//调用selectMap方法返回结果就是Map类型</span></span><br><span class="line">      result = sqlSession.selectMap(command.getName(), param, method.getMapKey(), rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = sqlSession.selectMap(command.getName(), param, method.getMapKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-12-26T10:30:17.338Z" itemprop="dateUpdated">2019-12-26 18:30:17</time>
</span><br>


        
        留言和分享第三方功能待实现，请各位疯狂star我的笔记，私活私聊我😘
        
    </div>
    
    <footer>
        <a href="https://caochikai.github.io">
            <img src="/img/avatar.jpg" alt="ChiKai">
            ChiKai
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/12/25/Mybatis%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9ATransaction%E4%BA%8B%E5%8A%A1/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Mybatis技术内幕源码解析：Transaction事务</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'true';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
</section>




<section class="comments" id="comments">
    <!-- UY BEGIN -->
    <div id="uyan_frame"></div>
    <script src="http://v2.uyan.cc/code/uyan.js?uid=true"></script>
    <!-- UY END -->
</section>
















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>ChiKai &copy; 2018 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: false, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>

[{"title":"Mybatis技术内幕源码解析：资源加载","date":"2019-12-22T06:10:00.000Z","path":"2019/12/22/Mybatis技术内幕源码解析：资源加载/","text":"2.5、资源加载2.5.1、类加载器 JVM类加载器（ClassLoader）负责加载各种资源（主要是class字节码文件)，来源比如文件系统、网络资源或者其他来源，且默认使用的是双亲委派模式。类加载器基本三大特性为延迟加载、职责分明、传递性。而JVM 中内置了三个重要的 ClassLoader： BootstrapClassLoader、ExtensionClassLoader 和 AppClassLoader。URLClassLoader 不但可以加载远程类库，还可以加载本地路径的类库，取决于构造器中不同的地址形式。ExtensionClassLoader 和 AppClassLoader 都是 URLClassLoader 的子类，它们都是从本地文件系统里加载类库。 BootstrapClassLoader（根加载器）：加载JVM核心类，比如$JAVA_HOME/lib/rt.jar； ExtensionClassLoader（扩展加载器）：加载扩展类，以 javax 开头的swing 系列、内置的 js 引擎、xml 解析器等等； AppClassLoader（用户加载器）：ClassLoader.getSystemClassLoader()获得，加载Classpath 环境变量下目录和jar； Thread.contextClassLoader（线程上下文类加载器）：主要是类隔离或者共享； 双亲委派模式：简单了来说子类有个parent 属性指向它的父加载器（类似指针），先检查自己是否已经加载过了，如果没有加载过就优先让父类尝试加载（理解为很懒都坑爹），如果已经加载或者坑爹不成那就自己干。 自定义类加载器：继承java.lang.ClassLoader，比如Tomcat（WebAppClassLoader）、JBoss类加载器； 12345678910package java.lang;...public abstract class ClassLoader &#123; // The parent class loader for delegation // Note: VM hardcoded the offset of this field, thus all new fields // must be added *after* it.//如果parent为空（比如ExtensionClassLoader），那默认null就是根加载器BootstrapClassLoader private final ClassLoader parent; ...&#125; 2.5.2 ClassloaderWrapper 看名字就知道是ClassLoader的包装器，org.apache.ibatis.io包就封装了资源加载文件的相关API，通过ClassloaderWrapper包装器就可以调整多个ClassLoader的使用顺序。ClassLoaderWrapper的主要方法可以分为三类，分别是getResourceAsURL方法、classForName方法、getResourceAsStream方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package org.apache.ibatis.io;import java.io.InputStream;import java.net.URL;/** * A class to wrap access to multiple class loaders making them work as one * * @author Clinton Begin */public class ClassLoaderWrapper &#123; //指定的默认类加载器 ClassLoader defaultClassLoader; //SecurityManager系统类加载器 ClassLoader systemClassLoader; ClassLoaderWrapper() &#123; try &#123; //初始化类加载器 systemClassLoader = ClassLoader.getSystemClassLoader(); &#125; catch (SecurityException ignored) &#123; // AccessControlException on Google App Engine &#125; &#125; ClassLoader[] getClassLoaders(ClassLoader classLoader) &#123; return new ClassLoader[]&#123; classLoader,//参数指定加载器 defaultClassLoader,//默认加载器 Thread.currentThread().getContextClassLoader(),//线程上下文类加载器 getClass().getClassLoader(),//当前类所使用的类加载器 systemClassLoader&#125;;//System ClassLoader &#125; ...省略部分重载方法 /** * Try to get a resource from a group of classloaders * * @param resource - the resource to get * @param classLoader - the classloaders to examine * @return the resource or null */ InputStream getResourceAsStream(String resource, ClassLoader[] classLoader) &#123; for (ClassLoader cl : classLoader) &#123; if (null != cl) &#123; // try to find the resource as passed InputStream returnValue = cl.getResourceAsStream(resource); // now, some class loaders want this leading \"/\", so we'll add it and try again if we didn't find the resource if (null == returnValue) &#123; returnValue = cl.getResourceAsStream(\"/\" + resource); &#125; if (null != returnValue) &#123; return returnValue; &#125; &#125; &#125; return null; &#125; /** * Get a resource as a URL using the current class path * * @param resource - the resource to locate * @param classLoader - the class loaders to examine * @return the resource or null */ URL getResourceAsURL(String resource, ClassLoader[] classLoader) &#123; URL url; for (ClassLoader cl : classLoader) &#123; if (null != cl) &#123; // look for the resource as passed in... url = cl.getResource(resource); // ...but some class loaders want this leading \"/\", so we'll add it // and try again if we didn't find the resource if (null == url) &#123; url = cl.getResource(\"/\" + resource); &#125; // \"It's always in the last place I look for it!\" // ... because only an idiot would keep looking for it after finding it, so stop looking already. if (null != url) &#123; return url; &#125; &#125; &#125; // didn't find it anywhere. return null; &#125; /** * Attempt to load a class from a group of classloaders * * @param name - the class to load * @param classLoader - the group of classloaders to examine * @return the class * @throws ClassNotFoundException - Remember the wisdom of Judge Smails: Well, the world needs ditch diggers, too. */ Class&lt;?&gt; classForName(String name, ClassLoader[] classLoader) throws ClassNotFoundException &#123; for (ClassLoader cl : classLoader) &#123; if (null != cl) &#123; try &#123; Class&lt;?&gt; c = Class.forName(name, true, cl) if (null != c) &#123; return c; &#125; &#125; catch (ClassNotFoundException e) &#123; // we'll ignore this until all classloaders fail to locate the class &#125; &#125; &#125; throw new ClassNotFoundException(\"Cannot find class: \" + name); &#125;&#125; 2.5.3 ResolverUtil ResolverUtil根据指定的条件查找指定包下的类，其中条件由Test接口中定义了matches方法提供。 upload successful 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package org.apache.ibatis.io;import ***import org.apache.ibatis.logging.Log;import org.apache.ibatis.logging.LogFactory;public class ResolverUtil&lt;T&gt; &#123; /** * A simple interface that specifies how to test classes to determine if they * are to be included in the results produced by the ResolverUtil. */ public interface Test &#123; /** * Will be called repeatedly with candidate classes. Must return True if a class * is to be included in the results, false otherwise. */ boolean matches(Class&lt;?&gt; type); &#125; /** * A Test that checks to see if each class is assignable to the provided class. Note * that this test will match the parent type itself if it is presented for matching. */ public static class IsA implements Test &#123; private Class&lt;?&gt; parent; //...构造方法初始化parent /** Returns true if type is assignable to the parent type supplied in the constructor. */ @Override public boolean matches(Class&lt;?&gt; type) &#123; //判断parent是否是type的父类（继承） return type != null &amp;&amp; parent.isAssignableFrom(type); &#125; &#125; /** * A Test that checks to see if each class is annotated with a specific annotation. If it * is, then the test returns true, otherwise false. */ public static class AnnotatedWith implements Test &#123; private Class&lt;? extends Annotation&gt; annotation; //...构造方法初始化annotation /** Returns true if the type is annotated with the class provided to the constructor. */ @Override public boolean matches(Class&lt;?&gt; type) &#123; //判断Type类上是否添加了annotation注解 return type != null &amp;&amp; type.isAnnotationPresent(annotation); &#125; &#125; /** The set of matches being accumulated. */ private Set&lt;Class&lt;? extends T&gt;&gt; matches = new HashSet&lt;&gt;(); /** * The ClassLoader to use when looking for classes. If null then the ClassLoader returned * by Thread.currentThread().getContextClassLoader() will be used. */ private ClassLoader classloader; /** * Provides access to the classes discovered so far. If no calls have been made to * any of the &#123;@code find()&#125; methods, **this set will be empty**. * * @return 匹配的类. */ public Set&lt;Class&lt;? extends T&gt;&gt; getClasses() &#123; return matches; &#125; /** * Returns the classloader that will be used for scanning for classes. If no explicit * ClassLoader has been set by the calling,the context class loader will be used. * 默认是线程上下文类加载器 */ public ClassLoader getClassLoader() &#123; return classloader == null ? Thread.currentThread().getContextClassLoader() : classloader; &#125; public void setClassLoader(ClassLoader classloader) &#123; this.classloader = classloader; &#125; /** * Scans for classes starting at the package provided and descending into subpackages. * Each class is offered up to the Test as it is discovered, and if the Test returns * true the class is retained. Accumulated classes can be fetched by calling * * @param test an instance of &#123;@link Test&#125; that will be used to filter classes * @param packageName the name of the package from which to start scanning for * classes, e.g. */ public ResolverUtil&lt;T&gt; find(Test test, String packageName) &#123; //根据包名获取对应的路径 String path = getPackagePath(packageName); try &#123; //根据VFS结果集合查找上面path下的资源 List&lt;String&gt; children = VFS.getInstance().list(path); for (String child : children) &#123; if (child.endsWith(\".class\")) &#123; //检查class是否符合结果 addIfMatching(test, child); &#125; &#125; &#125; catch (IOException ioe) &#123; log.error(\"Could not read package: \" + packageName, ioe); &#125; return this; &#125; ​ 12345678910111213141516171819202122232425262728293031323334 /** * Add the class designated by the fully qualified class name provided to the set of * resolved classes if and only if it is approved by the Test supplied. * * @param test the test used to determine if the class matches 查找条件 * @param fqn the fully qualified name of a class 类的完全限定名称 */ @SuppressWarnings(\"unchecked\") protected void addIfMatching(Test test, String fqn) &#123; try &#123; String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.'); ClassLoader loader = getClassLoader(); if (log.isDebugEnabled()) &#123; log.debug(\"Checking to see if class \" + externalName + \" matches criteria [\" + test + \"]\"); &#125; Class&lt;?&gt; type = loader.loadClass(externalName);//加载指定的类 if (test.matches(type)) &#123; //如果条件过滤在添加到匹配结果集合matches matches.add((Class&lt;T&gt;) type); &#125; &#125; catch (Throwable t) &#123; log.warn(\"Could not examine class '\" + fqn + \"'\" + \" due to a \" + t.getClass().getName() + \" with message: \" + t.getMessage()); &#125; &#125;&#125;//使用例子：在pkg1和pkg2这两个包下查找实现了ActionBean这个类ResolverUtil&lt;ActionBean&gt; resolver = new ResolverUtil&lt;ActionBean&gt;();resolver.findImplementation(ActionBean.class, pkg1, pkg2);resolver.find(new CustomTest(), pkg1);resolver.find(new CustomTest(), pkg2);//获取上面三个方法三次查找的结果集Collection&lt;ActionBean&gt; beans = resolver.getClasses(); 2.5.5 VFS（虚拟文件系统） VFS是Virtual File System缩写，用来查找指定路径下的资源。VFS也是一个抽象类，Mybatis在org.apache.ibatis.io下有DefaultVFS和JBoss6VFS的实现，UML图如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package org.apache.ibatis.io;import ...import org.apache.ibatis.logging.Log;import org.apache.ibatis.logging.LogFactory;/** * Provides a very simple API for accessing resources within an application server. * * @author Ben Gunter */public abstract class VFS &#123; /** The built-in implementations.记录了两个实现类 */ public static final Class&lt;?&gt;[] IMPLEMENTATIONS = &#123; JBoss6VFS.class, DefaultVFS.class &#125;; /** The list to which implementations are added by &#123;@link #addImplClass(Class)&#125;. *用户自定义的VES实现类。addImplClass（）方法会将指定的VES实现Class对象添加到集合。 */ public static final List&lt;Class&lt;? extends VFS&gt;&gt; USER_IMPLEMENTATIONS = new ArrayList&lt;&gt;(); ... /** Singleton instance holder.单例 */ private static class VFSHolder &#123; static final VFS INSTANCE = createVFS(); @SuppressWarnings(\"unchecked\") static VFS createVFS() &#123; // Try the user implementations first, then the built-ins List&lt;Class&lt;? extends VFS&gt;&gt; impls = new ArrayList&lt;&gt;();//优先使用用户定义的VFS的实现类 impls.addAll(USER_IMPLEMENTATIONS);//随后使用Mybatis提供的JBoss6VFS.class, DefaultVFS.class impls.addAll(Arrays.asList((Class&lt;? extends VFS&gt;[]) IMPLEMENTATIONS));//遍历所有实现类，依次实例化VFS对象并判断是否可用，可用就返回对象结束循环 // Try each implementation class until a valid one is found VFS vfs = null; for (int i = 0; vfs == null || !vfs.isValid(); i++) &#123; Class&lt;? extends VFS&gt; impl = impls.get(i); try &#123; vfs = impl.getDeclaredConstructor().newInstance(); if (!vfs.isValid()) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"VFS implementation \" + impl.getName() + \" is not valid in this environment.\"); &#125; &#125; &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123; log.error(\"Failed to instantiate \" + impl, e); return null; &#125; &#125; if (log.isDebugEnabled()) &#123; log.debug(\"Using VFS adapter \" + vfs.getClass().getName()); &#125; return vfs; &#125; &#125; /**单例模式体现，通过静态类创建 * Get the singleton &#123;@link VFS&#125; instance. If no &#123;@link VFS&#125; implementation can be found for the * current environment, then this method returns null. */ public static VFS getInstance() &#123; return VFSHolder.INSTANCE; &#125;//抽象方法 /*isValid()负责检测当前VFS对象在当前环境下是否有效* Return true if the &#123;@link VFS&#125; implementation is valid for the current environment. */ public abstract boolean isValid(); /**负责查找指定的资源名称列表 * Recursively list the full resource path of all the resources that are children of the * resource identified by a URL. * * @param url The URL that identifies the resource to list. * @param forPath The path to the resource that is identified by the URL. Generally, this is the * value passed to &#123;@link #getResources(String)&#125; to get the resource URL. * @return A list containing the names of the child resources. * @throws IOException If I/O errors occur */ protected abstract List&lt;String&gt; list(URL url, String forPath) throws IOException;&#125; VFS中定义了list（URL，String）和isValid()两个抽象方法，在ResolverUtil.find()方法查找类文件时会调用list()方法的重载方法，该重载最终会调用list（URL，String）这个重载。我们以DefaultVFS为例进行分析，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173ackage org.apache.ibatis.io;import ***import org.apache.ibatis.logging.Log;import org.apache.ibatis.logging.LogFactory;/**VFS的默认实现方法，适用于大多数的应用服务 * A default implementation of &#123;@link VFS&#125; that works for most application servers. * * @author Ben Gunter */public class DefaultVFS extends VFS &#123; private static final Log log = LogFactory.getLog(DefaultVFS.class); //判断是否是jar文件的字节特征 /** The magic header that indicates a JAR (ZIP) file. */ private static final byte[] JAR_MAGIC = &#123; 'P', 'K', 3, 4 &#125;; @Override public boolean isValid() &#123; return true; &#125; @Override public List&lt;String&gt; list(URL url, String path) throws IOException &#123; InputStream is = null; try &#123; List&lt;String&gt; resources = new ArrayList&lt;&gt;(); // First, try to find the URL of a JAR file containing the requested resource. If a JAR // file is found, then we'll list child resources by reading the JAR. //尝试读取jar文件，返回对应的URL，如果为空那就代表不是jar资源 URL jarUrl = findJarForResource(url); if (jarUrl != null) &#123; is = jarUrl.openStream(); if (log.isDebugEnabled()) &#123; log.debug(\"Listing \" + url); &#125; //遍历jar包中以path开头的资源列表 resources = listResources(new JarInputStream(is), path); &#125; else &#123; //遍历url的子目录并记录到children List&lt;String&gt; children = new ArrayList&lt;&gt;(); try &#123; if (isJar(url)) &#123; // Some versions of JBoss VFS might give a JAR stream even if the resource // referenced by the URL isn't actually a JAR is = url.openStream(); try (JarInputStream jarInput = new JarInputStream(is)) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Listing \" + url); &#125; for (JarEntry entry; (entry = jarInput.getNextJarEntry()) != null; ) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Jar entry: \" + entry.getName()); &#125; children.add(entry.getName()); &#125; &#125; &#125; else &#123; /* 大意是部分应用是资源列表在文本文件的里，下面尝试逐行读取资源， *路径为path + \"/\" + line（每行内容）若读取成功为文件，否则为文件夹 * Some servlet containers allow reading from directory resources like a * text file, listing the child resources one per line. However, there is no * way to differentiate between directory and file resources just by reading * them. To work around that, as each line is read, try to look it up via * the class loader as a child of the current resource. If any line fails * then we assume the current resource is not a directory. */ is = url.openStream(); List&lt;String&gt; lines = new ArrayList&lt;&gt;(); try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) &#123; for (String line; (line = reader.readLine()) != null;) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Reader entry: \" + line); &#125; lines.add(line); if (getResources(path + \"/\" + line).isEmpty()) &#123; lines.clear(); break; &#125; &#125; &#125; if (!lines.isEmpty()) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Listing \" + url); &#125; children.addAll(lines); &#125; &#125; &#125; catch (FileNotFoundException e) &#123; /*若读取URL失败则直接整个文件夹下所有的文件 * For file URLs the openStream() call might fail, depending on the servlet * container, because directories can't be opened for reading. If that happens, * then list the directory directly instead. */ if (\"file\".equals(url.getProtocol())) &#123; File file = new File(url.getFile()); if (log.isDebugEnabled()) &#123; log.debug(\"Listing directory \" + file.getAbsolutePath()); &#125; if (file.isDirectory()) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Listing \" + url); &#125; children = Arrays.asList(file.list()); &#125; &#125; else &#123; // No idea where the exception came from so rethrow it throw e; &#125; &#125; // The URL prefix to use when recursively listing child resources String prefix = url.toExternalForm(); if (!prefix.endsWith(\"/\")) &#123; prefix = prefix + \"/\"; &#125; // Iterate over immediate children, adding files and recursing into directories for (String child : children) &#123; String resourcePath = path + \"/\" + child; resources.add(resourcePath); URL childUrl = new URL(prefix + child); resources.addAll(list(childUrl, resourcePath)); &#125; &#125; return resources; &#125; finally &#123; ...关闭流 &#125; &#125; /** * List the names of the entries in the given &#123;@link JarInputStream&#125; that begin with the * specified &#123;@code path&#125;. Entries will match with or without a leading slash. * * @param jar The JAR input stream * @param path The leading path to match * @return The names of all the matching entries * @throws IOException If I/O errors occur */ protected List&lt;String&gt; listResources(JarInputStream jar, String path) throws IOException &#123; // Include the leading and trailing slash when matching names //...如果path不是以/开始和结束，则在其开始和结束位置添加/（略） // Iterate over the entries and collect those that begin with the requested path List&lt;String&gt; resources = new ArrayList&lt;&gt;(); //遍历jar包,将以path开头资源加入到resources 集合 for (JarEntry entry; (entry = jar.getNextJarEntry()) != null;) &#123; if (!entry.isDirectory()) &#123; // Add leading slash if it's missing StringBuilder name = new StringBuilder(entry.getName()); if (name.charAt(0) != '/') &#123; name.insert(0, '/'); &#125; // Check file name-&gt;path开头 if (name.indexOf(path) == 0) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Found resource: \" + name); &#125; // Trim leading slash resources.add(name.substring(1)); &#125; &#125; &#125; return resources; &#125; ...&#125; 参考文章 Oracle Location-Independent Access to Resources 老大难的 Java ClassLoader 再不理解就老了","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochikai.github.io/tags/Mybatis/"}]},{"title":"Mybatis技术内幕源码解析：日志模块","date":"2019-12-21T13:19:00.000Z","path":"2019/12/21/Mybatis技术内幕源码解析：日志模块/","text":"2.4、日志模块 Mybatis日志模块使用了适配器模式，内部调用org.apache.ibatis.logging.Log 接口。为了整合第三方的日志组件Log4J2、Log4J，mybatis提供了多种Adapter适配这些日志组件的API，并遵守Log 接口标准。在日志级别支持中，Mybatis提供了trace、debug、warn、eror四个级别，只能说基本满足绝大多数场景的日志。 12345678910111213141516171819202122package org.apache.ibatis.logging;/** * @author Clinton Begin */public interface Log &#123; //is开头方法为判断登记方法 boolean isDebugEnabled(); boolean isTraceEnabled(); //下面四个分别支持四种等级日志调用 void error(String s, Throwable e); void error(String s); void debug(String s); void trace(String s); void warn(String s);&#125; LogFactory负责创建对应的日志组件的适配器，其内部逻辑基本公共静态代码块加载支持的日志适配器，然后使用logConstructor集合记录所有支持的日志适配器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package org.apache.ibatis.logging;import java.lang.reflect.Constructor;/** * @author Clinton Begin * @author Eduardo Macarron */public final class LogFactory &#123; /** * Marker to be used by logging implementations that support markers. */ public static final String MARKER = \"MYBATIS\"; //第三方日志组件的集合 private static Constructor&lt;? extends Log&gt; logConstructor; static &#123; tryImplementation(LogFactory::useSlf4jLogging); tryImplementation(LogFactory::useCommonsLogging); tryImplementation(LogFactory::useLog4J2Logging); tryImplementation(LogFactory::useLog4JLogging); tryImplementation(LogFactory::useJdkLogging); tryImplementation(LogFactory::useNoLogging); &#125; private LogFactory() &#123; // disable construction &#125; public static Log getLog(Class&lt;?&gt; aClass) &#123; return getLog(aClass.getName()); &#125; public static Log getLog(String logger) &#123; try &#123; //返回logger对象 return logConstructor.newInstance(logger); &#125; catch (Throwable t) &#123; throw new LogException(\"Error creating logger for logger \" + logger + \". Cause: \" + t, t); &#125; &#125; ...use开头方法省略都会走下面方法setImplementation（对应适配器类） private static void tryImplementation(Runnable runnable) &#123; if (logConstructor == null) &#123; try &#123; runnable.run(); &#125; catch (Throwable t) &#123; // ignore &#125; &#125; &#125; private static void setImplementation(Class&lt;? extends Log&gt; implClass) &#123; try &#123; //获取指定适配器的构造方法 Constructor&lt;? extends Log&gt; candidate = implClass.getConstructor(String.class); //实例化适配器 Log log = candidate.newInstance(LogFactory.class.getName()); if (log.isDebugEnabled()) &#123; log.debug(\"Logging initialized using '\" + implClass + \"' adapter.\"); &#125; //初始化logConstructor logConstructor = candidate; &#125; catch (Throwable t) &#123; throw new LogException(\"Error setting Log implementation. Cause: \" + t, t); &#125; &#125;&#125; 2.4.4、JDBC调试日志 org.apache.ibatis.logging.jdbc是Mybatis通过动态代理的方式，将JDBC操作通过指定的日志框架打印出来，输出内容包含sql语句、绑定参数、影响行数等等。BaseJdbcLogger是jdbc下所有logger类的父类，继承树如下： upload successful 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package org.apache.ibatis.logging.jdbc;import ...省略部分导入import org.apache.ibatis.logging.Log;import org.apache.ibatis.reflection.ArrayUtil;/** * Base class for proxies to do logging. * * @author Clinton Begin * @author Eduardo Macarron */public abstract class BaseJdbcLogger &#123; //PreparedStatement接口中定义的常用的set*（）方法名 protected static final Set&lt;StrinSg&gt; SET_METHODS; //Statement接口和PreparedStatement接口中与执行SQL语句相关的方法名 protected static final Set&lt;String&gt; EXECUTE_METHODS = new HashSet&lt;&gt;(); //PreparedStatement.set*（）方法设置的键值对，key为parameterIndex下标，value为列值 private final Map&lt;Object, Object&gt; columnMap = new HashMap&lt;&gt;(); //parameterIndex集合 private final List&lt;Object&gt; columnNames = new ArrayList&lt;&gt;(); //value集合 private final List&lt;Object&gt; columnValues = new ArrayList&lt;&gt;(); //当前支持的适配器实例 protected final Log statementLog; //Sql层数，用于格式化sql，buffer堆栈的深度-&gt;char[] buffer = new char[queryStack * 2 + 2]; protected final int queryStack; /* * Default constructor，传入适配器实例 */ public BaseJdbcLogger(Log log, int queryStack) &#123; this.statementLog = log; if (queryStack == 0) &#123; this.queryStack = 1; &#125; else &#123; this.queryStack = queryStack; &#125; &#125; static &#123; //lambada获取PreparedStatement开通setXXX方法名称集合 SET_METHODS = Arrays.stream(PreparedStatement.class.getDeclaredMethods()) .filter(method -&gt; method.getName().startsWith(\"set\")) .filter(method -&gt; method.getParameterCount() &gt; 1) .map(Method::getName) .collect(Collectors.toSet()); //执行方法代理目标 EXECUTE_METHODS.add(\"execute\"); EXECUTE_METHODS.add(\"executeUpdate\"); EXECUTE_METHODS.add(\"executeQuery\"); EXECUTE_METHODS.add(\"addBatch\"); &#125; static &#123; //往SET_METHODS集合添加记录 SET_METHODS.add(\"setString\"); SET_METHODS.add(\"setNString\"); SET_METHODS.add(\"setInt\"); SET_METHODS.add(\"setByte\"); SET_METHODS.add(\"setShort\"); SET_METHODS.add(\"setLong\"); SET_METHODS.add(\"setDouble\"); SET_METHODS.add(\"setFloat\"); SET_METHODS.add(\"setTimestamp\"); SET_METHODS.add(\"setDate\"); SET_METHODS.add(\"setTime\"); SET_METHODS.add(\"setArray\"); SET_METHODS.add(\"setBigDecimal\"); SET_METHODS.add(\"setAsciiStream\"); SET_METHODS.add(\"setBinaryStream\"); SET_METHODS.add(\"setBlob\"); SET_METHODS.add(\"setBoolean\"); SET_METHODS.add(\"setBytes\"); SET_METHODS.add(\"setCharacterStream\"); SET_METHODS.add(\"setNCharacterStream\"); SET_METHODS.add(\"setClob\"); SET_METHODS.add(\"setNClob\"); SET_METHODS.add(\"setObject\"); SET_METHODS.add(\"setNull\"); EXECUTE_METHODS.add(\"execute\"); EXECUTE_METHODS.add(\"executeUpdate\"); EXECUTE_METHODS.add(\"executeQuery\"); EXECUTE_METHODS.add(\"addBatch\"); &#125; protected void setColumn(Object key, Object value) &#123; columnMap.put(key, value); columnNames.add(key); columnValues.add(value); &#125; ...&#125; PreparedStatementLogger继承了BaseJdbcLogger并实现了InvocationHandler接口。PreparedStatementLogger.invoke方法会为EXECUTE_METHODS集合中的方法、SET_METHODS集合中的方法、getResultSet等方法提供代理，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package org.apache.ibatis.logging.jdbc;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import org.apache.ibatis.logging.Log;import org.apache.ibatis.reflection.ExceptionUtil;/** * PreparedStatement proxy to add logging. * * @author Clinton Begin * @author Eduardo Macarron * */public final class PreparedStatementLogger extends BaseJdbcLogger implements InvocationHandler &#123; private final PreparedStatement statement; private PreparedStatementLogger(PreparedStatement stmt, Log statementLog, int queryStack) &#123; super(statementLog, queryStack); this.statement = stmt; &#125; @Override public Object invoke(Object proxy, Method method, Object[] params) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, params); &#125; //调用了EXECUTE_METHODS集合中的方法 if (EXECUTE_METHODS.contains(method.getName())) &#123; if (isDebugEnabled()) &#123; //日志输出，输出的是参数值以及参数类型-&gt;() debug(\"Parameters: \" + getParameterValueString(), true); &#125; clearColumnInfo();//清空BaseJdbcLogger中定义的三个column*集合 //如果是executeQuery方法，则为ResultSet创建代理对象，不是则直接返回结果 if (\"executeQuery\".equals(method.getName())) &#123; ResultSet rs = (ResultSet) method.invoke(statement, params); return rs == null ? null : ResultSetLogger.newInstance(rs, statementLog, queryStack); &#125; else &#123; return method.invoke(statement, params); &#125; &#125; else if (SET_METHODS.contains(method.getName())) &#123; //如果是SET_METHODS集合中的方法，则通过setColumn记录到 //BaseJdbcLogger的三个column*集合 if (\"setNull\".equals(method.getName())) &#123; setColumn(params[0], null); &#125; else &#123; setColumn(params[0], params[1]); &#125; return method.invoke(statement, params); &#125; else if (\"getResultSet\".equals(method.getName())) &#123; //如果调用getResultSet（）方法，则为ResultSet创建代理对象 ResultSet rs = (ResultSet) method.invoke(statement, params); return rs == null ? null : ResultSetLogger.newInstance(rs, statementLog, queryStack); &#125; else if (\"getUpdateCount\".equals(method.getName())) &#123; int updateCount = (Integer) method.invoke(statement, params); if (updateCount != -1) &#123; debug(\" Updates: \" + updateCount, false); &#125; //返回影响条数 return updateCount; &#125; else &#123; return method.invoke(statement, params); &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; /** * Creates a logging version of a PreparedStatement. * * @param stmt - the statement * @param statementLog - the statement log * @param queryStack - the query stack * @return - the proxy 使用JDK动态代理的方式创建代理对象 */ public static PreparedStatement newInstance(PreparedStatement stmt, Log statementLog, int queryStack) &#123; InvocationHandler handler = new PreparedStatementLogger(stmt, statementLog, queryStack); ClassLoader cl = PreparedStatement.class.getClassLoader(); return (PreparedStatement) Proxy.newProxyInstance(cl, new Class[]&#123;PreparedStatement.class, CallableStatement.class&#125;, handler); &#125; /** * Return the wrapped prepared statement. * * @return the PreparedStatement */ public PreparedStatement getPreparedStatement() &#123; return statement; &#125;&#125; ResultSetLogger 中封装了ResultSet对象，也继承了BaseldbcLogger抽象类并实现了InvocationHandler 接口。ResultSetLogger中定义的字段如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package org.apache.ibatis.logging.jdbc;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.sql.Types;import java.util.HashSet;import java.util.Set;import org.apache.ibatis.logging.Log;import org.apache.ibatis.reflection.ExceptionUtil;/** * ResultSet proxy to add logging * * @author Clinton Begin * @author Eduardo Macarron * */public final class ResultSetLogger extends BaseJdbcLogger implements InvocationHandler &#123; //记录了超大长度的类型 private static Set&lt;Integer&gt; BLOB_TYPES = new HashSet&lt;&gt;(); //是否是ResultSet结果集的第一行 private boolean first = true; //统计行数 private int rows; private final ResultSet rs; //记录了超大字段的列编号 private final Set&lt;Integer&gt; blobColumns = new HashSet&lt;&gt;(); static &#123; //所有超大长度的类型 BLOB_TYPES.add(Types.BINARY); BLOB_TYPES.add(Types.BLOB); BLOB_TYPES.add(Types.CLOB); BLOB_TYPES.add(Types.LONGNVARCHAR); BLOB_TYPES.add(Types.LONGVARBINARY); BLOB_TYPES.add(Types.LONGVARCHAR); BLOB_TYPES.add(Types.NCLOB); BLOB_TYPES.add(Types.VARBINARY); &#125; @Override public Object invoke(Object proxy, Method method, Object[] params) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, params); &#125; Object o = method.invoke(rs, params); if (\"next\".equals(method.getName())) &#123; //是否还有下一行 if ((Boolean) o) &#123; rows++; if (isTraceEnabled()) &#123; ResultSetMetaData rsmd = rs.getMetaData(); //获取数据集的列数 final int columnCount = rsmd.getColumnCount(); if (first) &#123; first = false; //输出表头，并填充超大长度的类型到集合中 printColumnHeaders(rsmd, columnCount); &#125; //输出该行记录，注意会过滤掉blobColumns中记录的列， //这些列的数据较大，不会输出到日志 printColumnValues(columnCount); &#125; &#125; else &#123; //遍历ResultSet之后输出总，完例子：Total: 1 debug(\" Total: \" + rows, false); &#125; &#125; clearColumnInfo();//清空BaseJdbcLogger的三个column*集合 return o; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; //例子：Header: [count(*)] private void printColumnHeaders(ResultSetMetaData rsmd, int columnCount) throws SQLException &#123; StringBuilder row = new StringBuilder(); row.append(\" Columns: \"); for (int i = 1; i &lt;= columnCount; i++) &#123; if (BLOB_TYPES.contains(rsmd.getColumnType(i))) &#123; blobColumns.add(i); &#125; String colname = rsmd.getColumnLabel(i); row.append(colname); if (i != columnCount) &#123; row.append(\", \"); &#125; &#125; trace(row.toString(), false); &#125; //例子：Row: 39 private void printColumnValues(int columnCount) &#123; StringBuilder row = new StringBuilder(); row.append(\" Row: \"); for (int i = 1; i &lt;= columnCount; i++) &#123; String colname; try &#123; if (blobColumns.contains(i)) &#123; colname = \"&lt;&lt;BLOB&gt;&gt;\"; &#125; else &#123; colname = rs.getString(i); &#125; &#125; catch (SQLException e) &#123; // generally can't call getString() on a BLOB column colname = \"&lt;&lt;Cannot Display&gt;&gt;\"; &#125; row.append(colname); if (i != columnCount) &#123; row.append(\", \"); &#125; &#125; trace(row.toString(), false); &#125;...&#125;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochikai.github.io/tags/Mybatis/"}]},{"title":"Mybatis技术内幕源码解析：类型转换","date":"2019-12-20T12:40:00.000Z","path":"2019/12/20/Mybatis技术内幕-第二章：2-3类型转换/","text":"2.3、类型转换 JDBC数据类型与Java语言中的数据类型并不是完全对应的，所以在PreparedStatement为SOL语句绑定参数时，需要从Java类型转换成JDBC类型，而从结果集中获取数据时，则需要从JDBC类型转换成Java类型。MyBatis使用类型处理器完成上述两种转换。 upload successful 2.3.1、TypeHandler Mybatis当中所有类型转化器都继承BaseTypeHandler，而BaseTypeHandler又实现了TypeHandler接口。接口定义了四个方法，分成两类：setParameter()方法负责将数据由JdbcType 类型转换成Java类型；getResult()方法及其重载负责将数据由Java类型转换成JdbcType类型。 1234567891011121314151617181920212223242526package org.apache.ibatis.type;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;&#x2F;** * @author Clinton Begin *&#x2F;public interface TypeHandler&lt;T&gt; &#123; &#x2F;&#x2F;在通过Preparedstatement为SQL语句绑定参数时，会将数据由JdbcType类型转换成Java类型 void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException; &#x2F;** * @param columnName Colunm name, when configuration &lt;code&gt;useColumnLabel&lt;&#x2F;code&gt; is &lt;code&gt;false&lt;&#x2F;code&gt; *&#x2F; &#x2F;&#x2F;从ResultSet中获取数据，通过字段名称将数据由Java类型转换成JdbcType类型 T getResult(ResultSet rs, String columnName) throws SQLException; &#x2F;&#x2F;从ResultSet中获取数据，通过字段下标（同上面getResult） T getResult(ResultSet rs, int columnIndex) throws SQLException; &#x2F;&#x2F;CallableStatement中通过下标获取结果 T getResult(CallableStatement cs, int columnIndex) throws SQLException;&#125; 一般类型转换器适用于单个参数或者单个列值完成类型转换，大多数是直接调用PreparedStatement、ResultSet、CallableStatement的对应方法， 以org.apache.ibatis.type.StringTypeHandler为例子如下： 1234567891011121314151617181920212223242526272829public class StringTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123; //调用PreparedStatement.setXXX(Type)绑定参数 ps.setString(i, parameter); &#125; @Override public String getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; //ResultSet.getXXX(Type)(列名称)获取列值 return rs.getString(columnName); &#125; @Override public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; //ResultSet.getXXX(Type)(列下标)获取列值 return rs.getString(columnIndex); &#125; @Override public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return cs.getString(columnIndex); &#125;&#125; 2.3.2、TypeHandlerRegistry TypeHandlerRegistry管理所有的类型转化器，register()方法实现了注册功能，过程中会向下述字段集合添加TypeHandler。 1234567891011121314151617181920212223package org.apache.ibatis.type;import .../** * @author Clinton Begin * @author Kazuki Shimizu */public final class TypeHandlerRegistry &#123; //在读取结果数据时候，依靠该集合映射从jdbcType转换成javaType， //而JdbcType类型为org.apache.ibatis.type.JdbcType枚举类型 private final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcTypeHandlerMap = new EnumMap&lt;&gt;(JdbcType.class); //记录了Java类型向指定Jdbcrype转换时，需要使用的TypeHandler对象。例如；Java类型中的string可能 //转换成教据库的 char、varchar等多种类型，所以存在一对多关系 private final Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = new ConcurrentHashMap&lt;&gt;(); //Object类型TypeHandler处理类 private final TypeHandler&lt;Object&gt; unknownTypeHandler = new UnknownTypeHandler(this); //全部Java类型以及对应的TypeHandler private final Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap = new HashMap&lt;&gt;(); //空TypeHandler集合的标识 private static final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; NULL_TYPE_HANDLER_MAP = Collections.emptyMap(); //枚举类型的TypeHandler集合 private Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler = EnumTypeHandler.class;&#125;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochikai.github.io/tags/Mybatis/"}]},{"title":"Mybatis技术内幕源码解析：反射工具箱","date":"2019-12-19T13:24:00.000Z","path":"2019/12/19/Mybatis技术内幕-第二章：基础层/","text":"第二章：基础支持层 Mybatis以SqlSessionFactory为核心，通过SqlSessionFactoryBuilder解析xml配置文件或Configration实例构建出SqlSessionFactory的实例。 一、重要概念 命名空间（Namespaces）：通常包名加类目组成完全限定名（com.MyMapper.selectAll），实现语句隔离确定唯一性。 作用域（Scope）和生命周期 SqlSessionFactoryBuilder：完成创建SqlSessionFactory后就不再需要。 SqlSessionFactory：最佳作用域是应用作用域，最优解是使用单例模式或者静态单例模式。 SqlSession：最佳的作用域是请求或方法作用域 2.2、反射工具箱 Mybatis进行参数处理、结果映射会涉及到大量的反射操作。Java反射功能虽然强大，但是代码复杂易错，所以在mybaits源码包org.apache.ibatis.reflection有专门的反射模块。 2.2.1 Reflector&amp;ReflectorFactory Reflector是反射模块的基础类，一个reflecotr实例对应一个类的元信息。根据Java Bean规范，封装的对getter、setter属性方法映射。 Reflector成员字段分析如下： 12345678910111213141516171819202122232425262728293031package org.apache.ibatis.reflection;import ....（省略导入类）&#x2F;** * This class represents a cached set of class definition information that * allows for easy mapping between property names and getter&#x2F;setter methods. * * @author Clinton Begin *&#x2F;public class Reflector &#123; &#x2F;&#x2F;对应的class类型 private final Class&lt;?&gt; type; &#x2F;&#x2F;getter方法对应的属性名称数组 private final String[] readablePropertyNames; &#x2F;&#x2F;setter方法对应的属性名称数组 private final String[] writablePropertyNames; &#x2F;&#x2F;属性对应的setter方法集合，key是属性名称，value是Invoker对象 private final Map&lt;String, Invoker&gt; setMethods &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F;属性对应的getter方法集合，key是属性名称，value是Invoker对象 private final Map&lt;String, Invoker&gt; getMethods &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F;记录了属性相应的setter方法的参数值类型，key是属性名称，value是setter方法的参数类型 private final Map&lt;String, Class&lt;?&gt;&gt; setTypes &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F;记录了属性相应的getter方法的参数值类型，key是属性名称，value是setter方法的参数类型 private final Map&lt;String, Class&lt;?&gt;&gt; getTypes &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F;记录默认构造器 private Constructor&lt;?&gt; defaultConstructor; &#x2F;&#x2F;所有属性名称集合 private Map&lt;String, String&gt; caseInsensitivePropertyMap &#x3D; new HashMap&lt;&gt;(); &#125; ReflectorFactory接口定义了Reflector对象创建或者缓存 12345678910package org.apache.ibatis.reflection;public interface ReflectorFactory &#123; &#x2F;&#x2F;确定是否需要缓存该Reflector对象 boolean isClassCacheEnabled(); &#x2F;&#x2F;设置是否缓存该Reflector对象 void setClassCacheEnabled(boolean classCacheEnabled); &#x2F;&#x2F;刘建指定Class对应的Reflector对象 Reflector findForClass(Class&lt;?&gt; type);&#125; DefaultReflectorFactory默认实现ReflectorFactory，而CustomReflectorFactory继承DefaultReflectorFactory并且空实现，其关系图如下 DefaultReflectorFactory 12345678910111213141516171819202122232425262728293031323334353637package org.apache.ibatis.reflection;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;public class DefaultReflectorFactory implements ReflectorFactory &#123; &#x2F;&#x2F;该字段决定是否开启对Reflector对象 private boolean classCacheEnabled &#x3D; true; &#x2F;&#x2F;使用ConcurrentMap集合实现对Reflector对象的缓存 private final ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap &#x3D; new ConcurrentHashMap&lt;&gt;(); public DefaultReflectorFactory() &#123; &#125; @Override public boolean isClassCacheEnabled() &#123; return classCacheEnabled; &#125; @Override public void setClassCacheEnabled(boolean classCacheEnabled) &#123; this.classCacheEnabled &#x3D; classCacheEnabled; &#125; @Override public Reflector findForClass(Class&lt;?&gt; type) &#123; if (classCacheEnabled) &#123;&#x2F;&#x2F;检测是否开启缓存 &#x2F;&#x2F; synchronized (type) removed see issue #461 &#x2F;&#x2F;通过线程安全ConcurrentHashMap获取缓存Reflector，没有则通过lambada调用构造新建对象 return reflectorMap.computeIfAbsent(type, Reflector::new); &#125; else &#123; &#x2F;&#x2F;未开启缓存则直接new Reflector对象 return new Reflector(type); &#125; &#125;&#125;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochikai.github.io/tags/Mybatis/"}]},{"title":"HttpServletRequest流重复读","date":"2019-12-18T12:30:00.000Z","path":"2019/12/18/HttpServletRequest流重复读/","text":"HttpServletRequest流重复读 springmvc controller @RequestBody接受参数报错，原因为http POST请求报文体为二进制流，在HttpServletRequest.getInputStream()中流只能被读取一次，重复读取会报如下： 1getRead() has already been called for this request&#x2F;getInputStream() has already been called for this request 一、解决方式 第一种方式：重写HttpServletRequestWrapper 将InputStream 替换成可重复读的ByteArrayInputStream，原理就是在Filter或者springmvc的interceptor中通过构造器包装HttpServletRequest，并且把当前流缓存起来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.ServletRequest;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.nio.charset.Charset;/** * 自定义HttpServletRequestWrapper * 解决InputStream不能重复读问题 * */public class BufferedServletRequestWrapper extends HttpServletRequestWrapper &#123; private final byte[] body; BufferedServletRequestWrapper(HttpServletRequest request) throws IOException &#123; super(request); String sessionStream = getBodyString(request); body = sessionStream.getBytes(Charset.forName(\"UTF-8\")); &#125; /** * 获取请求Body */ private String getBodyString(final ServletRequest request) &#123; StringBuilder sb = new StringBuilder(); InputStream inputStream = null; BufferedReader reader = null; try &#123; inputStream = cloneInputStream(request.getInputStream()); reader = new BufferedReader(new InputStreamReader(inputStream, Charset.forName(\"UTF-8\"))); String line = \"\"; while ((line = reader.readLine()) != null) &#123; sb.append(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return sb.toString(); &#125; /** * 复制输入流 */ private InputStream cloneInputStream(ServletInputStream inputStream) &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; try &#123; while ((len = inputStream.read(buffer)) &gt; -1) &#123; byteArrayOutputStream.write(buffer, 0, len); &#125; byteArrayOutputStream.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); &#125; @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; final ByteArrayInputStream bais = new ByteArrayInputStream(body); return new ServletInputStream() &#123; @Override public int read() throws IOException &#123; return bais.read(); &#125; &#125;; &#125;&#125; 第二种方式：Springmvc提供了解决方案ContentCachingRequestWrapper，思路也是一样，只不过代码更加严谨点。源码我就不贴了，开头注释说明贴一下，然后需要注意事项和正确的使用方式如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** *ContentCachingRequestWrapper源码注释如下 * &#123;@link javax.servlet.http.HttpServletRequest&#125; wrapper that caches all content read from * the &#123;@linkplain #getInputStream() input stream&#125; and &#123;@linkplain #getReader() reader&#125;, * and allows this content to be retrieved via a &#123;@link #getContentAsByteArray() byte array&#125;. * * &lt;p&gt;Used e.g. by &#123;@link org.springframework.web.filter.AbstractRequestLoggingFilter&#125;. * * @author Juergen Hoeller * @author Brian Clozel * @since 4.1.3 * @see ContentCachingResponseWrapper */package com.qm.interceptor;import org.springframework.web.util.ContentCachingRequestWrapper;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;/** * 配置哪些请求可以进行重复读数据 * */public class cachingRequestBodyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // 防止流读取一次后就没有了, 所以需要将流继续写出去 HttpServletRequest httpServletRequest = (HttpServletRequest) request; String requestURI = httpServletRequest.getRequestURI(); // 这里将原始request传入，读出流并存储 //PATH 为可重复读的路径开始或者接受部分 例如：caching.do if (requestURI.endsWith(\"caching.do\")) &#123; // 这里将原始request传入，读出流并存储 ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(httpServletRequest); // 这里将原始request替换为包装后的request，此后所有进入controller的request均为包装后的request chain.doFilter(requestWrapper, response); &#125; else &#123;// 不要覆盖所有的请求，防止覆盖其他人请求 chain.doFilter(request, response); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; 二、参考如下：HttpServletRequest数据流重复读问题","tags":[{"name":"Spring","slug":"Spring","permalink":"https://caochikai.github.io/tags/Spring/"}]},{"title":"BigDecimal金额计算","date":"2019-12-16T16:26:58.000Z","path":"2019/12/17/BigDecimal金额计算/","text":"关于金额计算，通常有加减乘除，四舍五入等。 add()加法函数：要注意BigDecimal加法得到的结果为零，因为BigDecimal的加法需要一个值去接收，加法不会改变调用者自身的值。 subtract()减法函数：同加法； multiply()乘法函数：注意Double转BigDecimal，尽量用字符串的形式初始化。因为使用BigDecimal类构造方法传入double类型时，计算的结果是不精确的！ divide()除法函数：避免抛出除零异常，方式将除运算尽量转换成等价的乘运算。 保留两位小数且四舍五入：value.setScale(2, BigDecimal.ROUND_HALF_UP); BigDecimal静态常量值，比如BigDecimal.ZERO等； 例子刨析：1234567891011121314151617181920212223242526BigDecimal num1 = new BigDecimal(0.005); BigDecimal num2 = new BigDecimal(1000000); BigDecimal num3 = new BigDecimal(-1000000); //尽量用字符串的形式初始化 BigDecimal num12 = new BigDecimal(\"0.005\"); BigDecimal num22 = new BigDecimal(\"1000000\"); BigDecimal num32 = new BigDecimal(\"-1000000\");//加法 BigDecimal result1 = num1.add(num2); BigDecimal result12 = num12.add(num22); //减法 BigDecimal result2 = num1.subtract(num2); BigDecimal result22 = num12.subtract(num22); //乘法 BigDecimal result3 = num1.multiply(num2); BigDecimal result32 = num12.multiply(num22); //绝对值 BigDecimal result4 = num3.abs(); BigDecimal result42 = num32.abs(); //除法 BigDecimal result5 = num2.divide(num1,20,BigDecimal.ROUND_HALF_UP); BigDecimal result52 = num22.divide(num12,20,BigDecimal.ROUND_HALF_UP); result全部输出结果，初始化建议使用String 结果 参考如下BigDecimal加减乘除计算","tags":[]},{"title":"Springboot+vue部署路由404","date":"2019-12-15T08:32:00.000Z","path":"2019/12/15/hello-world/","text":"问题背景vue单页面路由，刷新地址或者请求链接，都会404 user www; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; events { worker_connections 51200; multi_accept on; } http { include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; #gzip on; gzip on; server { listen 80; root /www/app/; server_name gdhxy.cn; try_files $uri $uri/ /index.html; } server { listen 80; root /www/app/; server_name www.gdhxy.cn; try_files $uri $uri/ /index.html; } server { listen 80; server_name admin.gdhxy.cn; try_files $uri $uri/ /index.html; location / { proxy_redirect off; proxy_pass http://127.0.0.1:38806; } } }解决方式 1、nginx配置：try_files $uri $uri/ /index.html；2、springboot指定404到index.html. import org.springframework.boot.web.servlet.error.ErrorController; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpServletRequest; @Controller public class MyErrorController implements ErrorController { @RequestMapping(&quot;/error&quot;) public String handleError(HttpServletRequest request) { //获取statusCode:404,重定向到首页 Integer statusCode = (Integer) request.getAttribute(&quot;javax.servlet.error.status_code&quot;); if (statusCode == 404) { return &quot;/index.html&quot;; } else { return &quot;/500&quot;; } } @Override public String getErrorPath() { return &quot;/error&quot;; } }","tags":[{"name":"Spring","slug":"Spring","permalink":"https://caochikai.github.io/tags/Spring/"}]},{"title":"服务器配置记录","date":"2019-09-27T16:48:12.000Z","path":"2019/09/28/服务器配置记录/","text":"服务器配置记录一、背景 真实生产环境部署：nginx、tomcat配置https证书 二、nginx安装过程：123456789101112131415//一键安装上面四个依赖yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel//下载tar包wget http://nginx.org/download/nginx-1.16.1.tar.gztar xzf nginx-1.16.1.tar.gz -C /usr/local//文件名改nginx-1.16.1成nginx//进入nginx目录cd /usr/local/nginx//关联编译https模块 ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module//执行make命令编译源码make//执行make install安装可执行binmake install//新建logs（日志）和ssl（证书）文件夹 https浏览器影响——混合内容 解决Nginx反代Tomcat Http、Https混合内容报错，浏览器认为https请求中资源是http的css、js和图片都无法正常加载，造成无法双协议兼容！ 12浏览器访问后开发者模式看到的报错信息：Mixed Content: The page at &#39;https:&#x2F;&#x2F;dashboard.domain.com&#x2F;wire&#39; was loaded over HTTPS, but requested an insecure stylesheet &#39;http:&#x2F;&#x2F;dashboard.domain.com&#x2F;static&#x2F;css&#x2F;flickity.css&#39;. This request has been blocked; the content must be served over HTTPS. nginx解决配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061user www;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;events &#123; worker_connections 51200; multi_accept on;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; #gzip on; gzip on; server &#123; listen 80; listen 443 ssl; server_name chinaffxz.com; #charset koi8-r; ssl_certificate /usr/local/nginx/ssl/2879444_chinagzhxy.com.pem; ssl_certificate_key /usr/local/nginx/ssl/2879444_chinagzhxy.com.key; location / &#123; proxy_pass http://127.0.0.1:xxxx/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #解决兼容配置要点 proxy_set_header X-Forwarded-Proto $scheme; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; Tomcat配置1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;Server port=\"8006\" shutdown=\"SHUTDOWN\"&gt; &lt;Listener className=\"org.apache.catalina.core.JreMemoryLeakPreventionListener\" /&gt; &lt;Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" /&gt; &lt;Listener className=\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\" /&gt; &lt;Listener className=\"org.apache.catalina.core.AprLifecycleListener\" /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name=\"UserDatabase\" auth=\"Container\" type=\"org.apache.catalina.UserDatabase\" description=\"User database that can be updated and saved\" factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\" pathname=\"conf/tomcat-users.xml\" /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name=\"Catalina\"&gt; &lt;Connector port=\"38080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" maxThreads=\"1000\" minSpareThreads=\"20\" acceptCount=\"1000\" maxHttpHeaderSize=\"65536\" debug=\"0\" disableUploadTimeout=\"true\" useBodyEncodingForURI=\"true\" enableLookups=\"false\" URIEncoding=\"UTF-8\" /&gt; &lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt; &lt;!-- 解决兼容要点--&gt; &lt;Valve className=\"org.apache.catalina.valves.RemoteIpValve\" remoteIpHeader=\"X-Forwarded-For\" protocolHeader=\"X-Forwarded-Proto\" protocolHeaderHttpsValue=\"https\"/&gt; &lt;Realm className=\"org.apache.catalina.realm.LockOutRealm\"&gt; &lt;Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\" resourceName=\"UserDatabase\" /&gt; &lt;/Realm&gt; &lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html Note: The pattern used is equivalent to using pattern=\"common\" --&gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt; &lt;Context path=\"\" docBase =\"mall\" debug=\"0\" reloadable=\"true\" crossContext=\"false\"/&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; git持续部署shell脚本 解决Linux CentOS中cp -f 复制强制覆盖的命令无效的方法，系统默认使用cp -i使用交互方式避免误操作，但在自动脚本中应当避免，推荐\\cp。 123456789101112#update codecd /root/dowload/mall/duoshanghugit fetch origin git pull &gt; /root/dowload/mall/logs/mall_git.log &amp;#package mvn package -Dmaven.test.skip=truesleep 2s#cp war to tomcat webapp\\cp -fr /root/dowload/mall/duoshanghu/target/mall.war /usr/local/env/tomcat/webapps/mall.warsleep 1s#restart.shsh /usr/local/env/tomcat/bin/restart.sh tomcat重启脚本1234567891011121314151617181920212223242526272829303132#!/bin/sh#初始化全局环境变量. /etc/profile#set java environmentexport CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib#查找tomcat的pidpid=`ps aux | grep tomcat | grep -v grep | grep -v Restart | grep -v restart | awk '&#123;print $2&#125;'`echo \"the tomcat pid is $pid\"#判断tomcat进程是否存在if [ -n \"$pid\" ];then sleep 1 pid=`ps aux | grep tomcat | grep -v grep | grep -v restart | grep -v Restart | awk '&#123;print $2&#125;'` if [ -n \"$pid\" ]; then sleep 1 echo \"tomcat进程将被杀?\" kill -9 $pid fi sleep 1 echo \"tomcat进程已经被杀死，先重新启动tomcat.\" service tomcat status sleep 1s service tomcat startelse echo \"tomcat进程不存在，先重新启动tomcat.\" service tomcat status sleep 1s service tomcat startfi maven编译完整依赖管理1、来源 解决webapp/WEB-INF/lib目录下的jar包无法用maven打包，且在linuxMaven编译报错[ERROR] Fatal Error: Unable to find package java.lang in classpath or bootclasspath，致命错误: 在类路径或引导类路径中找不到程序包 java.lang 2、解决方法Linux解决办法，使用maven自带的变量${path.separator}路径分隔符，原因是在Windows下是分号;，在linux下是冒号: 同时配置导入webapp/WEB-INF/lib和jdk的rt.jar、jce.jar，完美解决环境配置带来的无法package找不到依赖问题。 pom.xml：12345678910111213141516171819202122232425262728293031323334&lt;build&gt; &lt;finalName&gt;$&#123;artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;compilerArguments&gt; &lt;verbose /&gt; &lt;bootclasspath&gt;$&#123;java.home&#125;/lib/rt.jar$&#123;path.separator&#125;$&#123;java.home&#125;/lib/jce.jar&lt;/bootclasspath&gt; &lt;extdirs&gt;$&#123;basedir&#125;/src/main/webapp/WEB-INF/lib&lt;/extdirs&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 参考解决Nginx反代Tomcat Http、Https混合内容报错 解决WEB-INF/lib目录下的jar包无法用maven打包 反馈与建议 当了组长面试加运维，对接一堆支付和物流、短信和推送账号，今天记录一下面向DevOps！ markdown原文件在github里面，感谢各位大佬看官star，面试我要往脸上贴金哈哈哈😂。 邮箱：caochikai@qq.com，有问题发邮件。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://caochikai.github.io/tags/Linux/"},{"name":"nginx","slug":"nginx","permalink":"https://caochikai.github.io/tags/nginx/"},{"name":"tomcat","slug":"tomcat","permalink":"https://caochikai.github.io/tags/tomcat/"},{"name":"maven","slug":"maven","permalink":"https://caochikai.github.io/tags/maven/"}]},{"title":"JVM记录","date":"2019-09-14T04:32:49.000Z","path":"2019/09/14/JVM记录/","text":"JVM记录一、错误 背景：自动答题爬虫由于买的腾讯云1核2G1M，Jenkins、springboot爬虫和火狐浏览器驱动。 知识背景：JDWP：调试网络协议(Java Debug Wire Protocol)；调试线协议；jvmti：（Java Virtual Machine Tool Interface）jvm代理； 猜测：Selenium通过driver驱动Firefox浏览器，多次无法关闭浏览器造成内存无法释放最后溢出； 引用文章（有兴趣可深入了解）：jvmti agent黑科技，阿里云云监控； 1FATAL ERROR in native method: JDWP Can&#39;t allocate jvmti memory, jvmtiError&#x3D;JVMTI_ERROR_OUT_OF_MEMORY(110) 反馈与建议 立个flag：不定期更新，一更一周。 markdown原文件在github里面，感谢各位大佬看官star，面试我要往脸上贴金哈哈哈😂。 邮箱：caochikai@qq.com，有问题发邮件。","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"},{"name":"JVM","slug":"JVM","permalink":"https://caochikai.github.io/tags/JVM/"}]},{"title":"工具收藏——idea推荐插件","date":"2019-05-22T12:34:48.000Z","path":"2019/05/22/工具收藏——idea推荐插件/","text":"工具收藏——idea推荐插件一、概念 ​ 工欲善其事必先利其器，博主是个死忠工具派，为了解决一个大问题可能会收集多个工具和方案，然后求证对比出体验报告。后续文章有一大类就是工具类推荐，而本篇文章重点就是idea 安装插件记录，简要记录安装方法快速搭建个性化idea，还有一些关于UI方面插件可谓多不胜数，而且每个人口味不一，请各位自行选择——插件搜索技巧tags为Theme或者UI。 插件列表最强大插件卫冕之王——lambda表达式 名称 描述 JRebel 代替springboot dev热部署方案，最方便激活方式 Lombok 精简bean，各种功能强大又实用注解，搬砖人的MVP，结合Hutool实在完美 AceJump 光标跳跃，替代vim不二之选 MavenHelper 快速分析maven 包冲突的问题，搜索包名 MyBatis Log Plugin Restore the mybatis generate sql to original whole sql.（拼接完整sql） Log Support 2 快速log.info()，结合Lombok插件注解@Slf4j可以说无敌 Free Mybatis plugin Mybaits支持跳转，有钱大爷请收费版Mybatis plugin强大破解较少，差评 Rainbow Brackets 彩虹括号，多层嵌套代码显示助手 String Manipulation 各种各样字符串格式转化 RestfulToolkit 一套 RESTful 服务开发辅助工具集 Alibaba Cloud Toolkit 结合阿里云（非阿里也支持），多节点发布工具加强力linux客户端 stackoverflow stackoverflow快速搜索bug插件 Translation 最强大的翻译插件，支持中文替换英文，解决起英文变量名难的重度患者 Key Promoter X 所有操作的快捷键提示，忘记鼠标真的 Cyan Light Theme A light theme，偏青色对眼睛很柔和舒服，黑暗主题实在不适应 反馈与建议 2012年java程序员可以说非常吃香，今年2019从业人数暴增，职业发展挑战变得越来越大！现在流行自动构建和自动部署CI，开发运维一体化docker，整个互联网都在追求敏捷开发的今天。掌握一款追求效率功能的IDE非常重要，很多群和公众号对ide和Eclipse争议很大。但请记住斯大林名言——落后就要挨打，ide本身代表高效，但是插件也别装太多，免得启动还要半天哈哈哈😀 （首推）慕课网免费教程：IntelliJ IDEA神器使用技巧 （推荐）尚硅谷IDEA视频教程：链接：https://pan.baidu.com/s/11biVBv9EI9yfL6Cee0r0LQ，密码：n7hn 看完上面两个教程，你会怀疑自己用的idea是假的，原来写代码还可以这样的。 邮箱：caochikai@qq.com","tags":[{"name":"idea","slug":"idea","permalink":"https://caochikai.github.io/tags/idea/"},{"name":"tool","slug":"tool","permalink":"https://caochikai.github.io/tags/tool/"},{"name":"plugin","slug":"plugin","permalink":"https://caochikai.github.io/tags/plugin/"}]},{"title":"springboot整合elasticsearch","date":"2019-05-21T13:40:31.000Z","path":"2019/05/21/springboot整合elasticsearch/","text":"springboot整合elasticsearch一、概念 elasticsearch官网是一个分布式多用户能力的全文搜索引擎，也是一个具有RESTful web接口的java应用。目前开源软件商业比较不错的例子，与Solr一样都是基于Lucene，大数据hadoop也是脱胎于Lucene。Solr开源而且生态比较成熟，elasticsearch目前最火也是商业应用方面非常好的搜索引擎。 3w原则： question what：常见站内/app内搜索服务需求：商品文章的模糊搜索，精确搜索，拼音搜索 。 question why：借助elasticsearch和analysis-ik中文分词器，快速实现搜索服务功能。 how：在微服务当中，通常利用mq消息中间件来同步数据集群搜索服务（脚手架里没有mq），借助ElasticsearchTemplate（spring 模板工具类强大）API维护索引和搜索查询。 二、落地实现 根据码云企业级搜索脚手架的文档可知，注意版本为Springboot2.1.1+elasticsearch6.5.3，elasticsearch和analysis-ik插件版本必须统一，而且新版本elasticsearch 7不适用于该工程。这个参考工程的中文分词搜索效果不太理想，一般富文本的内容进入索引之前要利用字符过滤器清洗不正常的字符。通常为了保证索引时覆盖度和搜索时准确度,索引分词器采用ik_max_word,搜索分析器采用ik_smart模式。具体elasticsearch6.5.3的安装过程请参考码云的README.md，目前正在在公司项目使用请放心，单元测试的效果也非常nice。 1、添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置引导类12345#============================# 默认的节点名称elasticsearchspring.data.elasticsearch.cluster-name=my-application# elasticsearch 调用地址，多个使用“,”隔开spring.data.elasticsearch.cluster-nodes=localhost:9300 3、DWMQSender包装rabbitTemplate发送消息同步数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//服务类的简写如下&#123;//注入sender @AutowiredDWMQSender sender;//发送写法ArticlesMessage extends DWMQMessage&lt;消息内容类型&gt;JSONObject jsonObject = JSON.parseObject(JSON.toJSONString(articles)); jsonObject.put(Groups.ACTION, Groups.ADD); sender.sendMessage(new ArticlesMessage(jsonObject));&#125;//封装发送mq messageimport com.alibaba.fastjson.JSON;import com.dwalk.common.exception.EU;import com.dwalk.common.mq.mto.DWMQMessage;import com.dwalk.common.utils.SU;import com.rabbitmq.client.Channel;import lombok.extern.slf4j.Slf4j;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.amqp.AmqpException;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.MessagePostProcessor;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.amqp.rabbit.support.CorrelationData;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.util.concurrent.atomic.AtomicLong;/** * 消息成功发送到MQ服务器后的回调确认 */@Slf4j@Componentpublic class DWMQSender &#123; @Autowired RabbitTemplate rabbitTemplate; @Autowired DWMQRetry retry; // public void sendMessage(DWMQMessage mto) &#123; if( mto.getObj()==null ) &#123; EU.te(\"消息内容为空\"); &#125; if( SU.isNull( mto.getRoutingKey()) ) &#123; EU.te(\"路由规则为空\"); &#125; log.info(String.format(\"准备发送【%s】\", mto.getInfo())); mto.setId(retry.generateId()); if( SU.isNull(mto.getExchange()) &amp;&amp; mto.getExpire()&lt;1 ) &#123; //默认的没有交换器，则直接发送到指定的队列 rabbitTemplate.convertAndSend(mto.getRoutingKey(), mto.getObj(), new CorrelationData(mto.getId())); &#125; else if (mto.getExpire()&lt;1)&#123; //经过交换器，按路由规则匹配队列 rabbitTemplate.convertAndSend(mto.getExchange(), mto.getRoutingKey(), mto.getObj(), new CorrelationData(mto.getId())); &#125; else &#123; //默认的没有交换器，则直接发送到指定的队列，发送延迟消息 rabbitTemplate.convertAndSend(mto.getRoutingKey(), mto.getObj(), message -&gt; &#123; message.getMessageProperties().setExpiration(mto.getExpire()+\"\"); return message; &#125;, new CorrelationData(mto.getId())); &#125; mto.setCtime(System.currentTimeMillis()); retry.add(mto, this); &#125;&#125; 4、RabbitListener接收到消息同步数据123456789101112131415161718192021222324252627282930313233343536373839/** * 搜索服务接收到管理后台用户修改文章同步消息 */@Component@Slf4j//配置mq消息队列，接收文件同步消息@RabbitListener(queues = DirectMQConfig.DIRECT_ARTICLES_ELASTIC_QUEUE)public class ArticlesReceiver extends DWMQBaseReceiver&lt;String&gt; &#123; @Autowired private ArticleETOService etoService; @Override public Class getClazz() &#123; return String.class; &#125; @Override public boolean processMessage(String mto) &#123; log.info(\"Received 管理后台用户-修改文章同步消息接收:&#123;&#125;\", mto); JSONObject jsonObject = JSON.parseObject(mto); String action = jsonObject.getString(Groups.ACTION); //删除操作要删除索引，更新操作先删除后 ArticleETO articles = JSON.parseObject(jsonObject.toJSONString(), ArticleETO.class); String articlesId = articles.getId(); switch (action) &#123; case Groups.ADD: etoService.save(articles); break; case Groups.UPDATE: etoService.delete(articlesId); etoService.save(articles); break; case Groups.DELETE: etoService.delete(articlesId); break; &#125; return true; &#125;&#125; 5、公共搜索方法12345678910111213141516171819202122232425262728/** * 高亮显示，返回分页 * @auther: zhoudong * @date: 2018/12/18 10:29 */ @Override public IPage&lt;Map&lt;String, Object&gt;&gt; queryHitByPage(int pageNo, int pageSize, String keyword, String indexName, String... fieldNames) &#123; // 构造查询条件,使用标准分词器. QueryBuilder matchQuery = createQueryBuilder(keyword, fieldNames); // 设置高亮,使用默认的highlighter高亮器 HighlightBuilder highlightBuilder = createHighlightBuilder(fieldNames); // 设置查询字段 SearchResponse response = elasticsearchTemplate.getClient().prepareSearch(indexName) .setQuery(bool) .highlighter(highlightBuilder) .setFrom((pageNo - 1) * pageSize) .setSize(pageNo * pageSize) // 设置一次返回的文档数量，最大值：10000 .get(); // 返回搜索结果 SearchHits hits = response.getHits(); Long totalCount = hits.getTotalHits(); IPage&lt;Map&lt;String, Object&gt;&gt; page = new Page&lt;&gt;(pageNo, pageSize, totalCount); page.setRecords(getHitList(hits)); return page; &#125; 反馈与建议 今天终于出了elasticsearch文章，以后我会在对应专题的文章放出相关的百度云资源，这些都是网上流传比较广的资源，想找好的学习资源也可以与我合伙买绝版视频，有钱买正版吧（作者很穷，找工作从来没有造假包装，只能混成这个卵样😭，世道维艰，如果不是感觉做码农还算有点天赋，早就转行了）。 百度云 :下载街/01.Elasticsearch顶尖高手系列课程，密码：iw7f 邮箱：caochikai@qq.com","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://caochikai.github.io/tags/elasticsearch/"}]},{"title":"Springboot整合Quartz定时器","date":"2019-05-20T12:25:37.000Z","path":"2019/05/20/Spring boot整合Quartz定时器/","text":"Spring boot整合Quartz定时器一、概念 quartz官网是一个完全由 Java 编写的开源作业调度框架，结合数据库甚至可以做到分布式调度。目前参考的RuoYi后台脚手架的定时任务模块，支持在线（添加、修改、删除)任务调度，并记录执行日志作业结果。 3w原则： question what：定时任务，比如定时答题、商家结算等需求，并且支持立即运行、暂停和禁止。 question why：借助quartz springboot生态和后台脚手架，快速实现定时调度功能。 how：实现JobDetail运行任务详情，Trigger 触发器定义触发规则，Scheduler 调度中心/容器注册多个 JobDetail 和 Trigger。Trigger 与 JobDetail 组合即可被Scheduler调用。 二、落地实现 根据若依脚手架的文档可知，定时任务工程模块为ruoyi-quartz，结合sql/quartz.sql导入关于定时器数据库表。当然这种做法需要数据库和bootstrap，为了简化，我采取的替代方案是保留定时和立即执行功能，抛弃手动在代码硬编码新加定时器，web管理面板则通过swagger触发任务调度立即执行一次。极端偷懒方式，@Scheduled(cron = “”)放在在cotroller方法，同事推荐给我的😀。 1、添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置引导类1234567//模块加载@EnableScheduling@EnableSwagger2@SpringBootApplicationpublic class WeixinApplication &#123;......&#125; 3、注册JobDetail和Trigger1234567891011121314151617181920212223/** * 在线表达式：http://cron.qqe2.com/ */@Slf4j@Configurationpublic class QuartzConfig &#123; public static final String TASK_CLASS_NAME = \"reportNowTask\"; @Bean public JobDetail reportNowTask() &#123; return JobBuilder.newJob(reportNowTask.class).withIdentity(TASK_CLASS_NAME).storeDurably().build(); &#125; @Bean public Trigger reportNowTaskTrigger(JobDetail reportNowTask) &#123; //cronSchedule等于@Scheduled(cron = \"\"),但是通过注解无法配置jobkey return TriggerBuilder.newTrigger().forJob(reportNowTask) .withIdentity(\"reportNowTaskTrigger\") .withSchedule(CronScheduleBuilder.cronSchedule(\"9 0 19 * * ?\")) .build(); &#125;&#125; 4、任务详情继承QuartzJobBean或者实现Job接口12345678@Slf4jpublic class reportNowTask extends QuartzJobBean &#123; @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123; ......//任务内容 &#125;&#125; 5、立即执行123456789101112131415161718@Slf4j@Api(tags = \"问题模块\")@RequestMapping(value = \"question\")@RestControllerpublic class QuestionController &#123; /** * 任务调度立即执行一次 */ @PostMapping(\"/run\") @ResponseBody public ResponseEntity run() throws SchedulerException &#123; //api秘诀就在这里根据QuartzConfig jobKey触发作业调度 scheduler.triggerJob(JobKey.jobKey(QuartzConfig.TASK_CLASS_NAME)); return ResponseEntity.ok(\"执行成功！\"); &#125;&#125; 反馈与建议 今天粗略简易版的定时任务,功能强大的请查看若依后台脚手架,github和码云有很多类似脚手架,但是我们有选择性copy学习才是重点😊。 邮箱：caochikai@qq.com","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"},{"name":"quartz","slug":"quartz","permalink":"https://caochikai.github.io/tags/quartz/"}]},{"title":"springboot源码分析之启动过程","date":"2019-05-19T13:50:35.000Z","path":"2019/05/19/springboot源码分析之启动过程/","text":"springboot源码分析之启动过程一、概念 计划写一波springboot 2.x源码分析，只写实用性比较高的特性，从GitHub上看出更新频率在一个月左右，更新极快非常活跃。 版本发行: 版本 时间线 说明 v0.5.0.M1 2013-08-06 第一个版本 v2.2.0.M3 2019-05-15 当前最新版本 二、源码分析 SpringBoot的启动引导类写法多样，标记了@SpringBootApplication的class作为源类，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//简易版@SpringBootApplication public class MyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyApplication.class, args); &#125; &#125;//通过 SpringApplicationBuilder API@SpringBootApplicationpublic class DiveInSpringBootApplication &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(DiveInSpringBootApplication.class) .bannerMode(Banner.Mode.CONSOLE) .web(WebApplicationType.NONE) .profiles(\"prod\") .headless(true) .run(args); &#125;&#125;//声明newpublic class SpringApplicationBootstrap &#123; public static void main(String[] args) &#123;// SpringApplication.run(ApplicationConfiguration.class,args); Set sources = new HashSet(); // 配置Class 名称 sources.add(ApplicationConfiguration.class.getName()); SpringApplication springApplication = new SpringApplication(); //配置源 springApplication.setSources(sources); //配置控制台banner springApplication.setBannerMode(Banner.Mode.CONSOLE); //声明web类型 springApplication.setWebApplicationType(WebApplicationType.NONE); //多环境配置激活 springApplication.setAdditionalProfiles(\"prod\"); //java.awt.headless禁用模式 springApplication.setHeadless(true); springApplication.run(args); &#125; @SpringBootApplication public static class ApplicationConfiguration &#123; &#125;&#125; 从代码上可以看出，调用了SpringApplication的静态方法run。这个run方法会构造一个SpringApplication的实例，然后再调用这里实例的run方法就表示启动SpringBoot。因此，想要分析SpringBoot的启动过程，我们需要熟悉SpringApplication的构造过程以及SpringApplication的run方法执行过程即可。 SpringApplication的准备过程 配置 Spring Boot Bean 源：Java 配置 Class 或 XML 上下文配置文件集合，用于 Spring Boot BeanDefinitionLoader 读取 ，并且将配置源解析加载为Spring Bean 定义。 推断 Web 应用类型：根据当前应用 ClassPath 中是否存在相关实现类来推断 Web 应用的类型。参考方法：org.springframework.boot.SpringApplication#deduceWebApplicationType。 123456789101112private WebApplicationType deduceWebApplicationType() &#123; if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null) &amp;&amp; !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)) &#123; return WebApplicationType.REACTIVE; &#125; for (String className : WEB_ENVIRONMENT_CLASSES) &#123; if (!ClassUtils.isPresent(className, null)) &#123; return WebApplicationType.NONE; &#125; &#125; return WebApplicationType.SERVLET;&#125; 推断引导类（Main Class）：根据 Main 线程执行堆栈判断实际的引导类。参考方法： org.springframework.boot.SpringApplication#deduceMainApplicationClass 123456789101112131415private Class deduceMainApplicationClass() &#123; try &#123;//获取堆栈输出方法名称 StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) &#123; if (\"main\".equals(stackTraceElement.getMethodName())) &#123; return Class.forName(stackTraceElement.getClassName()); &#125; &#125; &#125; catch (ClassNotFoundException ex) &#123; // Swallow and continue &#125; return null; &#125; 加载应用上下文初始器 （ ApplicationContextInitializer ）：利用 Spring 工厂加载机制，实例化 ApplicationContextInitializer 实现类，并排序对象集合。 1234567891011121314//实现类： org.springframework.core.io.support.SpringFactoriesLoader//配置资源： META-INF/spring.factories//排序： AnnotationAwareOrderComparator#sortprivate Collection getSpringFactoriesInstances(Class type, Class[] parameterTypes, Object... args) &#123; ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); // Use names and ensure unique to protect against duplicates Set names = new LinkedHashSet&lt;&gt;( SpringFactoriesLoader.loadFactoryNames(type, classLoader)); List instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); AnnotationAwareOrderComparator.sort(instances); return instances; &#125;· 加载应用事件监听器（ ApplicationListener ）：利用 Spring 工厂加载机制，实例化 ApplicationListener 实现类，并排序对象集合。 SpringApplication 运行阶段 加载 SpringApplication 运行监听器（ SpringApplicationRunListeners ）：利用 Spring 工厂加载机制，读取 SpringApplicationRunListener 对象集合，并且封装到组合类SpringApplicationRunListeners。 运行 SpringApplication 运行监听器（ SpringApplicationRunListeners ）： started(run方法执行的时候立马执行；对应事件的类型是ApplicationStartedEvent) environmentPrepared(ApplicationContext创建之前并且环境信息准备好的时候调用；对应事件的类型是ApplicationEnvironmentPreparedEvent) contextPrepared(ApplicationContext创建好并且在source加载之前调用一次；没有具体的对应事件) contextLoaded(ApplicationContext创建并加载之后并在refresh之前调用；对应事件的类型是ApplicationPreparedEvent) finished(run方法结束之前调用；对应事件的类型是ApplicationReadyEvent或ApplicationFailedEvent) 创建 Spring 应用上下文（ ConfigurableApplicationContext ）:根据准备阶段的推断 Web 应用类型创建对应ConfigurableApplicationContext 实例： Web Reactive： AnnotationConfigReactiveWebServerApplicationContext Web Servlet： AnnotationConfigServletWebServerApplicationContext 非 Web： AnnotationConfigApplicationContext 创建 Environment：根据准备阶段的推断 Web 应用类型创建对应的 ConfigurableEnvironment 实例。 Web Reactive： StandardEnvironment Web Servlet： StandardServletEnvironment 非 Web： StandardEnvironment run方法分析1234567891011121314151617181920212223242526272829303132public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); // 构造一个任务执行观察器 stopWatch.start(); // 开始执行，记录开始时间 ConfigurableApplicationContext context = null; configureHeadlessProperty(); // 获取SpringApplicationRunListeners，内部只有一个EventPublishingRunListener SpringApplicationRunListeners listeners = getRunListeners(args); // 上面分析过，会封装成SpringApplicationEvent事件然后广播出去给SpringApplication中的listeners所监听 // 这里接受ApplicationStartedEvent事件的listener会执行相应的操作 listeners.started(); try &#123; // 构造一个应用程序参数持有类 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // 创建Spring容器 context = createAndRefreshContext(listeners, applicationArguments); // 容器创建完成之后执行额外一些操作 afterRefresh(context, applicationArguments); // 广播出ApplicationReadyEvent事件给相应的监听器执行 listeners.finished(context, null); stopWatch.stop(); // 执行结束，记录执行时间 if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; // 返回Spring容器 &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, ex); // 这个过程报错的话会执行一些异常操作、然后广播出ApplicationFailedEvent事件给相应的监听器执行 throw new IllegalStateException(ex); &#125;&#125; 反馈与建议 为了快大多分析的不好写的很乱，凑合看下我以后改下排版😂。 邮箱：caochikai@qq.com","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"},{"name":"quartz","slug":"quartz","permalink":"https://caochikai.github.io/tags/quartz/"}]},{"title":"地理定位业务实现","date":"2019-05-18T12:19:01.000Z","path":"2019/05/18/地理定位业务实现/","text":"地理定位业务实现一、概念3w原则： question what：a、附近一定范围的目标（电子围栏）；b、该经纬度的地理位置名称（省市县街道）。 why：解决上述问题的本质是获得经纬度，途径为硬件、GPS定位服务、基站定位，地理位置通过百度、谷歌、腾讯地图，基本所有地图免费版都有日访问量限制。 how：通过安卓或者IOS获取经纬度，再借助百度地图接口获取地理位置，距离也可通过接口或者谷歌地图算法。 GPS是英文Global Positioning System（全球定位系统）的简称。 二、解决方式 场景：小程序获取附近的好友，微信官方文档 wx.getLocation(Object object)。 现象：需要用户授权，前端获得gps 坐标通过接口传数据后台，保存到用户表（1：1关系）。 地图选择：其实纯前端基本也能解决基本问题，腾讯地图对小程序支持最好，根据JavaScript SDK文档可以拥有如下功能：绘制地图，地点搜索，关键词输入提示，逆地址解析（坐标位置描述），地址解析（地址转坐标，路线规划，距离计算，获取城市列表，获取城市区县。 业务前提：用户必须授权才能使用该功能，当拥有所有用户经纬度，通过数据库语句获取当前用户经纬度在一定距离，并且可以排行。 三、落地编码sql版例子：123456789101112131415161718192021222324252627#mysql版，根据谷歌地图公式计算点歌经纬度之间距离，单位为m（米）select e.id, e.longitude, e.latitude, ROUND( 6378.138 * 2 * ASIN( SQRT( POW( SIN( ( e.latitude * PI() / 180 - 23.12463 * PI() / 180 ) / 2 ), 2 ) + COS(e.latitude * PI() / 180) * COS(23.12463 * PI() / 180) * POW( SIN( ( e.longitude * PI() / 180 - 113.36189 * PI() / 180 ) / 2 ), 2 ) ) ) * 1000 ) AS distanceFROM dw_dbei_user ehaving distance &lt; 4000 工具类（获取两点距离）：12345678910111213141516171819202122232425262728293031323334public class MapUtils &#123; //private static double EARTH_RADIUS = 6378.137; private static double EARTH_RADIUS = 6371.393; private static double rad(double d) &#123; return d * Math.PI / 180.0; &#125; /** * 计算两个经纬度之间的距离 * * @param lat1 纬度1 * @param lng1 经度1 * @param lat2 纬度2 * @param lng2 经度2 * @return 计算结果单位：米 */ public static double GetDistance(double lat1, double lng1, double lat2, double lng2) &#123; double radLat1 = rad(lat1); double radLat2 = rad(lat2); double a = radLat1 - radLat2; double b = rad(lng1) - rad(lng2); double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(b / 2), 2))); s = s * EARTH_RADIUS; s = Math.round(s * 1000); return s; &#125; public static void main(String[] args) &#123; double v = GetDistance(113.36199, 23.12463, 113.36189, 23.12463); System.out.println(v); &#125;&#125; 反馈与建议 尽量每天不断更，做个自律者，markdown原文件在github里面，感谢各位大佬看官star，面试我要往脸上贴金哈哈哈😂。 邮箱：caochikai@qq.com","tags":[{"name":"sql","slug":"sql","permalink":"https://caochikai.github.io/tags/sql/"},{"name":"im","slug":"im","permalink":"https://caochikai.github.io/tags/im/"}]},{"title":"初探缓存","date":"2019-05-17T15:34:21.000Z","path":"2019/05/17/初探缓存/","text":"多级缓存架构缓存设计理念： 缓存常用的对象或者数据，减少系统开销提高效率。 缓存命中率 即从缓存中读取数据的次数 与 总读取次数的比率，命中率越高越好： 缓存策略： 移除策略：FIFO（First In First Out），LRU（Least Recently Used），LFU（Least Frequently Used）。 TTL（Time To Live）：缓存存活期 TTI（Time To Idle）：空闲存活期 spring cache 一、概念 自Spring 3.1起，提供注解缓存，并且提供事务回滚时也自动回滚缓存，并且支持SPEL表达式。 二、入门代码1、添加依赖，例如maven的pom.xml(Springboot); 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 2、添加一种cacheManager的bean实现类，常见ConcurrentMapCache、EhCacheCache、RedisCache； 123456@Beanpublic CacheManager cacheManager() &#123; SimpleCacheManager cacheManager &#x3D; new SimpleCacheManager(); cacheManager.setCaches(Collections.singletonList(new ConcurrentMapCache(&quot;models&quot;))); return cacheManager;&#125; 3、配置模块加载注解@EnableCaching 三、主要注解1、@Cacheable：将方法返回值作为缓存 value (也可使用 cacheNames) : 可看做命名空间，表示存到哪个缓存里了。 key : 表示命名空间下缓存唯一key,使用Spring Expression Language(简称SpEL,详见参考文献[5])生成。 condition : 表示在哪种情况下才缓存结果(对应的还有unless,哪种情况不缓存),同样使用SpEL 2、@CacheEvict：删除缓存注解 3、@CachePut：刷新注解 ehcache 一、概念二、入门代码1、缓存分组，要对分组进行全新CacheConfiguration ，为了高效使用配置自定义属性提取器。默认的属性处理器是JavaBeanAttributeExtractor。 123456789101112131415161718192021222324252627282930@Bean public EhCacheGroupBeanPostProcessor addCache() &#123; System.out.println(&quot;.......添加缓存组........&quot;); return new EhCacheGroupBeanPostProcessor(); &#125; &#x2F;&#x2F;后置处理器 public static class EhCacheGroupBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; &#x2F;&#x2F;根据前面初始化完成的beanName进一步操作 if(beanName.equals(&quot;appEhCacheCacheManager&quot;) ) &#123; EhCacheCacheManager manager &#x3D; (EhCacheCacheManager)bean; CacheManager cacheManager &#x3D; manager.getCacheManager();&#x2F;&#x2F; 文章缓存命中配置needUpdate CacheConfiguration configuration &#x3D; new CacheConfiguration(ReadCacheNames.文章缓存,10000); Searchable searchable &#x3D; new Searchable(); searchable.setKeys(false); searchable.setValues(false); &#x2F;&#x2F;动态索引 searchable.setAllowDynamicIndexing(true); searchable.addSearchAttribute(new SearchAttribute().name(&quot;needUpdate&quot;).className(&quot;com.dwalk.social.common.util.ArticlesAttributeExtractor&quot;)); configuration.eternal(true).addSearchable(searchable); Cache articlesCache &#x3D; new Cache(configuration); cacheManager.addCache(articlesCache); cacheManager.addCache(ReadCacheNames.热点文章缓存); &#125; return bean; &#125; &#125; 2、使用spring内置定时器，并使用ehcache查询api进行缓存查询。 123456789101112131415161718192021222324 @Scheduled(cron &#x3D; &quot;0 0&#x2F;1 * * * ?&quot;) private void synchronize() &#123; Cache cache &#x3D; cacheManager.getCache(ReadCacheNames.文章缓存); int size &#x3D; cache.getSize(); if (size &gt; 0) &#123; Query query &#x3D; cache.createQuery(); Attribute searchAttribute &#x3D; cache.getSearchAttribute(&quot;needUpdate&quot;); &#x2F;&#x2F;指定查询的 query.includeAttribute(searchAttribute); query.includeValues(); Results execute &#x3D; query.addCriteria(searchAttribute.eq(true)).execute(); List all &#x3D; execute.all(); log.info(&quot;查询文章缓存的大小：&#123;&#125;&quot;, all.size()); for (Result result : all) &#123; ArticlesDTO articles &#x3D; (ArticlesDTO) result.getValue(); articles.setNeedUpdate(false); Articles target &#x3D; new Articles();&#x2F;&#x2F; 同步浏览量、视频播放量、评论数、点赞数、收藏数 target.setVisitorNum(articles.getVisitorNum()).setCommentNum(articles.getCommentNum()). setPlayNum(articles.getPlayNum()).setLikeNum(articles.getLikeNum()).setCollectNum(articles.getCollectNum()); articlesService.updateById(target); &#125; &#125; &#125; 三、总结1、需要熟悉spring接口设计，以接口使用框架，要不然官方api使用需了解诸多细节。 四、一二级缓存 当遇到@Cacheable返回为null记录，为了成功序列化null，使用了org.springframework.cache.support.NullValue对象代替null。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889com.alibaba.fastjson.JSONException: autoType is not support. org.springframework.cache.support.NullValue1、起源一二级缓存重写get()方法public class EhRedisCache extends AbstractValueAdaptingCache &#123; 部分代码省略…… @Override public T get(Object key, Callable valueLoader) &#123; try &#123; lock.lock(); value &#x3D; lookup(key); if(value !&#x3D; null) &#123; return (T) value; &#125; value &#x3D; valueLoader.call(); &#x2F;&#x2F;toStoreValue是AbstractValueAdaptingCache抽象类的方法 Object storeValue &#x3D; toStoreValue(value); put(key, storeValue); return (T) value; &#125; catch (Exception e) &#123; throw new ValueRetrievalException(key, valueLoader, e.getCause()); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;2、toStoreValue判断userValue &#x3D;&#x3D; null 则return NullValue.INSTANCE -&gt; public static final Object INSTANCE &#x3D; new NullValue();public abstract class AbstractValueAdaptingCache implements Cache &#123; protected Object toStoreValue(@Nullable Object userValue) &#123; if (userValue &#x3D;&#x3D; null) &#123; if (this.allowNullValues) &#123; return NullValue.INSTANCE; &#125; throw new IllegalArgumentException( &quot;Cache &#39;&quot; + getName() + &quot;&#39; is configured to not allow null values but null was provided&quot;); &#125; return userValue; &#125;&#125;3、序列化反序列化public class FastJsonRedisSerializer implements RedisSerializer &#123; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if (null &#x3D;&#x3D; bytes || bytes.length &lt;&#x3D; 0) &#123; return null; &#125; String str &#x3D; new String(bytes, DEFAULT_CHARSET); return (T) JSON.parseObject(str, clazz); &#125;&#125;4、jsonParser解析类型public class com.alibaba.fastjson.parser.DefaultJSONParser implements Closeable &#123; public final Object parseObject(final Map object, Object fieldName) &#123; 部分代码省略…… Class clazz &#x3D; null; if (object !&#x3D; null &amp;&amp; object.getClass().getName().equals(typeName)) &#123; clazz &#x3D; object.getClass(); &#125; else &#123; &#x2F;&#x2F;com.alibaba.fastjson.parser.DefaultJSONParser#config执行 clazz &#x3D; config.checkAutoType(typeName, null, lexer.getFeatures()); &#125; &#125;&#125;5、异常抛出点TypeUtils.getClassFromMapping(typeName) -》 typeName为org.springframework.cache.support.NullValuepublic Class checkAutoType(String typeName, Class expectClass, int features) &#123; if (Arrays.binarySearch(denyHashCodes, hash) &gt;&#x3D; 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) &#x3D;&#x3D; null) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125;&#125;6、TypeUtils的getClassFromMapping方法返回null public static Class getClassFromMapping(String className)&#123; return mappings.get(className); &#125;7、TypeUtils不支持org.springframework.cache.support.NullValueprivate static ConcurrentMap&gt; mappings &#x3D; new ConcurrentHashMap&gt;(16, 0.75f, 1);&#x2F;&#x2F;mappings类型白名单private static void addBaseClassMappings()&#123; mappings.put(&quot;byte&quot;, byte.class); mappings.put(&quot;short&quot;, short.class); mappings.put(&quot;int&quot;, int.class); mappings.put(&quot;long&quot;, long.class); mappings.put(&quot;float&quot;, float.class); mappings.put(&quot;double&quot;, double.class); mappings.put(&quot;boolean&quot;, boolean.class); 部分代码省略…… fastJson官方没有支持org.springframework.cache.support.NullValue&#125; 反馈与建议 今天复出写博客，一是感觉懒了期望进步，二是为了积累知识方便copy😂。 邮箱：&#99;&#x61;&#111;&#x63;&#x68;&#105;&#x6b;&#x61;&#x69;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#109;","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"}]},{"title":"AndroidAdb","date":"2017-02-05T12:49:09.000Z","path":"2017/02/05/AndroidAdb/","text":"Android adb调试工具–清除锁屏密码误解@(Android)[调试工具|实用教程|adb命令] Android Studio ADB官方文档 ADB全称为 Android Debug Bridge, 是android 里的一个调试工具, 用这个工具可以直接操作管理android模拟器或者真实的andriod设备手机。如果你安装了Android SDK（或者下载adb工具包，体积小）,存放sdk的platform-tools目录下，在 命令行cmd使用需要配置路径（android_sdk/platform-tools/adb.exe ）到环境变量里。它可为各种设备操作提供便利，如安装和调试应用，例如查看android中的数据库，提供对 Unix shell（可用来在模拟器或连接的设备上运行各种命令）的访问。该工具作为一个客户端-服务器程序，包括三个组件： 客户端 ：该组件发送命令。客户端在开发计算机上运行。您可以通过发出 adb 命令从命令行终端调用客户端； 后台程序 ：该组件在设备上运行命令。后台程序在每个模拟器或设备实例上作为后台进程运行； 服务器 ：该组件管理客户端和后台程序之间的通信。服务器在开发计算机上作为后台进程运行。 关于清除解锁图案 用户相关的文件accounts.db（gmail账号管理），gesture.key（手势识别文件），password.key（密码文件）。不同品牌手机系统相关文件名也会不同,例如我的手机，华为4x文件为locksettings.db（数据库文件）。修理店里的师傅使用一个工具叫星海神器（高通平台强刷），功能超乎想象，几乎支持所有手机品牌（特别是苹果）淘宝上有卖，网上大部分加密过！小米手机叫丢失解锁神器！ 1. 破解条件 手机打开USB并连接电脑 手机被ROOT，并且ADB可以直接升级为ROOT用户 配置adb路径到环境变量或者直接在cmd命令行里面切换到adb所在路径 2. 破解步骤 *打开cmd命令行，用【adb shell】命令进入shell * 利用su命令将adb提升为root用户，如果成功，行首由$变成 #，#表示root用户 *进入data/system目录 * *ls查看当前目录 * *用ls命令查看密码文件 * 用rm命令删除密码文件，若是$（不是root），则会提示”rm failed for … Permission denied”，权限不足 12345$ adb shell $ su# cd /data/system# ls# rm locksettings.db 输入reboot或手动重启手机生效。亲测华为荣耀4X有效，删除锁屏密码后，指纹解锁自动失效，所以此方法也可以破解指纹解锁！！重新设置锁屏密码后，以前设置的指纹解锁又可以用了。 3. 注意事项看到这儿就明白了，即便手机Root+打开USB调试，也是无法通过ADB解锁手机的。因为想要想要解锁，就得删除/data/system 下的相关文件，可删除需要由Superuser或者kingroot授予ADB shell权限，而授权需要解锁打开手机后操作Superuser程序。即解锁需要用到解锁后的手机操作，就像春晚小品《开锁》中，业主黄宏要求开锁师傅林永健开锁，林永健要求黄宏出示有效证件，可证件就在锁着的箱子里头。 我进行了测试后发现，在授权过一次后，下次手机用USB数据线连接电脑，再次进行解锁，即便同台电脑，也是需要再次授权的。这就说明，即便你用你的电脑经过手机授权解锁过，过后想要在忘记密码时使用ADB方式解锁，也是不可能的。 我觉得这是高版本的安卓系统（eg. Android 4.2 Jelly Bean 安卓果冻豆）新有的安全特性，低版本的Android如安卓2.3.8是可以通过这种方法解锁的。因为我实际测试，我的固件版本为安卓2.3.8的三星S5570（已经Root，打开USB调试），执行命令rm gesture.key，无需授权，直接即可解锁。现在我有个问题，低版本安卓系统如 Android2.3.8的手机解锁屏幕锁定密码，是否的确必须Root，还是只要打开USB调试即可？我手头没有没Root的Android2.3手机，也懒得折腾了，就不管它了。 这样看来，高版本的安卓系统也就不存在被非手机所有者恶意解锁的BUG了。4. 题外话（今年好东西都挂了）收费音乐神器官网，服务器接口平台AnyListen 音乐间谍为window PC版，音乐助手Android版，Shelher微博分享出来3.3版源码百度云 ​​​​密码gria！尴尬的是朋友云免流量也不干了！","tags":[]},{"title":"SpiderWebMagic","date":"2017-01-30T12:50:27.000Z","path":"2017/01/30/SpiderWebMagic/","text":"WebMagic爬虫框架–京东图书@(爬虫)[框架|爬虫|Demo总结] WebMagic!项目代码分为核心(webmagic-core)和扩展(webmagic-extension)两部分(jar包)。Downloader、PageProcessor、Scheduler、Pipeline这四大组件对应爬虫生命周期中的下载、处理、管理和持久化等功能。 名称 功能 Downloader 基础。利用httpClient作为下载工具，下载页面内容便于后续处理解析; Page 网页内容对象。 指根据url下载到的页面内容，包括页面dom元素，css样式，javascript等; Pageprocess 爬虫的核心。 负责解析页面，抽取有用信息，可采用css(),$(),xpath()方法对特定页面元素进行抽取; Site 网站设置。设置网站domain，cookies,header,重试次数,访问间隔时间等; Scheduler 抓取页面队列。 管理待抓取的URL，以及一些去重的工作，将目标url内容push到抓取队列中; Pipeline 输出，收尾。 负责抽取结果的处理，包括计算、持久化到文件、数据库; Spider 爬虫的入口类 采用链式设计，通过它来设定多线程，页面解析器，调度以及输出方式等。 WebMagic官方链接： 官网 包含官方文档和源码,以及相应的实例； github 仓库保存最新版本； oschinamayun码云 包含所有编译好的依赖包； 爬取京东图书(https://book.jd.com/)在商品列表网页抓取如下商品信息 商品名：商品名称 商品网页：显示商品详细信息的网页地址。 市场价格：京东给出的市面价格 京东价格：京东的优惠价。 关于ajax价格链接地址格式：http://p.3.cn/prices/mgets?skuIds=J_ + 商品ID，抓取格式为json。 https://item.jd.com/12087016.html ：图书详情页； http://p.3.cn/prices/mgets?skuIds=J_12087016 （例）价格ajax请求链接； [{“id”:”J_12087016”,”p”:”60.80”,”m”:”90.00”,”op”:”60.80”}] 抓取结果 id + 京东实际价格+市场价格 代码块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import us.codecraft.webmagic.Page;import us.codecraft.webmagic.Site;import us.codecraft.webmagic.Spider;import us.codecraft.webmagic.processor.PageProcessor;import java.util.ArrayList;import java.util.List;public class JDPageProcesser implements PageProcessor &#123; private Site site = Site.me().setRetryTimes(3).setSleepTime(3000).setCharset(\"GBK\"); private static int size = 0;// 共抓取到的图书数量 //抓取商品信息集合 private static List&lt;String&gt; name = new ArrayList&lt;String&gt;();//所有的书名 private static List&lt;String&gt; author = new ArrayList&lt;String&gt;();//所有的作者 private static List&lt;Double&gt; prices = new ArrayList&lt;Double&gt;();//所有的价格 @Override public void process(Page page) &#123; //图书主页 // https://item.jd.com/12004057.html if (!page.getUrl().regex(\"https://item.jd.com/\\\\d&#123;8&#125;.html\").match()&amp;!page.getUrl().regex(\"p.3.cn/prices/mgets\").match()) &#123; // 主页中添加商品详情页到计划url List&lt;String&gt; detail = page.getHtml().links().regex(\"//item.jd.com/\\\\d&#123;8&#125;.html\").replace(\"//\", \"https://\").all(); //控制抓取商品的数量 if (detail.size()&gt;0) &#123; for (int i = 0; i &lt; 4; i++) &#123; String url = detail.get(i); System.out.println(\"url:\" + url.replace(\"https://item.jd.com\", \"\").replace(\"/\", \"http://p.3.cn/prices/mgets?skuIds=J_\").replace(\".html\", \"\")); //列队添加一条详情页后面追加一条价格ajax链接 page.addTargetRequest(url); page.addTargetRequest(url.replace(\"https://item.jd.com\", \"\").replace(\"/\", \"http://p.3.cn/prices/mgets?skuIds=J_\").replace(\".html\", \"\")); &#125; &#125; &#125; if (page.getUrl().regex(\"https://item.jd.com/\\\\d&#123;8&#125;.html\").match()) &#123; // 商品详情页 size++; name.add(page.getHtml().xpath(\"//div[@id=name]/h1/text()\").get());//添加书名 author.add(page.getHtml().xpath(\"//div[@id=p-author]/a/text()\").get());//添加作者 &#125; if (page.getUrl().regex(\"p.3.cn/prices/mgets\").match()) &#123; //ajax商品id对应价格json接口 prices.add(Double.parseDouble(page.getHtml().replace(\"&amp;quot\", \"\").regex(\"p;:;.+;,;m\").regex(\"\\\\d+\\\\.\\\\d+\").get()));//添加价格 &#125; &#125; @Override public Site getSite() &#123; return site; &#125; //获取所有信息导入DAO,持久化层待实现 private static void getAll() &#123; System.out.println(\"Size\" + name.size() + author.size() + prices.size()); for (int i = 0; i &lt; name.size(); i++) &#123; JDLog model = new JDLog(); model.setName(name.get(i)); model.setAuthor(author.get(i)); model.setPrices(prices.get(i)); System.out.println(\"书名:\" + model.getName()); System.out.println(\"作者:\" + model.getAuthor()); System.out.println(\"价格:\" + model.getPrices()); &#125; &#125; public static void main(String[] args) &#123; long startTime, endTime; System.out.println(\"【爬虫开始】请耐心等待一大波数据到你碗里来...\"); startTime = System.currentTimeMillis(); // 从京东图书开始抓，开启5个线程，启动爬虫 Spider.create(new JDPageProcesser()).addUrl(\"https://book.jd.com/\").thread(3).run(); endTime = System.currentTimeMillis(); getAll(); System.out.println(\"【爬虫结束】共抓取\" + size + \"本图书，耗时约\" + ((endTime - startTime) / 1000) + \"秒，已保存到数据库，请查收！\"); &#125;&#125; 以后将会坚持更新!反馈与建议 邮箱：&#99;&#97;&#111;&#99;&#x68;&#105;&#107;&#x61;&#x69;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#109;","tags":[]},{"title":"My New Post","date":"2016-12-24T13:46:06.000Z","path":"2016/12/24/First Wirte/","text":"Markdown初次使用Markdown是一门轻量级语法,仅仅需要5分钟你就能搞懂! 期末刷jsp作业心得 DAO层封装成工具类 ：持久层处理业务,尽量把变化东西采用数组遍历,约定成俗简化成配置化写； 登陆注册模块重用 ：前端样式变化,但尽量不要修改提交参数名称和个数； 单元测试类 ：使用 junit测试框架检查逻辑是否有误,方便部署调试 。 代码块1234567891011121314151617// 执行更新操作----带预编译参数public int excuteUpdate(String sql, String[] params) &#123; int result = 0; try &#123; pstmt = getCon().prepareStatement(sql); for (int i = 0; i &lt; params.length; i++) &#123; pstmt.setString(i + 1, params[i]); &#125; result = pstmt.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; pstmtClose(); conClose(); &#125; return result;&#125; ##以后将会持续更新,预告 webmagic 框架爬虫下次出 反馈与建议 邮箱：&#x63;&#97;&#x6f;&#x63;&#104;&#x69;&#x6b;&#97;&#105;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;","tags":[]}]
[{"title":"HttpServletRequest流重复读","date":"2019-12-18T12:30:13.000Z","path":"2019/12/18/HttpServletRequest流重复读/","text":"HttpServletRequest流重复读 springmvc controller @RequestBody接受参数报错，原因为http POST请求报文体为二进制流，在HttpServletRequest.getInputStream()中流只能被读取一次，重复读取会报如下： 1getRead() has already been called for this request&#x2F;getInputStream() has already been called for this request 一、解决方式 第一种方式：重写HttpServletRequestWrapper 将InputStream 替换成可重复读的ByteArrayInputStream，原理就是在Filter或者springmvc的interceptor中通过构造器包HttpServletRequest并且，并且把当前流缓存起来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.ServletRequest;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.nio.charset.Charset;/** * 自定义HttpServletRequestWrapper * 解决InputStream不能重复读问题 * * @author motui * @version 2019-01-06 18:53 */public class BufferedServletRequestWrapper extends HttpServletRequestWrapper &#123; private final byte[] body; BufferedServletRequestWrapper(HttpServletRequest request) throws IOException &#123; super(request); String sessionStream = getBodyString(request); body = sessionStream.getBytes(Charset.forName(\"UTF-8\")); &#125; /** * 获取请求Body */ private String getBodyString(final ServletRequest request) &#123; StringBuilder sb = new StringBuilder(); InputStream inputStream = null; BufferedReader reader = null; try &#123; inputStream = cloneInputStream(request.getInputStream()); reader = new BufferedReader(new InputStreamReader(inputStream, Charset.forName(\"UTF-8\"))); String line = \"\"; while ((line = reader.readLine()) != null) &#123; sb.append(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return sb.toString(); &#125; /** * 复制输入流 */ private InputStream cloneInputStream(ServletInputStream inputStream) &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; try &#123; while ((len = inputStream.read(buffer)) &gt; -1) &#123; byteArrayOutputStream.write(buffer, 0, len); &#125; byteArrayOutputStream.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); &#125; @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; final ByteArrayInputStream bais = new ByteArrayInputStream(body); return new ServletInputStream() &#123; @Override public int read() throws IOException &#123; return bais.read(); &#125; &#125;; &#125;&#125; 第二种方式：Springmvc提供了解决方案ContentCachingRequestWrapper，思路也是一样，只不过代码更加严谨点。源码我就不贴了，开头注释说明贴一下，然后需要注意事项和正确的使用方式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** *ContentCachingRequestWrapper源码注释如下 * &#123;@link javax.servlet.http.HttpServletRequest&#125; wrapper that caches all content read from * the &#123;@linkplain #getInputStream() input stream&#125; and &#123;@linkplain #getReader() reader&#125;, * and allows this content to be retrieved via a &#123;@link #getContentAsByteArray() byte array&#125;. * * &lt;p&gt;Used e.g. by &#123;@link org.springframework.web.filter.AbstractRequestLoggingFilter&#125;. * * @author Juergen Hoeller * @author Brian Clozel * @since 4.1.3 * @see ContentCachingResponseWrapper */package com.qm.interceptor;import org.springframework.web.util.ContentCachingRequestWrapper;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;/** * 配置哪些请求可以进行重复读数据 * * @author motui * @version 2019-01-05 21:59 */public class cachingRequestBodyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // 防止流读取一次后就没有了, 所以需要将流继续写出去 HttpServletRequest httpServletRequest = (HttpServletRequest) request; String requestURI = httpServletRequest.getRequestURI(); // 这里将原始request传入，读出流并存储 //PATH 为可重复读的路径开始或者接受部分 例如：caching.do if (requestURI.endsWith(\"caching.do\")) &#123; // 这里将原始request传入，读出流并存储 ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(httpServletRequest); // 这里将原始request替换为包装后的request，此后所有进入controller的request均为包装后的request chain.doFilter(requestWrapper, response); &#125; else &#123;// 不要覆盖所有的请求，防止覆盖其他人请求 chain.doFilter(request, response); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; 二、参考如下：HttpServletRequest数据流重复读问题","tags":[]},{"title":"BigDecimal金额计算","date":"2019-12-16T16:26:58.000Z","path":"2019/12/17/BigDecimal金额计算/","text":"关于金额计算，通常有加减乘除，四舍五入等。 add()加法函数：要注意BigDecimal加法得到的结果为零，因为BigDecimal的加法需要一个值去接收，加法不会改变调用者自身的值。 subtract()减法函数：同加法； multiply()乘法函数：注意Double转BigDecimal，尽量用字符串的形式初始化。因为使用BigDecimal类构造方法传入double类型时，计算的结果是不精确的！ divide()除法函数：避免抛出除零异常，方式将除运算尽量转换成等价的乘运算。 保留两位小数且四舍五入：value.setScale(2, BigDecimal.ROUND_HALF_UP); BigDecimal静态常量值，比如BigDecimal.ZERO等； 例子刨析：1234567891011121314151617181920212223242526BigDecimal num1 = new BigDecimal(0.005); BigDecimal num2 = new BigDecimal(1000000); BigDecimal num3 = new BigDecimal(-1000000); //尽量用字符串的形式初始化 BigDecimal num12 = new BigDecimal(\"0.005\"); BigDecimal num22 = new BigDecimal(\"1000000\"); BigDecimal num32 = new BigDecimal(\"-1000000\");//加法 BigDecimal result1 = num1.add(num2); BigDecimal result12 = num12.add(num22); //减法 BigDecimal result2 = num1.subtract(num2); BigDecimal result22 = num12.subtract(num22); //乘法 BigDecimal result3 = num1.multiply(num2); BigDecimal result32 = num12.multiply(num22); //绝对值 BigDecimal result4 = num3.abs(); BigDecimal result42 = num32.abs(); //除法 BigDecimal result5 = num2.divide(num1,20,BigDecimal.ROUND_HALF_UP); BigDecimal result52 = num22.divide(num12,20,BigDecimal.ROUND_HALF_UP); result全部输出结果，初始化建议使用String 结果 参考如下BigDecimal加减乘除计算","tags":[]},{"title":"Springboot+vue部署路由404","date":"2019-12-15T08:32:00.000Z","path":"2019/12/15/hello-world/","text":"问题背景vue单页面路由，刷新地址或者请求链接，都会404 user www; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; events { worker_connections 51200; multi_accept on; } http { include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; #gzip on; gzip on; server { listen 80; root /www/app/; server_name gdhxy.cn; try_files $uri $uri/ /index.html; } server { listen 80; root /www/app/; server_name www.gdhxy.cn; try_files $uri $uri/ /index.html; } server { listen 80; server_name admin.gdhxy.cn; try_files $uri $uri/ /index.html; location / { proxy_redirect off; proxy_pass http://127.0.0.1:38806; } } }解决方式 1、nginx配置：try_files $uri $uri/ /index.html；2、springboot指定404到index.html. import org.springframework.boot.web.servlet.error.ErrorController; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpServletRequest; @Controller public class MyErrorController implements ErrorController { @RequestMapping(&quot;/error&quot;) public String handleError(HttpServletRequest request) { //获取statusCode:404,重定向到首页 Integer statusCode = (Integer) request.getAttribute(&quot;javax.servlet.error.status_code&quot;); if (statusCode == 404) { return &quot;/index.html&quot;; } else { return &quot;/500&quot;; } } @Override public String getErrorPath() { return &quot;/error&quot;; } }","tags":[{"name":"Spring","slug":"Spring","permalink":"https://caochikai.github.io/tags/Spring/"}]},{"title":"服务器配置记录","date":"2019-09-27T16:48:12.000Z","path":"2019/09/28/服务器配置记录/","text":"服务器配置记录一、背景 真实生产环境部署：nginx、tomcat配置https证书 二、nginx安装过程：123456789101112131415//一键安装上面四个依赖yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel//下载tar包wget http://nginx.org/download/nginx-1.16.1.tar.gztar xzf nginx-1.16.1.tar.gz -C /usr/local//文件名改nginx-1.16.1成nginx//进入nginx目录cd /usr/local/nginx//关联编译https模块 ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module//执行make命令编译源码make//执行make install安装可执行binmake install//新建logs（日志）和ssl（证书）文件夹 https浏览器影响——混合内容 解决Nginx反代Tomcat Http、Https混合内容报错，浏览器认为https请求中资源是http的css、js和图片都无法正常加载，造成无法双协议兼容！ 12浏览器访问后开发者模式看到的报错信息：Mixed Content: The page at &#39;https:&#x2F;&#x2F;dashboard.domain.com&#x2F;wire&#39; was loaded over HTTPS, but requested an insecure stylesheet &#39;http:&#x2F;&#x2F;dashboard.domain.com&#x2F;static&#x2F;css&#x2F;flickity.css&#39;. This request has been blocked; the content must be served over HTTPS. nginx解决配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061user www;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;events &#123; worker_connections 51200; multi_accept on;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; #gzip on; gzip on; server &#123; listen 80; listen 443 ssl; server_name chinaffxz.com; #charset koi8-r; ssl_certificate /usr/local/nginx/ssl/2879444_chinagzhxy.com.pem; ssl_certificate_key /usr/local/nginx/ssl/2879444_chinagzhxy.com.key; location / &#123; proxy_pass http://127.0.0.1:xxxx/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #解决兼容配置要点 proxy_set_header X-Forwarded-Proto $scheme; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; Tomcat配置1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;Server port=\"8006\" shutdown=\"SHUTDOWN\"&gt; &lt;Listener className=\"org.apache.catalina.core.JreMemoryLeakPreventionListener\" /&gt; &lt;Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" /&gt; &lt;Listener className=\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\" /&gt; &lt;Listener className=\"org.apache.catalina.core.AprLifecycleListener\" /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name=\"UserDatabase\" auth=\"Container\" type=\"org.apache.catalina.UserDatabase\" description=\"User database that can be updated and saved\" factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\" pathname=\"conf/tomcat-users.xml\" /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name=\"Catalina\"&gt; &lt;Connector port=\"38080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" maxThreads=\"1000\" minSpareThreads=\"20\" acceptCount=\"1000\" maxHttpHeaderSize=\"65536\" debug=\"0\" disableUploadTimeout=\"true\" useBodyEncodingForURI=\"true\" enableLookups=\"false\" URIEncoding=\"UTF-8\" /&gt; &lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt; &lt;!-- 解决兼容要点--&gt; &lt;Valve className=\"org.apache.catalina.valves.RemoteIpValve\" remoteIpHeader=\"X-Forwarded-For\" protocolHeader=\"X-Forwarded-Proto\" protocolHeaderHttpsValue=\"https\"/&gt; &lt;Realm className=\"org.apache.catalina.realm.LockOutRealm\"&gt; &lt;Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\" resourceName=\"UserDatabase\" /&gt; &lt;/Realm&gt; &lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html Note: The pattern used is equivalent to using pattern=\"common\" --&gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt; &lt;Context path=\"\" docBase =\"mall\" debug=\"0\" reloadable=\"true\" crossContext=\"false\"/&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; git持续部署shell脚本 解决Linux CentOS中cp -f 复制强制覆盖的命令无效的方法，系统默认使用cp -i使用交互方式避免误操作，但在自动脚本中应当避免，推荐\\cp。 123456789101112#update codecd /root/dowload/mall/duoshanghugit fetch origin git pull &gt; /root/dowload/mall/logs/mall_git.log &amp;#package mvn package -Dmaven.test.skip=truesleep 2s#cp war to tomcat webapp\\cp -fr /root/dowload/mall/duoshanghu/target/mall.war /usr/local/env/tomcat/webapps/mall.warsleep 1s#restart.shsh /usr/local/env/tomcat/bin/restart.sh tomcat重启脚本1234567891011121314151617181920212223242526272829303132#!/bin/sh#初始化全局环境变量. /etc/profile#set java environmentexport CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib#查找tomcat的pidpid=`ps aux | grep tomcat | grep -v grep | grep -v Restart | grep -v restart | awk '&#123;print $2&#125;'`echo \"the tomcat pid is $pid\"#判断tomcat进程是否存在if [ -n \"$pid\" ];then sleep 1 pid=`ps aux | grep tomcat | grep -v grep | grep -v restart | grep -v Restart | awk '&#123;print $2&#125;'` if [ -n \"$pid\" ]; then sleep 1 echo \"tomcat进程将被杀?\" kill -9 $pid fi sleep 1 echo \"tomcat进程已经被杀死，先重新启动tomcat.\" service tomcat status sleep 1s service tomcat startelse echo \"tomcat进程不存在，先重新启动tomcat.\" service tomcat status sleep 1s service tomcat startfi maven编译完整依赖管理1、来源 解决webapp/WEB-INF/lib目录下的jar包无法用maven打包，且在linuxMaven编译报错[ERROR] Fatal Error: Unable to find package java.lang in classpath or bootclasspath，致命错误: 在类路径或引导类路径中找不到程序包 java.lang 2、解决方法Linux解决办法，使用maven自带的变量${path.separator}路径分隔符，原因是在Windows下是分号;，在linux下是冒号: 同时配置导入webapp/WEB-INF/lib和jdk的rt.jar、jce.jar，完美解决环境配置带来的无法package找不到依赖问题。 pom.xml：12345678910111213141516171819202122232425262728293031323334&lt;build&gt; &lt;finalName&gt;$&#123;artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;compilerArguments&gt; &lt;verbose /&gt; &lt;bootclasspath&gt;$&#123;java.home&#125;/lib/rt.jar$&#123;path.separator&#125;$&#123;java.home&#125;/lib/jce.jar&lt;/bootclasspath&gt; &lt;extdirs&gt;$&#123;basedir&#125;/src/main/webapp/WEB-INF/lib&lt;/extdirs&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 参考解决Nginx反代Tomcat Http、Https混合内容报错 解决WEB-INF/lib目录下的jar包无法用maven打包 反馈与建议 当了组长面试加运维，对接一堆支付和物流、短信和推送账号，今天记录一下面向DevOps！ markdown原文件在github里面，感谢各位大佬看官star，面试我要往脸上贴金哈哈哈😂。 邮箱：caochikai@qq.com，有问题发邮件。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://caochikai.github.io/tags/Linux/"},{"name":"nginx","slug":"nginx","permalink":"https://caochikai.github.io/tags/nginx/"},{"name":"tomcat","slug":"tomcat","permalink":"https://caochikai.github.io/tags/tomcat/"},{"name":"maven","slug":"maven","permalink":"https://caochikai.github.io/tags/maven/"}]},{"title":"JVM记录","date":"2019-09-14T04:32:49.000Z","path":"2019/09/14/JVM记录/","text":"JVM记录一、错误 背景：自动答题爬虫由于买的腾讯云1核2G1M，Jenkins、springboot爬虫和火狐浏览器驱动。 知识背景：JDWP：调试网络协议(Java Debug Wire Protocol)；调试线协议；jvmti：（Java Virtual Machine Tool Interface）jvm代理； 猜测：Selenium通过driver驱动Firefox浏览器，多次无法关闭浏览器造成内存无法释放最后溢出； 引用文章（有兴趣可深入了解）：jvmti agent黑科技，阿里云云监控； 1FATAL ERROR in native method: JDWP Can&#39;t allocate jvmti memory, jvmtiError&#x3D;JVMTI_ERROR_OUT_OF_MEMORY(110) 反馈与建议 立个flag：不定期更新，一更一周。 markdown原文件在github里面，感谢各位大佬看官star，面试我要往脸上贴金哈哈哈😂。 邮箱：caochikai@qq.com，有问题发邮件。","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"},{"name":"JVM","slug":"JVM","permalink":"https://caochikai.github.io/tags/JVM/"}]},{"title":"工具收藏——idea推荐插件","date":"2019-05-22T12:34:48.000Z","path":"2019/05/22/工具收藏——idea推荐插件/","text":"工具收藏——idea推荐插件一、概念 ​ 工欲善其事必先利其器，博主是个死忠工具派，为了解决一个大问题可能会收集多个工具和方案，然后求证对比出体验报告。后续文章有一大类就是工具类推荐，而本篇文章重点就是idea 安装插件记录，简要记录安装方法快速搭建个性化idea，还有一些关于UI方面插件可谓多不胜数，而且每个人口味不一，请各位自行选择——插件搜索技巧tags为Theme或者UI。 插件列表最强大插件卫冕之王——lambda表达式 名称 描述 JRebel 代替springboot dev热部署方案，最方便激活方式 Lombok 精简bean，各种功能强大又实用注解，搬砖人的MVP，结合Hutool实在完美 AceJump 光标跳跃，替代vim不二之选 MavenHelper 快速分析maven 包冲突的问题，搜索包名 MyBatis Log Plugin Restore the mybatis generate sql to original whole sql.（拼接完整sql） Log Support 2 快速log.info()，结合Lombok插件注解@Slf4j可以说无敌 Free Mybatis plugin Mybaits支持跳转，有钱大爷请收费版Mybatis plugin强大破解较少，差评 Rainbow Brackets 彩虹括号，多层嵌套代码显示助手 String Manipulation 各种各样字符串格式转化 RestfulToolkit 一套 RESTful 服务开发辅助工具集 Alibaba Cloud Toolkit 结合阿里云（非阿里也支持），多节点发布工具加强力linux客户端 stackoverflow stackoverflow快速搜索bug插件 Translation 最强大的翻译插件，支持中文替换英文，解决起英文变量名难的重度患者 Key Promoter X 所有操作的快捷键提示，忘记鼠标真的 Cyan Light Theme A light theme，偏青色对眼睛很柔和舒服，黑暗主题实在不适应 反馈与建议 2012年java程序员可以说非常吃香，今年2019从业人数暴增，职业发展挑战变得越来越大！现在流行自动构建和自动部署CI，开发运维一体化docker，整个互联网都在追求敏捷开发的今天。掌握一款追求效率功能的IDE非常重要，很多群和公众号对ide和Eclipse争议很大。但请记住斯大林名言——落后就要挨打，ide本身代表高效，但是插件也别装太多，免得启动还要半天哈哈哈😀 （首推）慕课网免费教程：IntelliJ IDEA神器使用技巧 （推荐）尚硅谷IDEA视频教程：链接：https://pan.baidu.com/s/11biVBv9EI9yfL6Cee0r0LQ，密码：n7hn 看完上面两个教程，你会怀疑自己用的idea是假的，原来写代码还可以这样的。 邮箱：caochikai@qq.com","tags":[{"name":"idea","slug":"idea","permalink":"https://caochikai.github.io/tags/idea/"},{"name":"tool","slug":"tool","permalink":"https://caochikai.github.io/tags/tool/"},{"name":"plugin","slug":"plugin","permalink":"https://caochikai.github.io/tags/plugin/"}]},{"title":"springboot整合elasticsearch","date":"2019-05-21T13:40:31.000Z","path":"2019/05/21/springboot整合elasticsearch/","text":"springboot整合elasticsearch一、概念 elasticsearch官网是一个分布式多用户能力的全文搜索引擎，也是一个具有RESTful web接口的java应用。目前开源软件商业比较不错的例子，与Solr一样都是基于Lucene，大数据hadoop也是脱胎于Lucene。Solr开源而且生态比较成熟，elasticsearch目前最火也是商业应用方面非常好的搜索引擎。 3w原则： question what：常见站内/app内搜索服务需求：商品文章的模糊搜索，精确搜索，拼音搜索 。 question why：借助elasticsearch和analysis-ik中文分词器，快速实现搜索服务功能。 how：在微服务当中，通常利用mq消息中间件来同步数据集群搜索服务（脚手架里没有mq），借助ElasticsearchTemplate（spring 模板工具类强大）API维护索引和搜索查询。 二、落地实现 根据码云企业级搜索脚手架的文档可知，注意版本为Springboot2.1.1+elasticsearch6.5.3，elasticsearch和analysis-ik插件版本必须统一，而且新版本elasticsearch 7不适用于该工程。这个参考工程的中文分词搜索效果不太理想，一般富文本的内容进入索引之前要利用字符过滤器清洗不正常的字符。通常为了保证索引时覆盖度和搜索时准确度,索引分词器采用ik_max_word,搜索分析器采用ik_smart模式。具体elasticsearch6.5.3的安装过程请参考码云的README.md，目前正在在公司项目使用请放心，单元测试的效果也非常nice。 1、添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置引导类12345#============================# 默认的节点名称elasticsearchspring.data.elasticsearch.cluster-name=my-application# elasticsearch 调用地址，多个使用“,”隔开spring.data.elasticsearch.cluster-nodes=localhost:9300 3、DWMQSender包装rabbitTemplate发送消息同步数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//服务类的简写如下&#123;//注入sender @AutowiredDWMQSender sender;//发送写法ArticlesMessage extends DWMQMessage&lt;消息内容类型&gt;JSONObject jsonObject = JSON.parseObject(JSON.toJSONString(articles)); jsonObject.put(Groups.ACTION, Groups.ADD); sender.sendMessage(new ArticlesMessage(jsonObject));&#125;//封装发送mq messageimport com.alibaba.fastjson.JSON;import com.dwalk.common.exception.EU;import com.dwalk.common.mq.mto.DWMQMessage;import com.dwalk.common.utils.SU;import com.rabbitmq.client.Channel;import lombok.extern.slf4j.Slf4j;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.amqp.AmqpException;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.MessagePostProcessor;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.amqp.rabbit.support.CorrelationData;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.util.concurrent.atomic.AtomicLong;/** * 消息成功发送到MQ服务器后的回调确认 */@Slf4j@Componentpublic class DWMQSender &#123; @Autowired RabbitTemplate rabbitTemplate; @Autowired DWMQRetry retry; // public void sendMessage(DWMQMessage mto) &#123; if( mto.getObj()==null ) &#123; EU.te(\"消息内容为空\"); &#125; if( SU.isNull( mto.getRoutingKey()) ) &#123; EU.te(\"路由规则为空\"); &#125; log.info(String.format(\"准备发送【%s】\", mto.getInfo())); mto.setId(retry.generateId()); if( SU.isNull(mto.getExchange()) &amp;&amp; mto.getExpire()&lt;1 ) &#123; //默认的没有交换器，则直接发送到指定的队列 rabbitTemplate.convertAndSend(mto.getRoutingKey(), mto.getObj(), new CorrelationData(mto.getId())); &#125; else if (mto.getExpire()&lt;1)&#123; //经过交换器，按路由规则匹配队列 rabbitTemplate.convertAndSend(mto.getExchange(), mto.getRoutingKey(), mto.getObj(), new CorrelationData(mto.getId())); &#125; else &#123; //默认的没有交换器，则直接发送到指定的队列，发送延迟消息 rabbitTemplate.convertAndSend(mto.getRoutingKey(), mto.getObj(), message -&gt; &#123; message.getMessageProperties().setExpiration(mto.getExpire()+\"\"); return message; &#125;, new CorrelationData(mto.getId())); &#125; mto.setCtime(System.currentTimeMillis()); retry.add(mto, this); &#125;&#125; 4、RabbitListener接收到消息同步数据123456789101112131415161718192021222324252627282930313233343536373839/** * 搜索服务接收到管理后台用户修改文章同步消息 */@Component@Slf4j//配置mq消息队列，接收文件同步消息@RabbitListener(queues = DirectMQConfig.DIRECT_ARTICLES_ELASTIC_QUEUE)public class ArticlesReceiver extends DWMQBaseReceiver&lt;String&gt; &#123; @Autowired private ArticleETOService etoService; @Override public Class getClazz() &#123; return String.class; &#125; @Override public boolean processMessage(String mto) &#123; log.info(\"Received 管理后台用户-修改文章同步消息接收:&#123;&#125;\", mto); JSONObject jsonObject = JSON.parseObject(mto); String action = jsonObject.getString(Groups.ACTION); //删除操作要删除索引，更新操作先删除后 ArticleETO articles = JSON.parseObject(jsonObject.toJSONString(), ArticleETO.class); String articlesId = articles.getId(); switch (action) &#123; case Groups.ADD: etoService.save(articles); break; case Groups.UPDATE: etoService.delete(articlesId); etoService.save(articles); break; case Groups.DELETE: etoService.delete(articlesId); break; &#125; return true; &#125;&#125; 5、公共搜索方法12345678910111213141516171819202122232425262728/** * 高亮显示，返回分页 * @auther: zhoudong * @date: 2018/12/18 10:29 */ @Override public IPage&lt;Map&lt;String, Object&gt;&gt; queryHitByPage(int pageNo, int pageSize, String keyword, String indexName, String... fieldNames) &#123; // 构造查询条件,使用标准分词器. QueryBuilder matchQuery = createQueryBuilder(keyword, fieldNames); // 设置高亮,使用默认的highlighter高亮器 HighlightBuilder highlightBuilder = createHighlightBuilder(fieldNames); // 设置查询字段 SearchResponse response = elasticsearchTemplate.getClient().prepareSearch(indexName) .setQuery(bool) .highlighter(highlightBuilder) .setFrom((pageNo - 1) * pageSize) .setSize(pageNo * pageSize) // 设置一次返回的文档数量，最大值：10000 .get(); // 返回搜索结果 SearchHits hits = response.getHits(); Long totalCount = hits.getTotalHits(); IPage&lt;Map&lt;String, Object&gt;&gt; page = new Page&lt;&gt;(pageNo, pageSize, totalCount); page.setRecords(getHitList(hits)); return page; &#125; 反馈与建议 今天终于出了elasticsearch文章，以后我会在对应专题的文章放出相关的百度云资源，这些都是网上流传比较广的资源，想找好的学习资源也可以与我合伙买绝版视频，有钱买正版吧（作者很穷，找工作从来没有造假包装，只能混成这个卵样😭，世道维艰，如果不是感觉做码农还算有点天赋，早就转行了）。 百度云 :下载街/01.Elasticsearch顶尖高手系列课程，密码：iw7f 邮箱：caochikai@qq.com","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://caochikai.github.io/tags/elasticsearch/"}]},{"title":"Springboot整合Quartz定时器","date":"2019-05-20T12:25:37.000Z","path":"2019/05/20/Spring boot整合Quartz定时器/","text":"Spring boot整合Quartz定时器一、概念 quartz官网是一个完全由 Java 编写的开源作业调度框架，结合数据库甚至可以做到分布式调度。目前参考的RuoYi后台脚手架的定时任务模块，支持在线（添加、修改、删除)任务调度，并记录执行日志作业结果。 3w原则： question what：定时任务，比如定时答题、商家结算等需求，并且支持立即运行、暂停和禁止。 question why：借助quartz springboot生态和后台脚手架，快速实现定时调度功能。 how：实现JobDetail运行任务详情，Trigger 触发器定义触发规则，Scheduler 调度中心/容器注册多个 JobDetail 和 Trigger。Trigger 与 JobDetail 组合即可被Scheduler调用。 二、落地实现 根据若依脚手架的文档可知，定时任务工程模块为ruoyi-quartz，结合sql/quartz.sql导入关于定时器数据库表。当然这种做法需要数据库和bootstrap，为了简化，我采取的替代方案是保留定时和立即执行功能，抛弃手动在代码硬编码新加定时器，web管理面板则通过swagger触发任务调度立即执行一次。极端偷懒方式，@Scheduled(cron = “”)放在在cotroller方法，同事推荐给我的😀。 1、添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置引导类1234567//模块加载@EnableScheduling@EnableSwagger2@SpringBootApplicationpublic class WeixinApplication &#123;......&#125; 3、注册JobDetail和Trigger1234567891011121314151617181920212223/** * 在线表达式：http://cron.qqe2.com/ */@Slf4j@Configurationpublic class QuartzConfig &#123; public static final String TASK_CLASS_NAME = \"reportNowTask\"; @Bean public JobDetail reportNowTask() &#123; return JobBuilder.newJob(reportNowTask.class).withIdentity(TASK_CLASS_NAME).storeDurably().build(); &#125; @Bean public Trigger reportNowTaskTrigger(JobDetail reportNowTask) &#123; //cronSchedule等于@Scheduled(cron = \"\"),但是通过注解无法配置jobkey return TriggerBuilder.newTrigger().forJob(reportNowTask) .withIdentity(\"reportNowTaskTrigger\") .withSchedule(CronScheduleBuilder.cronSchedule(\"9 0 19 * * ?\")) .build(); &#125;&#125; 4、任务详情继承QuartzJobBean或者实现Job接口12345678@Slf4jpublic class reportNowTask extends QuartzJobBean &#123; @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123; ......//任务内容 &#125;&#125; 5、立即执行123456789101112131415161718@Slf4j@Api(tags = \"问题模块\")@RequestMapping(value = \"question\")@RestControllerpublic class QuestionController &#123; /** * 任务调度立即执行一次 */ @PostMapping(\"/run\") @ResponseBody public ResponseEntity run() throws SchedulerException &#123; //api秘诀就在这里根据QuartzConfig jobKey触发作业调度 scheduler.triggerJob(JobKey.jobKey(QuartzConfig.TASK_CLASS_NAME)); return ResponseEntity.ok(\"执行成功！\"); &#125;&#125; 反馈与建议 今天粗略简易版的定时任务,功能强大的请查看若依后台脚手架,github和码云有很多类似脚手架,但是我们有选择性copy学习才是重点😊。 邮箱：caochikai@qq.com","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"},{"name":"quartz","slug":"quartz","permalink":"https://caochikai.github.io/tags/quartz/"}]},{"title":"springboot源码分析之启动过程","date":"2019-05-19T13:50:35.000Z","path":"2019/05/19/springboot源码分析之启动过程/","text":"springboot源码分析之启动过程一、概念 计划写一波springboot 2.x源码分析，只写实用性比较高的特性，从GitHub上看出更新频率在一个月左右，更新极快非常活跃。 版本发行: 版本 时间线 说明 v0.5.0.M1 2013-08-06 第一个版本 v2.2.0.M3 2019-05-15 当前最新版本 二、源码分析 SpringBoot的启动引导类写法多样，标记了@SpringBootApplication的class作为源类，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//简易版@SpringBootApplication public class MyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyApplication.class, args); &#125; &#125;//通过 SpringApplicationBuilder API@SpringBootApplicationpublic class DiveInSpringBootApplication &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(DiveInSpringBootApplication.class) .bannerMode(Banner.Mode.CONSOLE) .web(WebApplicationType.NONE) .profiles(\"prod\") .headless(true) .run(args); &#125;&#125;//声明newpublic class SpringApplicationBootstrap &#123; public static void main(String[] args) &#123;// SpringApplication.run(ApplicationConfiguration.class,args); Set sources = new HashSet(); // 配置Class 名称 sources.add(ApplicationConfiguration.class.getName()); SpringApplication springApplication = new SpringApplication(); //配置源 springApplication.setSources(sources); //配置控制台banner springApplication.setBannerMode(Banner.Mode.CONSOLE); //声明web类型 springApplication.setWebApplicationType(WebApplicationType.NONE); //多环境配置激活 springApplication.setAdditionalProfiles(\"prod\"); //java.awt.headless禁用模式 springApplication.setHeadless(true); springApplication.run(args); &#125; @SpringBootApplication public static class ApplicationConfiguration &#123; &#125;&#125; 从代码上可以看出，调用了SpringApplication的静态方法run。这个run方法会构造一个SpringApplication的实例，然后再调用这里实例的run方法就表示启动SpringBoot。因此，想要分析SpringBoot的启动过程，我们需要熟悉SpringApplication的构造过程以及SpringApplication的run方法执行过程即可。 SpringApplication的准备过程 配置 Spring Boot Bean 源：Java 配置 Class 或 XML 上下文配置文件集合，用于 Spring Boot BeanDefinitionLoader 读取 ，并且将配置源解析加载为Spring Bean 定义。 推断 Web 应用类型：根据当前应用 ClassPath 中是否存在相关实现类来推断 Web 应用的类型。参考方法：org.springframework.boot.SpringApplication#deduceWebApplicationType。 123456789101112private WebApplicationType deduceWebApplicationType() &#123; if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null) &amp;&amp; !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)) &#123; return WebApplicationType.REACTIVE; &#125; for (String className : WEB_ENVIRONMENT_CLASSES) &#123; if (!ClassUtils.isPresent(className, null)) &#123; return WebApplicationType.NONE; &#125; &#125; return WebApplicationType.SERVLET;&#125; 推断引导类（Main Class）：根据 Main 线程执行堆栈判断实际的引导类。参考方法： org.springframework.boot.SpringApplication#deduceMainApplicationClass 123456789101112131415private Class deduceMainApplicationClass() &#123; try &#123;//获取堆栈输出方法名称 StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) &#123; if (\"main\".equals(stackTraceElement.getMethodName())) &#123; return Class.forName(stackTraceElement.getClassName()); &#125; &#125; &#125; catch (ClassNotFoundException ex) &#123; // Swallow and continue &#125; return null; &#125; 加载应用上下文初始器 （ ApplicationContextInitializer ）：利用 Spring 工厂加载机制，实例化 ApplicationContextInitializer 实现类，并排序对象集合。 1234567891011121314//实现类： org.springframework.core.io.support.SpringFactoriesLoader//配置资源： META-INF/spring.factories//排序： AnnotationAwareOrderComparator#sortprivate Collection getSpringFactoriesInstances(Class type, Class[] parameterTypes, Object... args) &#123; ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); // Use names and ensure unique to protect against duplicates Set names = new LinkedHashSet&lt;&gt;( SpringFactoriesLoader.loadFactoryNames(type, classLoader)); List instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); AnnotationAwareOrderComparator.sort(instances); return instances; &#125;· 加载应用事件监听器（ ApplicationListener ）：利用 Spring 工厂加载机制，实例化 ApplicationListener 实现类，并排序对象集合。 SpringApplication 运行阶段 加载 SpringApplication 运行监听器（ SpringApplicationRunListeners ）：利用 Spring 工厂加载机制，读取 SpringApplicationRunListener 对象集合，并且封装到组合类SpringApplicationRunListeners。 运行 SpringApplication 运行监听器（ SpringApplicationRunListeners ）： started(run方法执行的时候立马执行；对应事件的类型是ApplicationStartedEvent) environmentPrepared(ApplicationContext创建之前并且环境信息准备好的时候调用；对应事件的类型是ApplicationEnvironmentPreparedEvent) contextPrepared(ApplicationContext创建好并且在source加载之前调用一次；没有具体的对应事件) contextLoaded(ApplicationContext创建并加载之后并在refresh之前调用；对应事件的类型是ApplicationPreparedEvent) finished(run方法结束之前调用；对应事件的类型是ApplicationReadyEvent或ApplicationFailedEvent) 创建 Spring 应用上下文（ ConfigurableApplicationContext ）:根据准备阶段的推断 Web 应用类型创建对应ConfigurableApplicationContext 实例： Web Reactive： AnnotationConfigReactiveWebServerApplicationContext Web Servlet： AnnotationConfigServletWebServerApplicationContext 非 Web： AnnotationConfigApplicationContext 创建 Environment：根据准备阶段的推断 Web 应用类型创建对应的 ConfigurableEnvironment 实例。 Web Reactive： StandardEnvironment Web Servlet： StandardServletEnvironment 非 Web： StandardEnvironment run方法分析1234567891011121314151617181920212223242526272829303132public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); // 构造一个任务执行观察器 stopWatch.start(); // 开始执行，记录开始时间 ConfigurableApplicationContext context = null; configureHeadlessProperty(); // 获取SpringApplicationRunListeners，内部只有一个EventPublishingRunListener SpringApplicationRunListeners listeners = getRunListeners(args); // 上面分析过，会封装成SpringApplicationEvent事件然后广播出去给SpringApplication中的listeners所监听 // 这里接受ApplicationStartedEvent事件的listener会执行相应的操作 listeners.started(); try &#123; // 构造一个应用程序参数持有类 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // 创建Spring容器 context = createAndRefreshContext(listeners, applicationArguments); // 容器创建完成之后执行额外一些操作 afterRefresh(context, applicationArguments); // 广播出ApplicationReadyEvent事件给相应的监听器执行 listeners.finished(context, null); stopWatch.stop(); // 执行结束，记录执行时间 if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; // 返回Spring容器 &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, ex); // 这个过程报错的话会执行一些异常操作、然后广播出ApplicationFailedEvent事件给相应的监听器执行 throw new IllegalStateException(ex); &#125;&#125; 反馈与建议 为了快大多分析的不好写的很乱，凑合看下我以后改下排版😂。 邮箱：caochikai@qq.com","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"},{"name":"quartz","slug":"quartz","permalink":"https://caochikai.github.io/tags/quartz/"}]},{"title":"地理定位业务实现","date":"2019-05-18T12:19:01.000Z","path":"2019/05/18/地理定位业务实现/","text":"地理定位业务实现一、概念3w原则： question what：a、附近一定范围的目标（电子围栏）；b、该经纬度的地理位置名称（省市县街道）。 why：解决上述问题的本质是获得经纬度，途径为硬件、GPS定位服务、基站定位，地理位置通过百度、谷歌、腾讯地图，基本所有地图免费版都有日访问量限制。 how：通过安卓或者IOS获取经纬度，再借助百度地图接口获取地理位置，距离也可通过接口或者谷歌地图算法。 GPS是英文Global Positioning System（全球定位系统）的简称。 二、解决方式 场景：小程序获取附近的好友，微信官方文档 wx.getLocation(Object object)。 现象：需要用户授权，前端获得gps 坐标通过接口传数据后台，保存到用户表（1：1关系）。 地图选择：其实纯前端基本也能解决基本问题，腾讯地图对小程序支持最好，根据JavaScript SDK文档可以拥有如下功能：绘制地图，地点搜索，关键词输入提示，逆地址解析（坐标位置描述），地址解析（地址转坐标，路线规划，距离计算，获取城市列表，获取城市区县。 业务前提：用户必须授权才能使用该功能，当拥有所有用户经纬度，通过数据库语句获取当前用户经纬度在一定距离，并且可以排行。 三、落地编码sql版例子：123456789101112131415161718192021222324252627#mysql版，根据谷歌地图公式计算点歌经纬度之间距离，单位为m（米）select e.id, e.longitude, e.latitude, ROUND( 6378.138 * 2 * ASIN( SQRT( POW( SIN( ( e.latitude * PI() / 180 - 23.12463 * PI() / 180 ) / 2 ), 2 ) + COS(e.latitude * PI() / 180) * COS(23.12463 * PI() / 180) * POW( SIN( ( e.longitude * PI() / 180 - 113.36189 * PI() / 180 ) / 2 ), 2 ) ) ) * 1000 ) AS distanceFROM dw_dbei_user ehaving distance &lt; 4000 工具类（获取两点距离）：12345678910111213141516171819202122232425262728293031323334public class MapUtils &#123; //private static double EARTH_RADIUS = 6378.137; private static double EARTH_RADIUS = 6371.393; private static double rad(double d) &#123; return d * Math.PI / 180.0; &#125; /** * 计算两个经纬度之间的距离 * * @param lat1 纬度1 * @param lng1 经度1 * @param lat2 纬度2 * @param lng2 经度2 * @return 计算结果单位：米 */ public static double GetDistance(double lat1, double lng1, double lat2, double lng2) &#123; double radLat1 = rad(lat1); double radLat2 = rad(lat2); double a = radLat1 - radLat2; double b = rad(lng1) - rad(lng2); double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(b / 2), 2))); s = s * EARTH_RADIUS; s = Math.round(s * 1000); return s; &#125; public static void main(String[] args) &#123; double v = GetDistance(113.36199, 23.12463, 113.36189, 23.12463); System.out.println(v); &#125;&#125; 反馈与建议 尽量每天不断更，做个自律者，markdown原文件在github里面，感谢各位大佬看官star，面试我要往脸上贴金哈哈哈😂。 邮箱：caochikai@qq.com","tags":[{"name":"sql","slug":"sql","permalink":"https://caochikai.github.io/tags/sql/"},{"name":"im","slug":"im","permalink":"https://caochikai.github.io/tags/im/"}]},{"title":"初探缓存","date":"2019-05-17T15:34:21.000Z","path":"2019/05/17/初探缓存/","text":"多级缓存架构缓存设计理念： 缓存常用的对象或者数据，减少系统开销提高效率。 缓存命中率 即从缓存中读取数据的次数 与 总读取次数的比率，命中率越高越好： 缓存策略： 移除策略：FIFO（First In First Out），LRU（Least Recently Used），LFU（Least Frequently Used）。 TTL（Time To Live）：缓存存活期 TTI（Time To Idle）：空闲存活期 spring cache 一、概念 自Spring 3.1起，提供注解缓存，并且提供事务回滚时也自动回滚缓存，并且支持SPEL表达式。 二、入门代码1、添加依赖，例如maven的pom.xml(Springboot); 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 2、添加一种cacheManager的bean实现类，常见ConcurrentMapCache、EhCacheCache、RedisCache； 123456@Beanpublic CacheManager cacheManager() &#123; SimpleCacheManager cacheManager &#x3D; new SimpleCacheManager(); cacheManager.setCaches(Collections.singletonList(new ConcurrentMapCache(&quot;models&quot;))); return cacheManager;&#125; 3、配置模块加载注解@EnableCaching 三、主要注解1、@Cacheable：将方法返回值作为缓存 value (也可使用 cacheNames) : 可看做命名空间，表示存到哪个缓存里了。 key : 表示命名空间下缓存唯一key,使用Spring Expression Language(简称SpEL,详见参考文献[5])生成。 condition : 表示在哪种情况下才缓存结果(对应的还有unless,哪种情况不缓存),同样使用SpEL 2、@CacheEvict：删除缓存注解 3、@CachePut：刷新注解 ehcache 一、概念二、入门代码1、缓存分组，要对分组进行全新CacheConfiguration ，为了高效使用配置自定义属性提取器。默认的属性处理器是JavaBeanAttributeExtractor。 123456789101112131415161718192021222324252627282930@Bean public EhCacheGroupBeanPostProcessor addCache() &#123; System.out.println(&quot;.......添加缓存组........&quot;); return new EhCacheGroupBeanPostProcessor(); &#125; &#x2F;&#x2F;后置处理器 public static class EhCacheGroupBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; &#x2F;&#x2F;根据前面初始化完成的beanName进一步操作 if(beanName.equals(&quot;appEhCacheCacheManager&quot;) ) &#123; EhCacheCacheManager manager &#x3D; (EhCacheCacheManager)bean; CacheManager cacheManager &#x3D; manager.getCacheManager();&#x2F;&#x2F; 文章缓存命中配置needUpdate CacheConfiguration configuration &#x3D; new CacheConfiguration(ReadCacheNames.文章缓存,10000); Searchable searchable &#x3D; new Searchable(); searchable.setKeys(false); searchable.setValues(false); &#x2F;&#x2F;动态索引 searchable.setAllowDynamicIndexing(true); searchable.addSearchAttribute(new SearchAttribute().name(&quot;needUpdate&quot;).className(&quot;com.dwalk.social.common.util.ArticlesAttributeExtractor&quot;)); configuration.eternal(true).addSearchable(searchable); Cache articlesCache &#x3D; new Cache(configuration); cacheManager.addCache(articlesCache); cacheManager.addCache(ReadCacheNames.热点文章缓存); &#125; return bean; &#125; &#125; 2、使用spring内置定时器，并使用ehcache查询api进行缓存查询。 123456789101112131415161718192021222324 @Scheduled(cron &#x3D; &quot;0 0&#x2F;1 * * * ?&quot;) private void synchronize() &#123; Cache cache &#x3D; cacheManager.getCache(ReadCacheNames.文章缓存); int size &#x3D; cache.getSize(); if (size &gt; 0) &#123; Query query &#x3D; cache.createQuery(); Attribute searchAttribute &#x3D; cache.getSearchAttribute(&quot;needUpdate&quot;); &#x2F;&#x2F;指定查询的 query.includeAttribute(searchAttribute); query.includeValues(); Results execute &#x3D; query.addCriteria(searchAttribute.eq(true)).execute(); List all &#x3D; execute.all(); log.info(&quot;查询文章缓存的大小：&#123;&#125;&quot;, all.size()); for (Result result : all) &#123; ArticlesDTO articles &#x3D; (ArticlesDTO) result.getValue(); articles.setNeedUpdate(false); Articles target &#x3D; new Articles();&#x2F;&#x2F; 同步浏览量、视频播放量、评论数、点赞数、收藏数 target.setVisitorNum(articles.getVisitorNum()).setCommentNum(articles.getCommentNum()). setPlayNum(articles.getPlayNum()).setLikeNum(articles.getLikeNum()).setCollectNum(articles.getCollectNum()); articlesService.updateById(target); &#125; &#125; &#125; 三、总结1、需要熟悉spring接口设计，以接口使用框架，要不然官方api使用需了解诸多细节。 四、一二级缓存 当遇到@Cacheable返回为null记录，为了成功序列化null，使用了org.springframework.cache.support.NullValue对象代替null。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889com.alibaba.fastjson.JSONException: autoType is not support. org.springframework.cache.support.NullValue1、起源一二级缓存重写get()方法public class EhRedisCache extends AbstractValueAdaptingCache &#123; 部分代码省略…… @Override public T get(Object key, Callable valueLoader) &#123; try &#123; lock.lock(); value &#x3D; lookup(key); if(value !&#x3D; null) &#123; return (T) value; &#125; value &#x3D; valueLoader.call(); &#x2F;&#x2F;toStoreValue是AbstractValueAdaptingCache抽象类的方法 Object storeValue &#x3D; toStoreValue(value); put(key, storeValue); return (T) value; &#125; catch (Exception e) &#123; throw new ValueRetrievalException(key, valueLoader, e.getCause()); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;2、toStoreValue判断userValue &#x3D;&#x3D; null 则return NullValue.INSTANCE -&gt; public static final Object INSTANCE &#x3D; new NullValue();public abstract class AbstractValueAdaptingCache implements Cache &#123; protected Object toStoreValue(@Nullable Object userValue) &#123; if (userValue &#x3D;&#x3D; null) &#123; if (this.allowNullValues) &#123; return NullValue.INSTANCE; &#125; throw new IllegalArgumentException( &quot;Cache &#39;&quot; + getName() + &quot;&#39; is configured to not allow null values but null was provided&quot;); &#125; return userValue; &#125;&#125;3、序列化反序列化public class FastJsonRedisSerializer implements RedisSerializer &#123; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if (null &#x3D;&#x3D; bytes || bytes.length &lt;&#x3D; 0) &#123; return null; &#125; String str &#x3D; new String(bytes, DEFAULT_CHARSET); return (T) JSON.parseObject(str, clazz); &#125;&#125;4、jsonParser解析类型public class com.alibaba.fastjson.parser.DefaultJSONParser implements Closeable &#123; public final Object parseObject(final Map object, Object fieldName) &#123; 部分代码省略…… Class clazz &#x3D; null; if (object !&#x3D; null &amp;&amp; object.getClass().getName().equals(typeName)) &#123; clazz &#x3D; object.getClass(); &#125; else &#123; &#x2F;&#x2F;com.alibaba.fastjson.parser.DefaultJSONParser#config执行 clazz &#x3D; config.checkAutoType(typeName, null, lexer.getFeatures()); &#125; &#125;&#125;5、异常抛出点TypeUtils.getClassFromMapping(typeName) -》 typeName为org.springframework.cache.support.NullValuepublic Class checkAutoType(String typeName, Class expectClass, int features) &#123; if (Arrays.binarySearch(denyHashCodes, hash) &gt;&#x3D; 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) &#x3D;&#x3D; null) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125;&#125;6、TypeUtils的getClassFromMapping方法返回null public static Class getClassFromMapping(String className)&#123; return mappings.get(className); &#125;7、TypeUtils不支持org.springframework.cache.support.NullValueprivate static ConcurrentMap&gt; mappings &#x3D; new ConcurrentHashMap&gt;(16, 0.75f, 1);&#x2F;&#x2F;mappings类型白名单private static void addBaseClassMappings()&#123; mappings.put(&quot;byte&quot;, byte.class); mappings.put(&quot;short&quot;, short.class); mappings.put(&quot;int&quot;, int.class); mappings.put(&quot;long&quot;, long.class); mappings.put(&quot;float&quot;, float.class); mappings.put(&quot;double&quot;, double.class); mappings.put(&quot;boolean&quot;, boolean.class); 部分代码省略…… fastJson官方没有支持org.springframework.cache.support.NullValue&#125; 反馈与建议 今天复出写博客，一是感觉懒了期望进步，二是为了积累知识方便copy😂。 邮箱：&#99;&#x61;&#111;&#x63;&#104;&#105;&#x6b;&#x61;&#105;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"}]},{"title":"AndroidAdb","date":"2017-02-05T12:49:09.000Z","path":"2017/02/05/AndroidAdb/","text":"Android adb调试工具–清除锁屏密码误解@(Android)[调试工具|实用教程|adb命令] Android Studio ADB官方文档 ADB全称为 Android Debug Bridge, 是android 里的一个调试工具, 用这个工具可以直接操作管理android模拟器或者真实的andriod设备手机。如果你安装了Android SDK（或者下载adb工具包，体积小）,存放sdk的platform-tools目录下，在 命令行cmd使用需要配置路径（android_sdk/platform-tools/adb.exe ）到环境变量里。它可为各种设备操作提供便利，如安装和调试应用，例如查看android中的数据库，提供对 Unix shell（可用来在模拟器或连接的设备上运行各种命令）的访问。该工具作为一个客户端-服务器程序，包括三个组件： 客户端 ：该组件发送命令。客户端在开发计算机上运行。您可以通过发出 adb 命令从命令行终端调用客户端； 后台程序 ：该组件在设备上运行命令。后台程序在每个模拟器或设备实例上作为后台进程运行； 服务器 ：该组件管理客户端和后台程序之间的通信。服务器在开发计算机上作为后台进程运行。 关于清除解锁图案 用户相关的文件accounts.db（gmail账号管理），gesture.key（手势识别文件），password.key（密码文件）。不同品牌手机系统相关文件名也会不同,例如我的手机，华为4x文件为locksettings.db（数据库文件）。修理店里的师傅使用一个工具叫星海神器（高通平台强刷），功能超乎想象，几乎支持所有手机品牌（特别是苹果）淘宝上有卖，网上大部分加密过！小米手机叫丢失解锁神器！ 1. 破解条件 手机打开USB并连接电脑 手机被ROOT，并且ADB可以直接升级为ROOT用户 配置adb路径到环境变量或者直接在cmd命令行里面切换到adb所在路径 2. 破解步骤 *打开cmd命令行，用【adb shell】命令进入shell * 利用su命令将adb提升为root用户，如果成功，行首由$变成 #，#表示root用户 *进入data/system目录 * *ls查看当前目录 * *用ls命令查看密码文件 * 用rm命令删除密码文件，若是$（不是root），则会提示”rm failed for … Permission denied”，权限不足 12345$ adb shell $ su# cd /data/system# ls# rm locksettings.db 输入reboot或手动重启手机生效。亲测华为荣耀4X有效，删除锁屏密码后，指纹解锁自动失效，所以此方法也可以破解指纹解锁！！重新设置锁屏密码后，以前设置的指纹解锁又可以用了。 3. 注意事项看到这儿就明白了，即便手机Root+打开USB调试，也是无法通过ADB解锁手机的。因为想要想要解锁，就得删除/data/system 下的相关文件，可删除需要由Superuser或者kingroot授予ADB shell权限，而授权需要解锁打开手机后操作Superuser程序。即解锁需要用到解锁后的手机操作，就像春晚小品《开锁》中，业主黄宏要求开锁师傅林永健开锁，林永健要求黄宏出示有效证件，可证件就在锁着的箱子里头。 我进行了测试后发现，在授权过一次后，下次手机用USB数据线连接电脑，再次进行解锁，即便同台电脑，也是需要再次授权的。这就说明，即便你用你的电脑经过手机授权解锁过，过后想要在忘记密码时使用ADB方式解锁，也是不可能的。 我觉得这是高版本的安卓系统（eg. Android 4.2 Jelly Bean 安卓果冻豆）新有的安全特性，低版本的Android如安卓2.3.8是可以通过这种方法解锁的。因为我实际测试，我的固件版本为安卓2.3.8的三星S5570（已经Root，打开USB调试），执行命令rm gesture.key，无需授权，直接即可解锁。现在我有个问题，低版本安卓系统如 Android2.3.8的手机解锁屏幕锁定密码，是否的确必须Root，还是只要打开USB调试即可？我手头没有没Root的Android2.3手机，也懒得折腾了，就不管它了。 这样看来，高版本的安卓系统也就不存在被非手机所有者恶意解锁的BUG了。4. 题外话（今年好东西都挂了）收费音乐神器官网，服务器接口平台AnyListen 音乐间谍为window PC版，音乐助手Android版，Shelher微博分享出来3.3版源码百度云 ​​​​密码gria！尴尬的是朋友云免流量也不干了！","tags":[]},{"title":"SpiderWebMagic","date":"2017-01-30T12:50:27.000Z","path":"2017/01/30/SpiderWebMagic/","text":"WebMagic爬虫框架–京东图书@(爬虫)[框架|爬虫|Demo总结] WebMagic!项目代码分为核心(webmagic-core)和扩展(webmagic-extension)两部分(jar包)。Downloader、PageProcessor、Scheduler、Pipeline这四大组件对应爬虫生命周期中的下载、处理、管理和持久化等功能。 名称 功能 Downloader 基础。利用httpClient作为下载工具，下载页面内容便于后续处理解析; Page 网页内容对象。 指根据url下载到的页面内容，包括页面dom元素，css样式，javascript等; Pageprocess 爬虫的核心。 负责解析页面，抽取有用信息，可采用css(),$(),xpath()方法对特定页面元素进行抽取; Site 网站设置。设置网站domain，cookies,header,重试次数,访问间隔时间等; Scheduler 抓取页面队列。 管理待抓取的URL，以及一些去重的工作，将目标url内容push到抓取队列中; Pipeline 输出，收尾。 负责抽取结果的处理，包括计算、持久化到文件、数据库; Spider 爬虫的入口类 采用链式设计，通过它来设定多线程，页面解析器，调度以及输出方式等。 WebMagic官方链接： 官网 包含官方文档和源码,以及相应的实例； github 仓库保存最新版本； oschinamayun码云 包含所有编译好的依赖包； 爬取京东图书(https://book.jd.com/)在商品列表网页抓取如下商品信息 商品名：商品名称 商品网页：显示商品详细信息的网页地址。 市场价格：京东给出的市面价格 京东价格：京东的优惠价。 关于ajax价格链接地址格式：http://p.3.cn/prices/mgets?skuIds=J_ + 商品ID，抓取格式为json。 https://item.jd.com/12087016.html ：图书详情页； http://p.3.cn/prices/mgets?skuIds=J_12087016 （例）价格ajax请求链接； [{“id”:”J_12087016”,”p”:”60.80”,”m”:”90.00”,”op”:”60.80”}] 抓取结果 id + 京东实际价格+市场价格 代码块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import us.codecraft.webmagic.Page;import us.codecraft.webmagic.Site;import us.codecraft.webmagic.Spider;import us.codecraft.webmagic.processor.PageProcessor;import java.util.ArrayList;import java.util.List;public class JDPageProcesser implements PageProcessor &#123; private Site site = Site.me().setRetryTimes(3).setSleepTime(3000).setCharset(\"GBK\"); private static int size = 0;// 共抓取到的图书数量 //抓取商品信息集合 private static List&lt;String&gt; name = new ArrayList&lt;String&gt;();//所有的书名 private static List&lt;String&gt; author = new ArrayList&lt;String&gt;();//所有的作者 private static List&lt;Double&gt; prices = new ArrayList&lt;Double&gt;();//所有的价格 @Override public void process(Page page) &#123; //图书主页 // https://item.jd.com/12004057.html if (!page.getUrl().regex(\"https://item.jd.com/\\\\d&#123;8&#125;.html\").match()&amp;!page.getUrl().regex(\"p.3.cn/prices/mgets\").match()) &#123; // 主页中添加商品详情页到计划url List&lt;String&gt; detail = page.getHtml().links().regex(\"//item.jd.com/\\\\d&#123;8&#125;.html\").replace(\"//\", \"https://\").all(); //控制抓取商品的数量 if (detail.size()&gt;0) &#123; for (int i = 0; i &lt; 4; i++) &#123; String url = detail.get(i); System.out.println(\"url:\" + url.replace(\"https://item.jd.com\", \"\").replace(\"/\", \"http://p.3.cn/prices/mgets?skuIds=J_\").replace(\".html\", \"\")); //列队添加一条详情页后面追加一条价格ajax链接 page.addTargetRequest(url); page.addTargetRequest(url.replace(\"https://item.jd.com\", \"\").replace(\"/\", \"http://p.3.cn/prices/mgets?skuIds=J_\").replace(\".html\", \"\")); &#125; &#125; &#125; if (page.getUrl().regex(\"https://item.jd.com/\\\\d&#123;8&#125;.html\").match()) &#123; // 商品详情页 size++; name.add(page.getHtml().xpath(\"//div[@id=name]/h1/text()\").get());//添加书名 author.add(page.getHtml().xpath(\"//div[@id=p-author]/a/text()\").get());//添加作者 &#125; if (page.getUrl().regex(\"p.3.cn/prices/mgets\").match()) &#123; //ajax商品id对应价格json接口 prices.add(Double.parseDouble(page.getHtml().replace(\"&amp;quot\", \"\").regex(\"p;:;.+;,;m\").regex(\"\\\\d+\\\\.\\\\d+\").get()));//添加价格 &#125; &#125; @Override public Site getSite() &#123; return site; &#125; //获取所有信息导入DAO,持久化层待实现 private static void getAll() &#123; System.out.println(\"Size\" + name.size() + author.size() + prices.size()); for (int i = 0; i &lt; name.size(); i++) &#123; JDLog model = new JDLog(); model.setName(name.get(i)); model.setAuthor(author.get(i)); model.setPrices(prices.get(i)); System.out.println(\"书名:\" + model.getName()); System.out.println(\"作者:\" + model.getAuthor()); System.out.println(\"价格:\" + model.getPrices()); &#125; &#125; public static void main(String[] args) &#123; long startTime, endTime; System.out.println(\"【爬虫开始】请耐心等待一大波数据到你碗里来...\"); startTime = System.currentTimeMillis(); // 从京东图书开始抓，开启5个线程，启动爬虫 Spider.create(new JDPageProcesser()).addUrl(\"https://book.jd.com/\").thread(3).run(); endTime = System.currentTimeMillis(); getAll(); System.out.println(\"【爬虫结束】共抓取\" + size + \"本图书，耗时约\" + ((endTime - startTime) / 1000) + \"秒，已保存到数据库，请查收！\"); &#125;&#125; 以后将会坚持更新!反馈与建议 邮箱：&#99;&#97;&#x6f;&#99;&#104;&#x69;&#107;&#97;&#x69;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;","tags":[]},{"title":"My New Post","date":"2016-12-24T13:46:06.000Z","path":"2016/12/24/First Wirte/","text":"Markdown初次使用Markdown是一门轻量级语法,仅仅需要5分钟你就能搞懂! 期末刷jsp作业心得 DAO层封装成工具类 ：持久层处理业务,尽量把变化东西采用数组遍历,约定成俗简化成配置化写； 登陆注册模块重用 ：前端样式变化,但尽量不要修改提交参数名称和个数； 单元测试类 ：使用 junit测试框架检查逻辑是否有误,方便部署调试 。 代码块1234567891011121314151617// 执行更新操作----带预编译参数public int excuteUpdate(String sql, String[] params) &#123; int result = 0; try &#123; pstmt = getCon().prepareStatement(sql); for (int i = 0; i &lt; params.length; i++) &#123; pstmt.setString(i + 1, params[i]); &#125; result = pstmt.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; pstmtClose(); conClose(); &#125; return result;&#125; ##以后将会持续更新,预告 webmagic 框架爬虫下次出 反馈与建议 邮箱：&#99;&#97;&#x6f;&#99;&#x68;&#x69;&#107;&#x61;&#x69;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;","tags":[]}]
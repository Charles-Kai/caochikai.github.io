[{"title":"接口测试 Rest-assured","date":"2021-08-02T14:31:00.000Z","path":"2021/08/02/接口测试-Rest-assured/","text":"接口测试 Rest-assured一、如何确保 API 的稳定性与正确性呢？ 全面系统的测试是必不可少的。Java 开发者常常借助于 JUnit或者TestNg做单元测试！但是从REST API来讲，开发者知道正在测试的是哪个类、哪个方法，测试的是哪个 REST API，所以就需要由一套 Java 实现的 REST API 测试框架。虽然它不是从用户的角度出发，但是结合BDD行为驱动测试，就能保证接口的稳定性和功能的正确性！当然本章还是以rest-assured为主。 什么是Rest-assured? Rest-Assured 是一套由 Java 实现的 REST API 测试框架，它是一个现代化轻量级的 REST API 客户端，可以简化HTTP Builder向服务器端发起 HTTP 请求，并验证和校对返回结果；它的语法非常简洁，是一种专为测试 REST API 而设计的 DSL（针对某一领域，具有受限表达性的一种计算机程序设计语言）。这套写测试代码方案适合比较复杂切不成熟的接口，另外还有一套以JSON测试方案适合成熟简洁的系统，后面再写。 二、Rest-assured好特性 现代化简洁的语法，针对JSON、XML和身份认证有非常多的语法糖（疯狂链式调用，非常Groovy）。 JSON Schema Validation：特别是校验返回的JSON结构体，初期设计往往会落后于实际，最后需要做回归测试，同步修改初期的设计。 Spring Mock Mvc和Spring Web Test Client有集成模块，生态成熟。 三、集成Maven Dependencies12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;dependency&gt; &lt;groupId&gt;io.rest-assured&lt;/groupId&gt; &lt;artifactId&gt;rest-assured&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.rest-assured&lt;/groupId&gt; &lt;artifactId&gt;json-schema-validator&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.rest-assured&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- Testng --&gt;&lt;dependency&gt; &lt;groupId&gt;org.testng&lt;/groupId&gt; &lt;artifactId&gt;testng&lt;/artifactId&gt; &lt;version&gt;7.0.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;build&gt; &lt;plugins&gt; &lt;!-- 测试插件 surefire --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;surefire-plugin.version&#125;&lt;/version&gt; &lt;configuration&gt; &lt;!-- allure 2 配置 --&gt; &lt;argLine&gt; -javaagent:\"$&#123;settings.localRepository&#125;/org/aspectj/aspectjweaver/$&#123;aspectj.version&#125;/aspectjweaver-$&#123;aspectj.version&#125;.jar\" &lt;/argLine&gt; &lt;!-- 指定 xml 文件 --&gt; &lt;suiteXmlFiles&gt; &lt;!-- 通过美元符的形式可以将 jenkins 中参数传递过来，指定要运行的 xml 名 --&gt; &lt;!-- &lt;suiteXmlFile&gt;$&#123;xml.file&#125;&lt;/suiteXmlFile&gt; --&gt; &lt;suiteXmlFile&gt;testng.xml&lt;/suiteXmlFile&gt; &lt;/suiteXmlFiles&gt; &lt;!--Jenkins参数传递给Maven，mvn command使用 -D参数名称 将参数传递至所运行项目 --&gt; &lt;systemPropertyVariables&gt; &lt;!-- jenkins 参数一 --&gt; &lt;param1&gt;$&#123;param1&#125;&lt;/param1&gt; &lt;!-- jenkins 参数二 --&gt; &lt;param2&gt;$&#123;param2&#125;&lt;/param2&gt; &lt;!-- jenkins 参数三 --&gt; &lt;param3&gt;$&#123;param3&#125;&lt;/param3&gt; &lt;/systemPropertyVariables&gt; &lt;argLine&gt;-Dfile.encoding=UTF-8&lt;/argLine&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;!-- allure 2 配置依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;$&#123;aspectj.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 完整例子123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"title\": \"Product set\", \"type\": \"array\", \"items\": &#123; \"title\": \"Product\", \"type\": \"object\", \"properties\": &#123; \"id\": &#123; \"description\": \"The unique identifier for a product\", \"type\": \"number\" &#125;, \"name\": &#123; \"type\": \"string\" &#125;, \"price\": &#123; \"type\": \"number\", \"minimum\": 0, \"exclusiveMinimum\": true &#125;, \"tags\": &#123; \"type\": \"array\", \"items\": &#123; \"type\": \"string\" &#125;, \"minItems\": 1, \"uniqueItems\": true &#125;, \"dimensions\": &#123; \"type\": \"object\", \"properties\": &#123; \"length\": &#123;\"type\": \"number\"&#125;, \"width\": &#123;\"type\": \"number\"&#125;, \"height\": &#123;\"type\": \"number\"&#125; &#125;, \"required\": [\"length\", \"width\", \"height\"] &#125;, \"warehouseLocation\": &#123; \"description\": \"Coordinates of the warehouse with the product\", \"$ref\": \"http://json-schema.org/geo\" &#125; &#125;, \"required\": [\"id\", \"name\", \"price\"] &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445import io.restassured.module.mockmvc.RestAssuredMockMvc;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.web.context.WebApplicationContext;import static io.restassured.module.mockmvc.RestAssuredMockMvc.given;import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.httpBasic;import static org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.authenticated;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = MyConfiguration.class)@WebAppConfigurationpublic class BasicAuthExample &#123; @Autowired private WebApplicationContext context; @Before public void rest_assured_is_initialized_with_the_web_application_context_before_each_test() &#123; RestAssuredMockMvc.webAppContextSetup(context); &#125; @After public void rest_assured_is_reset_after_each_test() &#123; RestAssuredMockMvc.reset(); &#125; @Test public void basic_auth_example() &#123; given(). auth().with(httpBasic(\"username\", \"password\")). when(). get(\"/products\"). then(). statusCode(200) .body(matchesJsonSchemaInClasspath(\"products-schema.json\")) .expect(authenticated().withUsername(\"username\")); &#125;&#125; 五、参考资料 官方文档 WIKI","tags":[{"name":"Test","slug":"Test","permalink":"https://caochikai.github.io/tags/Test/"}]},{"title":"API Standard","date":"2021-08-01T07:30:00.000Z","path":"2021/08/01/API-Standard/","text":"API Standard一、意义 API standard即接口标准，它提供了工程开发指南和最好的培训实现，能让API接口开发者自愿跟随共同的工程标准，技术解决方案，公共库管理，甚至是构建API的模板。 二、各项标准 项目标准涉及到方方面面，随着业务不断发展，持续演变进化，架构团队需要与各团队深度合作，成立架构评审委员会ARB，在不断配合业务部门支撑公司业务发展，勇于承担重任。 分类 标准 文档名称 目的 培训 开发者工具和权限申请 培训文档 使用免费的软件和工具是主要方向，应根据最小权限原则在必要时候申请。 培训 快速开始指引 新人指引离职指引技术经理指引数据库工程师指引 基于不同的团队角色提供开始文档，比如leader和developer 开发流程 代码标准 代码标准 在API开发中必须遵循代码标准 开发流程 分支策略 分支管理策略 提供分支、提交信息、拉请求和代码合并的命名规定。主分支是保护分支。理想情况下，开发完成才有主分支。feature功能分支合并后必须删除。 开发流程 CI/CD Pipeline CI/CD Pipeline 在上生产之前必须审查扫描报告 接口设计 HTTP REST，API契约和JSON标准 接口设计 遵循OpenAPI 或者RAML规范。JSON schema和example由开发者必须提供。 应用基础 Spring Boot框架 应用基础 选型Spring Boot作为后端API开发基础框架。提供父POM和公共包推动API接口开发。 应用基础 依赖管理 源码依赖管理 提供parent-dependencies BOM统一依赖管理。提供两套父POM针对WebMvc和WebFlux标准给API开发。开发者可以根据需求选择其中一个父POM。 应用基础 仓库、包、类、文件夹结构的命名规范和代码规范 源码管理 开发者应当遵守包命名规范。为SpringBoot API提供了预定义的文件夹和文件结构。提供了编码规范，建议开发人员应遵循。 应用基础 公共库 公共库 提供公共库来推动API开发。loggingerror-handingraml-paserhttp-client 应用基础 模板和参考实现 模板和参考实现 提供简单和模板。提供代码生成器。 编码流程 业务流程和编排 业务流程和编排 对基础服务选择同步或者异步调用。对基础服务选择同步或者顺序调用。复杂编排规范分析。 编码流程 非阻塞IO和响应式模式 非阻塞IO和响应式模式 应当使用Reactor Reactive开发。 编码流程 数据校验 数据校验 输入数据必须要在业务处理之前校验。API规范中必须定义数据校验。 编码流程 数据转化和匹配 数据转化和匹配 MapStruct选型为mapping framework。Jackson选型为默认json和POJO 转化框架。Lombok禁止使用。 编码流程 限流熔断 限流熔断 在应用推荐使用resislence4j库。 编码流程 异常处理 异常处理 Error Schema必须遵守。自定义HTTP状态码和Error code不要冲突公共规范。提供公共全局异常处理库处理应用跑出的error。 协议支持 Http Server Http Server 强制默认使用tomcat和8080端口或netty。 协议支持 HTTP Client HTTP Client Reactor Netty Client是核心http client库。公共库提供默认配置和扩展配置。如超时、代理等。 协议支持 数据加密和安全 数据加密和安全 提供公共库异步记录请求和响应到日志，保护敏感数据进行加密打印。 安全 鉴权 鉴权 强制开启Token校验。允许健康检查相关端点跳过。 安全 授权 授权 针对用户角色校验当前请求时候是否有权限。 安全 环境变量加密 环境变量加密 阿里云密钥管理服务（KMS）或者AWS Secret Mananger来存储环境变量。 安全 密钥管理 密钥管理 阿里云密钥管理服务（KMS）或者AWS Secret Mananger来管理秘钥，通过脚本定期更新服务密码。如数据库和redis。 安全 SSL强制校验 SSL强制校验 所有连接必须使用SSL加密。应用中通过Https FItler强制开启。 安全 参数加密解密 参数加密解密 公共库secure-data提供运行时重要参数加密解密。 安全 Client ID和Secret秘钥对 Client ID和Secret秘钥对 针对部分的外部第三应用授权和接口限流。 监控和故障排查 日志 日志 关键信息必须打印。提供公共包logging。 监控和故障排查 日志框架 日志框架 SF4J and logback选型为默认日志库。 监控和故障排查 日志规范 日志规范 INFO级别为默认配置。长时间处理任务必须打印日志。日志打印点和数据必须review。 监控和故障排查 日志配置和输出 日志配置和输出 提供公共日志配置和公共抽象接口，异常时将打印erro并返回规定error schema。 监控和故障排查 日志追踪 日志追踪 日志必须记录异常出现信息和Trace ID，不能吞掉异常信息。 监控和故障排查 Info和Health端点 Info和Health端点 提供公共库endpoint。info端点必须提供当前应用基础信息。health端点必须保护应用当前状态。 监控和故障排查 Splunk集成 Splunk集成 通过CICD pipeline配置namespace lable完成集成。在控制台必须符合监控规范。 监控和故障排查 AppDynamic集成 AppDynamic集成 在容器里配置JAVAOPS AppDynamic参数和agent集成。 支持 发布配置 发布配置 推荐发布配置不要参合到应用代码。通过属性外部化配置，如容器环境变量，通过不修改代码和重新部署情况下方便重新调整配置。 支持 多区域发布支持 多区域发布支持 同一套代码支持不同数据中心。 测试 单元测试和代码覆盖率 单元测试和代码覆盖率 使用Junit 5 单元测试框架。提供公共库完成API功能测试。行和分支测试覆盖率不能低于100%。 测试 集成测试 集成测试 做测试渗透率和压力测试。提供jemeter压测脚本和框架，通过Prometheus控制面板集成Jenkins报告和AppDynamic jvm性能指标。 审计 Checkmax, Nexus IQ,SonarQube和Jacoco 代码质量测量 Checkmax能检查应用代码漏洞，要求必须为零。Nexus IQ扫描安全和license法务风险，超低级必须低于5个，中高级风险必须为零，否则提供审计报告。SonarQube和jacoco测量代码和测试质量，漏洞和错误必须为零，测试覆盖必须100%。 审计 README.md 项目文档规范 READMED.md必须强制记录关键信息。 其他 架构演变历史 架构演变历史 记录架构随年度变化演变历史背景。 其他 支持插件 支持插件 提供插件支持根据预定义规则扫描Maven构建过程中的源码，上传到分析服务，生成对应报告，验证当前代码是否符合整套架构规范。","tags":[{"name":"架构","slug":"架构","permalink":"https://caochikai.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"行为驱动测试BDD Cucumber方案","date":"2021-07-31T16:19:00.000Z","path":"2021/08/01/行为驱动测试BDD-Cucumber方案/","text":"行为驱动测试BDD Cucumber方案一、什么是BDD Behaviour-Driven Development既行为驱动开发，是构建Cucumber以支持的软件开发过程。 BDD是软件团队的一种工作方式，通过以下方式缩小业务人员和技术人员之间的差距: 鼓励跨角色的协作，以建立对要解决的问题的共享理解。 业务员根据用户的行为生成需求场景描述文档，比如行为条件和参数，相当于伪代码。 技术人员通过用户的行为场景设计测试用例，验收和驱动开发，并生成符合伪代码报告。 敏捷流程 二、Cucumber特性 Cucumber是一种可以使用文本描述语言来执行自动测试用例的工具，使用的语言叫做Gherkin。Gherkin用于描述软件的行为而不需要了解具体的实现，主要有两个目的文档和自动测试用例（最好和手工测试用例统一）。 Gherkin支持超过40种语言，包括英文、中文。 Gherkin可以在任何地方新增注释，注释已#开头，都是以.feature结尾，在feature文件中输入功能描述、场景、步骤，当执行这个功能时每一个步骤都需要编写java代码块来实现具体的功能。当前cucumber支持多种语言，还可以使用java和spring、javascript和react。下面是Cucumber Ruby 官方截图： Ruby官方例子 Cucumber Report截图 Gherkin语言基本概念：Features功能 一个feature文件对应一组集合功能，比如用户管理。 Scenario场景 一个feature文件对应一组Scenario场景，比如用户管理功能有新增用户，删除用户，修改用户和查询用户四个场景。Scenario Outline场景大纲必须包含一个示例Examples，Examples有多少行测试驱动数据，测试场景Scenario就执行多少次，以下面步骤第一步Given step的参数变量，就来源于Examples下的day。 Step denfinitions步骤 Scenario场景下有多个Step步骤，每一Step步骤都以Given, When, Then, And, or But开始。 Given When then(假如 当 那么) 每一步都以Given, When, Then, And, or But开始。java实现都有对应注解。 Given——@Given：用例开始执行前的一个前置条件，比如用户已经登录对应代码有jwt token。 When——@When：用例开始执行的一些关键操作步骤，类似修改用户性别等。 Then——@Then：观察结果，就是平时用例中的验证步骤，比如修改后验证数据库是否存入操作成功。 通过下列步骤介绍Cucumber流程： 第一步：通过Gherkin伪代码文本语言描述，写到feature文件。以官方10分钟体验为例： 12345678910111213Feature: Is it Friday yet? Everybody wants to know when it's Friday Scenario Outline: Today is or is not Friday Given today is \"&lt;day&gt;\" When I ask whether it's Friday yet Then I should be told \"&lt;answer&gt;\" Examples: | day | answer | | Friday | TGIF | | Sunday | Nope | | anything else! | Nope | 使用java进行步骤定义。feature文件的step对应了每个java方法上的注解，而且注解双引号文本内容在所有feature中唯一且不可重复。 1234567891011121314151617181920212223242526272829303132package hellocucumber;import io.cucumber.java.en.Given;import io.cucumber.java.en.When;import io.cucumber.java.en.Then;import static org.junit.Assert.*;class IsItFriday &#123; static String isItFriday(String today) &#123; return \"Friday\".equals(today) ? \"TGIF\" : \"Nope\"; &#125;&#125;public class Stepdefs &#123; private String today; private String actualAnswer; @Given(\"today is &#123;string&#125;\") public void today_is(String today) &#123; this.today = today; &#125; @When(\"I ask whether it's Friday yet\") public void i_ask_whether_it_s_Friday_yet() &#123; actualAnswer = IsItFriday.isItFriday(today); &#125; @Then(\"I should be told &#123;string&#125;\") public void i_should_be_told(String expectedAnswer) &#123; assertEquals(expectedAnswer, actualAnswer); &#125;&#125; Maven mvn test控制台输出: 1234567891011121314151617181920212223242526272829303132------------------------------------------------------- T E S T S-------------------------------------------------------Running hellocucumber.RunCucumberTestFeature: Is it Friday yet? Everybody wants to know when it&#39;s Friday Scenario Outline: Today is or is not Friday # hellocucumber&#x2F;is_it_friday_yet.feature:4 Given today is &quot;&lt;day&gt;&quot; When I ask whether it&#39;s Friday yet Then I should be told &quot;&lt;answer&gt;&quot; Examples: Scenario Outline: Today is or is not Friday # hellocucumber&#x2F;is_it_friday_yet.feature:11 Given today is &quot;Friday&quot; # Stepdefs.today_is(String) When I ask whether it&#39;s Friday yet # Stepdefs.i_ask_whether_it_s_Friday_yet() Then I should be told &quot;TGIF&quot; # Stepdefs.i_should_be_told(String) Scenario Outline: Today is or is not Friday # hellocucumber&#x2F;is_it_friday_yet.feature:12 Given today is &quot;Sunday&quot; # Stepdefs.today_is(String) When I ask whether it&#39;s Friday yet # Stepdefs.i_ask_whether_it_s_Friday_yet() Then I should be told &quot;Nope&quot; # Stepdefs.i_should_be_told(String) Scenario Outline: Today is or is not Friday # hellocucumber&#x2F;is_it_friday_yet.feature:13 Given today is &quot;anything else!&quot; # Stepdefs.today_is(String) When I ask whether it&#39;s Friday yet # Stepdefs.i_ask_whether_it_s_Friday_yet() Then I should be told &quot;Nope&quot; # Stepdefs.i_should_be_told(String)3 Scenarios (3 passed)9 Steps (9 passed)0m0.255s 三、集成Spring生成测试报告Maven Dependencies123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;io.cucumber&lt;/groupId&gt; &lt;artifactId&gt;cucumber-java&lt;/artifactId&gt; &lt;version&gt;6.8.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.cucumber&lt;/groupId&gt; &lt;artifactId&gt;cucumber-junit&lt;/artifactId&gt; &lt;version&gt;6.8.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.cucumber&lt;/groupId&gt; &lt;artifactId&gt;cucumber-spring&lt;/artifactId&gt; &lt;version&gt;6.8.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; REST Controller1234567@RestControllerpublic class VersionController &#123; @GetMapping(\"/version\") public String getVersion() &#123; return \"1.0\"; &#125;&#125; Cucumber Step Definitions12345//单独跑Cucumber@RunWith(Cucumber.class)@CucumberOptions(features = \"src/test/resources\")public class CucumberIntegrationTest &#123;&#125; 12345Feature: the version can be retrieved Scenario: client makes call to GET /version When the client calls /version Then the client receives status code of 200 And the client receives server version 1.0 12345678910111213141516@When(\"^the client calls /version$\")public void the_client_issues_GET_version() throws Throwable&#123; executeGet(\"http://localhost:8080/version\");&#125;@Then(\"^the client receives status code of (\\\\d+)$\")public void the_client_receives_status_code_of(int statusCode) throws Throwable &#123; HttpStatus currentStatusCode = latestResponse.getTheResponse().getStatusCode(); assertThat(\"status code is incorrect : \"+ latestResponse.getBody(), currentStatusCode.value(), is(statusCode));&#125;@And(\"^the client receives server version (.+)$\")public void the_client_receives_server_version_body(String version) throws Throwable &#123; assertThat(latestResponse.getBody(), is(version));&#125; 1234567891011121314//集成Springboot@CucumberContextConfiguration@SpringBootTestpublic class SpringIntegrationTest &#123; // executeGet implementation&#125;//进行接口自动化测试public class StepDefs extends SpringIntegrationTest &#123; @When(\"^the client calls /version$\") public void the_client_issues_GET_version() throws Throwable &#123; executeGet(\"http://localhost:8080/version\"); &#125;&#125; 四、Moco Server在集成测试和开发中应用 moco工具是在github开源的一个项目，可以搭一个简单的mock server方便我们进行开发调试，以及在单元测试中取消边界服务。有两种形式，第一种是集成到项目，随项目启动提供http mock服务。第二种是一个jar包，配合配置文件和命令启动http服务。 通过jar提供mock http服务：首先我们要编写一个config文件，把我们需要“模拟”的请求和响应写入这个配置文件，配置文件是json格式的访问 localhost:12306/hello 接口，返回一个纯文本“moco”。 123456789101112[ &#123; \"request\": &#123; \"uri\":\"/hello\" &#125;, \"response\": &#123; \"text\":\"moco\" &#125; &#125;] 启动指令： 1java -jar moco-runner-0.11.1-standalone.jar http -p 12306 -c config.json 集成到项目Maven Dependencies12345&lt;dependency&gt; &lt;groupId&gt;com.github.dreamhead&lt;/groupId&gt; &lt;artifactId&gt;moco-core&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt; API Test123456789101112131415161718192021222324252627282930313233import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import static com.github.dreamhead.moco.Moco.httpServer;import static com.github.dreamhead.moco.Runner.runner;import static org.hamcrest.CoreMatchers.is;import static org.hamcrest.MatcherAssert.assertThat;public class MocoRunnerTest &#123; private Runner runner; @Before public void setup() &#123; HttpServer server = httpServer(12306); server.response(\"foo\"); runner = runner(server); runner.start(); &#125; @After public void tearDown() &#123; runner.stop(); &#125; @Test public void should_response_as_expected() throws IOException &#123; Content content = Request.Get(\"http://localhost:12306\").execute().returnContent(); assertThat(content.asString(), is(\"foo\")); &#125;&#125; 五、参考资料 Cucumber官方文档 Cucumber测试报告例子 Cucumber入门2 - 啥是BDD？ Moco Server","tags":[{"name":"Test","slug":"Test","permalink":"https://caochikai.github.io/tags/Test/"}]},{"title":"Netty Connection prematurely closed BEFORE response和connection reset by peer解决方案","date":"2021-07-31T03:50:00.000Z","path":"2021/07/31/Netty-Connection-prematurely-closed-BEFORE-response和connection-reset-by-peer解决方案/","text":"Netty Connection prematurely closed BEFORE response和connection reset by peer解决方案一、异常说明 在长达一年时间里面，由于云基础设施kubernetes经常升级更新，以及网络原因不定期出现。长期和云设施部门打交道，所有k8s集群都是Istio进行流量控制，Istio提供服务网格服务。如果要请求到容器外部网络，需要通过Egress Gateway的组件，从HTTPS代理Squid proxy请求外部网络。一个Squid proxy集群对应一个k8s，一个Squid集群十二个节点，部分节点出现故障就会造成整个集群出现概率性netty请求异常。作为踩雷先锋队和救火员，所以很多其他部门或者团队都有向我咨询反馈，首先从日志平台Splunk搜索到异常，进入容器通过curl -kv 测试外部请求，出现概率性连接异常，连接被重置了。概率问题通常会想到jemeter做接口压测，通过jemeter的聚合报告，大概有23%概率出现error，写报告申请云设施部门反馈，最终发现某个Squid节点故障，删除该节点再次压测，一切恢复正常。后面一段时间，遇到部署成功，第一次请求一定发生该上次问题，反馈之后短时间没解决，我们通过netty reactor retry策略，一旦发生该异常触发重试请求，从代码上解决问题。 1CURL ERROR: Recv failure: Connection reset by peer Splunk收集到的异常日志： Splunk是收集实时IT设施的数据日志平台，在国外非常流行，类似商业化的ELK。架构上通过splunk-connect-for-kubernetes开源项目，负责收集几个K8s集群的容器日志，每个集群大概200到300多个namespace，可以说性能非常给力。 Connection prematurely closed BEFORE response 12345reactor.core.ReactiveException: reactor.netty.http.client.PrematureCloseException: Connection prematurely closed BEFORE response at reactor.core.Exceptions.propagate(Exceptions.java:393) at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:97) at reactor.core.publisher.Mono.block(Mono.java:1678)·······业务相关，省略 connection reset by peer 12345678910111213141516java.io.IOException: Connection reset by peer at sun.nio.ch.FileDispatcherImpl.read0(FileDispatcherImpl.java) at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:39) at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223) at sun.nio.ch.IOUtil.read(IOUtil.java:192) at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380) at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288) at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108) at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886) at java.lang.Thread.run(Thread.java:748) 二、Retry策略解决第一次必定出现Connection reset by peer 在实际的开发中，可以请求重试的场景应该是：网络异常、请求超时异常，需根据实际应用场景的设计重试策略，防止重试带来接口幂等性问题。 123456789101112Retry&lt;?&gt; retry = Retry.onlyIf(x -&gt; x.exception() instanceof IOException) .retryMax(3) // 重试3次 .backoff(Backoff.exponential(Duration.ofSeconds(5),Duration.ofSeconds(60),2,true));Mono&lt;String&gt; mono = webClient .get() //GET 请求 .uri(\"/posts/1\") // 请求路径,这里的请求路径是正确的 .retrieve() .bodyToMono(String.class) .retryWhen(retry); //满足Retry条件进行重试System.out.println(\"=====\" + mono.block()); 三、网络分析 网络异常原因从本质上网络连接，牵扯到TCP三次握手建立连接，又导致Socket套接字在读取数据时，服务器端因为某种原因提前关闭了Connection，而客户端依然用握手成功的旧连接在读写数据，此时服务器会返回复位标志“RST”，然后客户端就会提示“java.net.SocketException: Connection reset”。 基础概念套接字Socket 以192.168.1.11:80为例子，TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字。 半连接队列和全连接队列 在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：半连接队列，也称 SYN 队列；全连接队列，也称 accepet 队列； 服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。 滑动窗口 控制报文流量，用来告诉对方目前接收端缓冲器大小。当为0时标识缓冲器已满，需要停止发包，单位为byte。 SYN 同步序列编号（Synchronize Sequence Numbers），在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息。 ACK Acknowledge character即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。 RST Reset the connection表示复位，关闭因某种原因引起出现的错误连接，也用来拒绝非法数据和请求。 FIN No more data from sender，用来释放连接，表明发送方已经没有数据发送了。 URG Urgent Pointer field significant紧急指针。用到的时候值为1，用来处理避免TCP数据流中断。 PSH Push Function——PUSH标志的数据，置1时请求的数据段在接收方得到后就可直接送到应用程序，而不必等到缓冲区满时才传送。 wireshark网络抓包TCP三次握手到RST复位 upload successful TCP协议：三次握手、四次挥手 upload successful 三次握手建立连接 upload successful 四次握手关闭连接 upload successful 四、参考资料 WebClient第6篇-请求失败自动重试机制 github netty: java.io.IOException: Connection reset by peer TCP中的RST标志(Reset)详解 两张动图-彻底明白TCP的三次握手与四次挥手 TCP协议中的6个重要标志位 TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？","tags":[{"name":"Linux","slug":"Linux","permalink":"https://caochikai.github.io/tags/Linux/"},{"name":"TCP","slug":"TCP","permalink":"https://caochikai.github.io/tags/TCP/"}]},{"title":"redis如何实现消息队列","date":"2020-06-06T14:55:00.000Z","path":"2020/06/06/redis如何实现消息队列/","text":"redis如何实现消息队列一、复盘面试 遇到面试问到：如果我想在redis实现队列，会用到哪个命令？根据redis手册关于Redis 列表(List) 命令主要操作有四种非阻塞版lpush/lpop/rpush/rpop，两种阻塞版本blpop/brpop，l和r代表左（left）和右（right）缩写，push代表添加也叫压入，pop代表弹出。基本满足先进入先出（FIFO）效果就完成了基本的队列，本次GitHub实验代码仓库。 通过命令模拟队列12345678910111213141516RDM Redis Console连接中...已连接。localhost:0&gt;lpush mylist a b c d\"4\"localhost:0&gt;rpop mylist\"a\"localhost:0&gt;rpop mylist\"b\"localhost:0&gt;rpop mylist\"c\"localhost:0&gt;rpop mylist\"d\"localhost:0&gt;rpop mylistnulllocalhost:0&gt; 二、java模拟队列实现生产者消费者模式redis配置常量1234567891011121314151617181920package io.charles;public class Constant &#123; /** * redis链接地址 */ public static final String host = \"127.0.0.1\"; /** * redis启动端口 */ public static final int port = 6379; /** * 正式队列列表名称 */ public static final String task_queue = \"task-queue\"; /** * 临时队列列表名称 */ public static final String tmp_queue = \"tmp-queue\";&#125; TaskProducer模拟生产者123456789101112131415161718192021222324252627282930package io.charles;/** * 用于模拟生产者 */import java.util.Random;import java.util.UUID;import redis.clients.jedis.Jedis;public class TaskProducer implements Runnable &#123; Jedis jedis = new Jedis(Constant.host, Constant.port); public void run() &#123; Random random = new Random(); while (true) &#123; try &#123; Thread.sleep(random.nextInt(600) + 600); // 模拟生成一个任务 UUID taskid = UUID.randomUUID(); //将任务插入任务队列：task-queue jedis.lpush(Constant.task_queue, taskid.toString()); System.out.println(\"插入了一个新的任务： \" + taskid); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; TaskConsumer模拟消费者1234567891011121314151617181920212223242526272829303132333435363738394041package io.charles;import java.util.Random;import redis.clients.jedis.Jedis;/** * 模拟消费者 */public class TaskConsumer implements Runnable &#123; Jedis jedis = new Jedis(Constant.host, Constant.port); public void run() &#123; Random random = new Random(); while (true) &#123; //从任务队列\"task-queue\"中获取一个任务，并将该任务放入临时队列\"tmp-queue\" String taskid = jedis.rpoplpush(Constant.task_queue, Constant.tmp_queue); // 模拟一下：睡觉 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //模拟成功和失败的偶然现象 if (random.nextInt(13) % 7 == 0) &#123;// 模拟失败的情况,概率为2/13 //将本次处理失败的任务从临时队列\"tmp-queue\"中，弹回任务队列\"task-queue\" jedis.rpoplpush(Constant.task_queue, Constant.tmp_queue); System.out.println(taskid + \"处理失败，被弹回任务队列\"); &#125; else &#123;// 模拟成功的情况 // 将本次任务从临时队列\"tmp-queue\"中清除 jedis.rpop(Constant.tmp_queue); System.out.println(taskid + \"处理成功，被清除\"); &#125; &#125; &#125;&#125; TaskShedulerSystem启动生产者和消费者线程1234567891011121314package io.charles;public class TaskShedulerSystem &#123; public static void main(String[] args) throws Exception &#123; // 启动一个生产者线程，模拟任务的产生 new Thread(new TaskProducer()).start(); Thread.sleep(15000); //启动一个线程者线程，模拟任务的处理 new Thread(new TaskConsumer()).start(); &#125;&#125; 三、参考资料 redis中文命令手册 GitHub实验代码仓库","tags":[{"name":"redis","slug":"redis","permalink":"https://caochikai.github.io/tags/redis/"}]},{"title":"基于Seata实现分布式事务","date":"2020-05-31T03:24:00.000Z","path":"2020/05/31/基于Seata实现分布式事务/","text":"一、Seata简介 2019 年 1 月，阿里巴巴中间件团队发起了开源项目 Fescar（Fast &amp; EaSy Commit And Rollback），蚂蚁金服后在Fescar 0.4.0 版本中贡献了 TCC 模式。后来更名为 Seata，意为：Simple Extensible Autonomous Transaction Architecture，是一套一站式分布式事务解决方案。 Seata三大基本组件： Transaction Coordinator (TC)： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。 Transaction Manager (TM)： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。 Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。 Seata官方调用流程图： upload successful 二、Fescar相比XA二阶段优缺点：优点： 基于SQL解析实现了自动补偿，降低业务侵入性。 第一阶段就本地事务就提交了 ，二阶段commit是异步操作相对XA两段全部持有资源更高效。 Fescar提供了两种模式，AT和MT。在AT模式下事务资源可以是任何支持ACID的数据库，在MT模式下事务资源没有限制，可以是缓存，可以是文件，可以是其他的等等。当然这两个模式也可以混用。 global lock全局锁实现了写隔离与读隔离。 Undolog日志自动清理 缺点： 代码入侵性体现为配置Fescar的数据代理和加个注解，每个业务库都需要一个Undolog表。 从调用图中开源看出性能损耗有：一条Update的SQL，获取全局事务xid（TC通讯）、before image（查询）、after image（查询）、insert undo log（Undolog表的blob字段数据量可不小）、before commit（TC通讯，判断锁冲突）；为了自动补偿在Undolog表花了不小开销，而且触发概率比较低。 二阶段commit也是需要占用系统资源。 二阶段回滚需要删除各节点的Undolog才能释放全局锁。 三、实验 本次实验使用的是官方提供的springcloud-eureka-feign-mybatis-seata工程，模拟远程调用超时异常；通过localhost:8180/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100触发流程，order本地创建订单调用，远程storage扣减库存，远程扣减账户余额时候模拟该超时异常。下面展示下异常情况下日志信息： OrderServerApplication日志展示了事务增强拦截器GlobalTransactionalInterceptor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970i.seata.tm.api.DefaultGlobalTransaction : Begin new global transaction [192.168.3.2:8091:2044579200] i.seata.sample.service.OrderServiceImpl : -------&gt;交易开始 i.seata.sample.service.OrderServiceImpl : -------&gt;扣减账户开始order中 i.s.core.rpc.netty.RmMessageListener : onMessage:xid=192.168.3.2:8091:2044579200,branchId=2044579202,branchType=AT,resourceId=jdbc:mysql://127.0.0.1/seat-order,applicationData=null io.seata.rm.AbstractRMHandler : Branch Rollbacking: 192.168.3.2:8091:2044579200 2044579202 jdbc:mysql://127.0.0.1/seat-order i.s.r.d.undo.AbstractUndoLogManager : xid 192.168.3.2:8091:2044579200 branch 2044579202, undo_log deleted with GlobalFinished io.seata.rm.AbstractRMHandler : Branch Rollbacked result: PhaseTwo_Rollbacked i.seata.tm.api.DefaultGlobalTransaction : [192.168.3.2:8091:2044579200] rollback status: Rollbacked o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is feign.RetryableException: Read timed out executing GET http://account-server/account/decrease?userId=1&amp;money=100] with root causejava.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) ~[na:1.8.0_231] at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) ~[na:1.8.0_231] at java.net.SocketInputStream.read(SocketInputStream.java:171) ~[na:1.8.0_231] at java.net.SocketInputStream.read(SocketInputStream.java:141) ~[na:1.8.0_231] at java.io.BufferedInputStream.fill(BufferedInputStream.java:246) ~[na:1.8.0_231] at java.io.BufferedInputStream.read1(BufferedInputStream.java:286) ~[na:1.8.0_231] at java.io.BufferedInputStream.read(BufferedInputStream.java:345) ~[na:1.8.0_231] at sun.net.www.http.HttpClient.parseHTTPHeader(HttpClient.java:735) ~[na:1.8.0_231] at sun.net.www.http.HttpClient.parseHTTP(HttpClient.java:678) ~[na:1.8.0_231] at sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1593) ~[na:1.8.0_231] at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1498) ~[na:1.8.0_231] at java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:480) ~[na:1.8.0_231] at feign.Client$Default.convertResponse(Client.java:143) ~[feign-core-10.2.3.jar:na] at feign.Client$Default.execute(Client.java:68) ~[feign-core-10.2.3.jar:na] at com.alibaba.cloud.seata.feign.SeataFeignClient.execute(SeataFeignClient.java:57) ~[spring-cloud-alibaba-seata-2.1.0.RELEASE.jar:2.1.0.RELEASE] at org.springframework.cloud.openfeign.ribbon.FeignLoadBalancer.execute(FeignLoadBalancer.java:93) ~[spring-cloud-openfeign-core-2.1.2.RELEASE.jar:2.1.2.RELEASE] at org.springframework.cloud.openfeign.ribbon.FeignLoadBalancer.execute(FeignLoadBalancer.java:56) ~[spring-cloud-openfeign-core-2.1.2.RELEASE.jar:2.1.2.RELEASE] at com.netflix.client.AbstractLoadBalancerAwareClient$1.call(AbstractLoadBalancerAwareClient.java:104) ~[ribbon-loadbalancer-2.3.0.jar:2.3.0] at com.netflix.loadbalancer.reactive.LoadBalancerCommand$3$1.call(LoadBalancerCommand.java:303) ~[ribbon-loadbalancer-2.3.0.jar:2.3.0] at com.netflix.loadbalancer.reactive.LoadBalancerCommand$3$1.call(LoadBalancerCommand.java:287) ~[ribbon-loadbalancer-2.3.0.jar:2.3.0] at rx.internal.util.ScalarSynchronousObservable$3.call(ScalarSynchronousObservable.java:231) ~[rxjava-1.3.8.jar:1.3.8] at rx.internal.util.ScalarSynchronousObservable$3.call(ScalarSynchronousObservable.java:228) ~[rxjava-1.3.8.jar:1.3.8] at rx.Observable.unsafeSubscribe(Observable.java:10327) ~[rxjava-1.3.8.jar:1.3.8] at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286) ~[rxjava-1.3.8.jar:1.3.8] at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.onNext(OnSubscribeConcatMap.java:144) ~[rxjava-1.3.8.jar:1.3.8] at com.netflix.loadbalancer.reactive.LoadBalancerCommand$1.call(LoadBalancerCommand.java:185) ~[ribbon-loadbalancer-2.3.0.jar:2.3.0] at com.netflix.loadbalancer.reactive.LoadBalancerCommand$1.call(LoadBalancerCommand.java:180) ~[ribbon-loadbalancer-2.3.0.jar:2.3.0] at rx.Observable.unsafeSubscribe(Observable.java:10327) ~[rxjava-1.3.8.jar:1.3.8] at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:94) ~[rxjava-1.3.8.jar:1.3.8] at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:42) ~[rxjava-1.3.8.jar:1.3.8] at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) ~[rxjava-1.3.8.jar:1.3.8] at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) ~[rxjava-1.3.8.jar:1.3.8] at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) ~[rxjava-1.3.8.jar:1.3.8] at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) ~[rxjava-1.3.8.jar:1.3.8] at rx.Observable.subscribe(Observable.java:10423) ~[rxjava-1.3.8.jar:1.3.8] at rx.Observable.subscribe(Observable.java:10390) ~[rxjava-1.3.8.jar:1.3.8] at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:443) ~[rxjava-1.3.8.jar:1.3.8] at rx.observables.BlockingObservable.single(BlockingObservable.java:340) ~[rxjava-1.3.8.jar:1.3.8] at com.netflix.client.AbstractLoadBalancerAwareClient.executeWithLoadBalancer(AbstractLoadBalancerAwareClient.java:112) ~[ribbon-loadbalancer-2.3.0.jar:2.3.0] at org.springframework.cloud.openfeign.ribbon.LoadBalancerFeignClient.execute(LoadBalancerFeignClient.java:83) ~[spring-cloud-openfeign-core-2.1.2.RELEASE.jar:2.1.2.RELEASE] at com.alibaba.cloud.seata.feign.SeataLoadBalancerFeignClient.execute(SeataLoadBalancerFeignClient.java:56) ~[spring-cloud-alibaba-seata-2.1.0.RELEASE.jar:2.1.0.RELEASE] at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:108) ~[feign-core-10.2.3.jar:na] at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:78) ~[feign-core-10.2.3.jar:na] at feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:103) ~[feign-core-10.2.3.jar:na] at com.sun.proxy.$Proxy111.decrease(Unknown Source) ~[na:na] at io.seata.sample.service.OrderServiceImpl.create(OrderServiceImpl.java:50) ~[classes/:na] at io.seata.sample.service.OrderServiceImpl$$FastClassBySpringCGLIB$$3d2d368a.invoke(&lt;generated&gt;) ~[classes/:na] at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.1.9.RELEASE.jar:5.1.9.RELEASE] at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) ~[spring-aop-5.1.9.RELEASE.jar:5.1.9.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.1.9.RELEASE.jar:5.1.9.RELEASE] at io.seata.spring.annotation.GlobalTransactionalInterceptor$1.execute(GlobalTransactionalInterceptor.java:109) ~[seata-all-1.2.0.jar:1.2.0] at io.seata.tm.api.TransactionalTemplate.execute(TransactionalTemplate.java:104) ~[seata-all-1.2.0.jar:1.2.0] at io.seata.spring.annotation.GlobalTransactionalInterceptor.handleGlobalTransaction(GlobalTransactionalInterceptor.java:106) ~[seata-all-1.2.0.jar:1.2.0] at io.seata.spring.annotation.GlobalTransactionalInterceptor.invoke(GlobalTransactionalInterceptor.java:83) ~[seata-all-1.2.0.jar:1.2.0] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.9.RELEASE.jar:5.1.9.RELEASE] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.1.9.RELEASE.jar:5.1.9.RELEASE] at io.seata.sample.service.OrderServiceImpl$$EnhancerBySpringCGLIB$$9c1f4d2e.create(&lt;generated&gt;) ~[classes/:na] at io.seata.sample.controller.OrderController.create(OrderController.java:29) ~[classes/:na]........省略异常 StorageServerApplication日志展示事务分支Branch Rollbacked123456i.s.sample.service.StorageServiceImpl : -------&gt;扣减库存开始i.s.sample.service.StorageServiceImpl : -------&gt;扣减库存结束c.a.c.seata.web.SeataHandlerInterceptor : xid in change during RPC from 192.168.3.2:8091:2044579200 to nulli.s.core.rpc.netty.RmMessageListener : onMessage:xid=192.168.3.2:8091:2044579200,branchId=2044579204,branchType=AT,resourceId=jdbc:mysql://127.0.0.1/seat-storage,applicationData=nullio.seata.rm.AbstractRMHandler : Branch Rollbacking: 192.168.3.2:8091:2044579200 2044579204 jdbc:mysql://127.0.0.1/seat-storagei.s.r.d.undo.AbstractUndoLogManager : xid 192.168.3.2:8091:2044579200 branch 2044579204, undo_log deleted with GlobalFinished : Branch Rollbacked result: PhaseTwo_Rollbacked AccountServerApplication日志出现sql exception1234567891011121314i.s.sample.service.AccountServiceImpl : -------&gt;扣减账户开始account中i.s.r.d.exec.AbstractDMLBaseExecutor : execute executeAutoCommitTrue error:io.seata.core.exception.RmTransactionException: Response[ TransactionException[192.168.3.2:8091:2044579200] ]java.sql.SQLException: io.seata.core.exception.RmTransactionException: Response[ TransactionException[192.168.3.2:8091:2044579200] ]...省略一些重要异常堆栈信息2020-05-30 23:31:56.652 WARN 5960 --- [nio-8181-exec-2] c.a.c.seata.web.SeataHandlerInterceptor : xid in change during RPC from 192.168.3.2:8091:2044579200 to null2020-05-30 23:31:56.654 ERROR 5960 --- [nio-8181-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.jdbc.UncategorizedSQLException: ### Error updating database. Cause: java.sql.SQLException: io.seata.core.exception.RmTransactionException: Response[ TransactionException[192.168.3.2:8091:2044579200] ]### The error may exist in file [E:\\document\\GitHub\\seata-samples-master\\springcloud-eureka-feign-mybatis-seata\\account-server\\target\\classes\\mapper\\AccountMapper.xml]### The error may involve defaultParameterMap### The error occurred while setting parameters### SQL: UPDATE account SET residue = residue - ?,used = used + ? where user_id = ?;### Cause: java.sql.SQLException: io.seata.core.exception.RmTransactionException: Response[ TransactionException[192.168.3.2:8091:2044579200] ]; uncategorized SQLException; SQL state [null]; error code [0]; io.seata.core.exception.RmTransactionException: Response[ TransactionException[192.168.3.2:8091:2044579200] ]; nested exception is java.sql.SQLException: io.seata.core.exception.RmTransactionException: Response[ TransactionException[192.168.3.2:8091:2044579200] ]] with root cause 四、分布式事务公共模块1、创建工程common_fescar，引入依赖123456789101112131415&lt;properties&gt; &lt;fescar.version&gt;0.4.2&lt;/fescar.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.fescar&lt;/groupId&gt; &lt;artifactId&gt;fescar-tm&lt;/artifactId&gt; &lt;version&gt;$&#123;fescar.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.fescar&lt;/groupId&gt; &lt;artifactId&gt;fescar-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;fescar.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、将fescar配置文件拷贝到resources工程下 3、资源提供者每个线程绑定一个XID123456789101112131415161718192021222324252627282930313233public class FescarRMRequestFilter extends OncePerRequestFilter &#123; private static final Logger LOGGER = org.slf4j.LoggerFactory.getLogger( FescarRMRequestFilter.class); /** * 给每次线程请求绑定一个XID * @param request * @param response * @param filterChain */ @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; String currentXID = request.getHeader( FescarAutoConfiguration.FESCAR_XID); if(!StringUtils.isEmpty(currentXID))&#123; RootContext.bind(currentXID); LOGGER.info(\"当前线程绑定的XID :\" + currentXID); &#125; try&#123; filterChain.doFilter(request, response); &#125; finally &#123; String unbindXID = RootContext.unbind(); if(unbindXID != null)&#123; LOGGER.info(\"当前线程从指定XID中解绑 XID :\" + unbindXID); if(!currentXID.equals(unbindXID))&#123; LOGGER.info(\"当前线程的XID发生变更\"); &#125; &#125; if(currentXID != null)&#123; LOGGER.info(\"当前线程的XID发生变更\"); &#125; &#125; &#125;&#125; 4、RestInterceptor过滤器，每次请求都将XID转发到其他微服务1234567891011121314151617181920public class FescarRestInterceptor implements RequestInterceptor, ClientHttpRequestInterceptor &#123; @Override public void apply(RequestTemplate requestTemplate) &#123; String xid = RootContext.getXID(); if(!StringUtils.isEmpty(xid))&#123; requestTemplate.header( FescarAutoConfiguration.FESCAR_XID, xid); &#125; &#125; @Override public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException &#123; String xid = RootContext.getXID(); if(!StringUtils.isEmpty(xid))&#123; HttpHeaders headers = request.getHeaders(); headers.put( FescarAutoConfiguration.FESCAR_XID, Collections.singletonList(xid)); &#125; return execution.execute(request, body); &#125;&#125; 5、创建FescarAutoConfiguration类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * * 创建数据源 * * 定义全局事务管理器扫描对象 * * 给所有RestTemplate添加头信息防止微服务之间调用问题 */@Configurationpublic class FescarAutoConfiguration &#123; public static final String FESCAR_XID = \"fescarXID\"; /*** * 创建代理数据库 * @param environment * @return */ @Bean public DataSource dataSource(Environment environment)&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(environment.getProperty(\"spring.datasource.url\")); try &#123; dataSource.setDriver(DriverManager.getDriver(environment.getProperty(\"spring.datasource.url\"))); &#125; catch (SQLException e) &#123; throw new RuntimeException(\"can't recognize dataSource Driver\"); &#125; dataSource.setUsername(environment.getProperty(\"spring.datasource.username\")); dataSource.setPassword(environment.getProperty(\"spring.datasource.password\")); return new DataSourceProxy(dataSource); &#125; /*** * 全局事务扫描器 * 用来解析带有@GlobalTransactional注解的方法，然后采用AOP的机制控制事务 * @param environment * @return */ @Bean public GlobalTransactionScanner globalTransactionScanner(Environment environment)&#123; String applicationName = environment.getProperty(\"spring.application.name\"); String groupName = environment.getProperty(\"fescar.group.name\"); if(applicationName == null)&#123; return new GlobalTransactionScanner(groupName == null ? \"my_test_tx_group\" : groupName); &#125;else&#123; return new GlobalTransactionScanner(applicationName, groupName == null ? \"my_test_tx_group\" : groupName); &#125; &#125; /*** * 每次微服务和微服务之间相互调用 * 要想控制全局事务，每次TM都会请求TC生成一个XID，每次执行下一个事务，也就是调用其他微服务的时候都需要将该XID传递过去 * 所以我们可以每次请求的时候，都获取头中的XID，并将XID传递到下一个微服务 * @param restTemplates * @return */ @ConditionalOnBean(&#123;RestTemplate.class&#125;) @Bean public Object addFescarInterceptor(Collection&lt;RestTemplate&gt; restTemplates)&#123; restTemplates.stream() .forEach(restTemplate -&gt; &#123; List&lt;ClientHttpRequestInterceptor&gt; interceptors = restTemplate.getInterceptors(); if(interceptors != null)&#123; interceptors.add(fescarRestInterceptor()); &#125; &#125;); return new Object(); &#125; @Bean public FescarRMRequestFilter fescarRMRequestFilter()&#123; return new FescarRMRequestFilter(); &#125; @Bean public FescarRestInterceptor fescarRestInterceptor()&#123; return new FescarRestInterceptor(); &#125;&#125; 6、记得将涉及到分布式事务的每个数据库都新建一个Undolog表五、参考资料 官方实验Demo集合 本次博客实验所用Demo 分布式事务框架Fescar在SpringCloud环境下的应用实践","tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochikai.github.io/tags/SpringCloud/"}]},{"title":"TX-LCN分布式事务实践","date":"2020-05-30T10:11:00.000Z","path":"2020/05/30/TX-LCN分布式事务实践/","text":"TX-LCN分布式事务实践一、需求 扣减库存服务和生成订单服务对应不同数据库，Spring本地事务@Transactional并不能解决跨库跨服务保证数据一致性。分布式事务一般包含事务的发起者和参与者、关系型数据库资源服务以及事务管理器；Distributed Transaction Framework流行的主要有TX-LCN和阿里的seata框架，下一篇会调研下seata框架。 TX-LCN分布式事务框架是一款开源分布式事务框架，由两大模块组成TxClient和TxManager，TxClient扮演发起者和参与者，TxManager扮演事务管理器协调事务；从开发角度讲，TxClient指的是是我们自己的服务系统，TxManager是事务中心的协调系统；从Github RELEASE版本发布看，最新是5.0.2.RELEASE（支持LCN TXC TCC 三种事务模式），项目为了稳定使用v4.1.0（默认只支持LCN模式）；LCN模式基本原理是代理切面拦截所有数据库链接的提交和回滚，由代理连接对象控制本地事务的真正的提交、回滚和释放。若是存在与非关系型数据库redis，就需要TCC模式补偿操作，来保证非关系redis和关系mysql整体一致性。 二、开始准备1、准备mysql和redis环境，通过spring initializr快速准备eureka注册中心。2、下载v4.1.0版本，tx-lcn-4.1.0是spring boot项目需要eureka注册中心服务和redis，运行启动类com.codingapi.tm.TxManagerApplication。3、访问http://127.0.0.1:8899/TxManager管理界面，注意两个属性负载均衡服务器地址的端口和当前连接数，这是实验成功的截图，一开始当前连接数应该是0。 upload successful 4、springcloud LCN分布式事务v4.0 示例demo 根据教程引导创建相应的数据库和修改配置，重点标注重要配置。我们重点关系jdbc版本的springcloud-jdbc-demo，它涉及到了5个业务模块，工程从1到5对应端口port：8081到8085，控制器的接口前缀是localhost:port/demo，分list列表接口和save接口；在save方法中，在demo3（调用4和5，自己）和demo1（调用2和3，自己）是事务发起方，两者差别是demo3注释了异常能正常返回insert 3条数据，而demo1打开异常触发分布式事务回滚insert数据；demo2、demo4和demo5仅仅是事务参与方。 12345678910111213141516171819202122232425262728feign.hystrix.enabled=falsespring.datasource.driver-class-name = com.mysql.jdbc.Driverspring.datasource.url= jdbc:mysql://localhost:3306/testspring.datasource.username= rootspring.datasource.password=rootspring.datasource.initialize = trueinit-db= truespring.application.name = demo3server.port = 8083#$&#123;random.int[9000,9999]&#125;，注册中心端口要对应eureka.client.service-url.defaultZone=http://127.0.0.1:8761/eureka/feign.hystrix.enabled=true# 关于**springcloud-hystrix机制，选择信号量隔离** http://www.jianshu.com/p/b8d21248c9b1hystrix.command.default.execution.isolation.strategy= SEMAPHOREhystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=5000#Ribbon的负载均衡策略，重试次数为0ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RandomRuleribbon.MaxAutoRetriesNextServer=0#**txmanager地址端口指的是TxManager管理界面的负载均衡服务器地址的端口**tm.manager.url=http://127.0.0.1:8899/tx/manager/logging.level.com.codingapi=debug 以demo1的DemoServiceImpl异常触发分布式为例，重点是@TxTransaction(isStart = true)标注事务发起方，否则ThreadLocal不会有groupid，那就不会有事务组，更不可能实现回滚事务。 未标记发起方出现异常则groupId为空情况：12342020-05-30 17:30:06.387 DEBUG 4964 --- [nio-8084-exec-8] c.c.t.s.interceptor.TransactionAspect : annotation-TransactionRunning-start----&gt;2020-05-30 17:30:06.387 DEBUG 4964 --- [nio-8084-exec-8] c.c.t.a.s.impl.AspectBeforeServiceImpl : around--&gt; groupId-&gt; null,txTransactionLocal-&gt;null2020-05-30 17:30:06.387 DEBUG 4964 --- [nio-8084-exec-8] c.c.t.d.aspect.DataSourceAspect : getConnection-start----&gt;2020-05-30 17:30:06.387 DEBUG 4964 --- [nio-8084-exec-8] c.c.tx.datasource.AbstractResourceProxy : loadConnection -&gt; null ! DemoServiceImpl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.example.demo.service.impl;import com.example.demo.client.Demo2Client;import com.example.demo.client.Demo3Client;import com.example.demo.dao.TestDao;import com.example.demo.entity.Test;import com.example.demo.service.DemoService;import com.codingapi.tx.annotation.TxTransaction;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * Created by lorne on 2017/6/26. */@Servicepublic class DemoServiceImpl implements DemoService &#123; @Autowired private TestDao testDao; @Autowired private Demo2Client demo2Client; @Autowired private Demo3Client demo3Client; @Override public List&lt;Test&gt; list() &#123; return testDao.list(); &#125; @Override **@TxTransaction(isStart = true)** @Transactional public int save() &#123; int rs2 = demo2Client.save(); int rs3 = demo3Client.save(); int rs1 = testDao.save(); int v = 100/0; return rs1+rs2+rs3; &#125;&#125; 访问demo1的save接口1234567//访问save接口：http://localhost:8081/demo/save，触发异常Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Sat May 30 17:33:11 CST 2020There was an unexpected error (type=Internal Server Error, status=500).Demo3Client#save() failed and fallback failed. 触发回滚JdbcDemo2Application控制台正确日志：123456789101112#触发回滚2020-05-30 17:33:11.654 DEBUG 4468 --- [ntLoopGroup-2-1] c.c.tx.netty.handler.TransactionHandler : TxManager-response-&gt;&#123;\"a\":\"t\",\"c\":0,\"t\":\"9Fxhh19M\",\"k\":\"62kQVGPh\"&#125;2020-05-30 17:33:11.654 INFO 4468 --- [ool-1-thread-19] c.c.t.c.service.impl.ActionTServiceImpl : accept notify data -&gt;&#123;\"a\":\"t\",\"c\":0,\"t\":\"9Fxhh19M\",\"k\":\"62kQVGPh\"&#125;lcn transaction over, res -&gt; groupId:3OBwlhvN and state is rollback2020-05-30 17:33:11.657 DEBUG 4468 --- [ Thread-28] c.c.t.d.relational.LCNDBConnection : lcnConnection closed groupId:3OBwlhvN2020-05-30 17:33:11.658 INFO 4468 --- [ool-1-thread-19] c.c.t.c.service.impl.ActionTServiceImpl : accept notify response res -&gt;12020-05-30 17:33:11.658 DEBUG 4468 --- [ool-1-thread-19] .c.t.c.s.i.TransactionControlServiceImpl : send notify data -&gt;&#123;\"p\":&#123;\"d\":\"1\"&#125;,\"a\":\"t\",\"k\":\"62kQVGPh\"&#125;2020-05-30 17:33:11.659 DEBUG 4468 --- [ntLoopGroup-2-1] c.c.tx.netty.handler.TransactionHandler : TxManager-response-&gt;&#123;\"d\":\"\",\"k\":\"62kQVGPh\"&#125;#clent和manager的心跳数据2020-05-30 17:33:26.659 DEBUG 4468 --- [ntLoopGroup-2-1] c.c.tx.netty.handler.TransactionHandler : hart data ---&gt;&#123;\"p\":\"&#123;&#125;\",\"a\":\"h\",\"k\":\"h\"&#125;2020-05-30 17:33:26.659 DEBUG 4468 --- [ntLoopGroup-2-1] c.c.tx.netty.handler.TransactionHandler : TxManager-response-&gt;&#123;\"d\":\"5\",\"k\":\"h\"&#125; 三、4.0与5.0版本差别 5.0版本从1月份开始大量提交，并已经交由codingApi团队开发维护，两个版本的注解源码是不同的。 12345678910111213141516171819202122232425262728/** **4.0版本** * Created by lorne on 2017/6/26. */@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface TxTransaction &#123; /** * 是否LCN事务发起方 * @return true 是:是发起方 false 否:是参与方 */ boolean isStart() default false; /** * 回滚异常 * @return */ Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;; /** * 不回滚异常 * @return */ Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;&#125; 12345678910111213141516171819202122232425/****5.0版本** * Created by lorne on 2017/6/26. */@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface TxTransaction &#123; /** * 事务模式 transaction type * * @return lcn, tcc, txc * @see Transactions */ String type() default Transactions.LCN; /** * 分布式事务传播行为 * * @return 传播行为 * @see DTXPropagation */ DTXPropagation propagation() default DTXPropagation.REQUIRED;&#125; 四、参考资料 分布式事务从0到1-认识分布式事务 codingapi/tx-lcn springcloud LCN分布式事务v4.0 示例demo","tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochikai.github.io/tags/SpringCloud/"}]},{"title":"SpringBoot canal数据同步解决方案","date":"2020-05-28T14:31:00.000Z","path":"2020/05/28/SpringBoot-canal数据同步解决方案/","text":"SpringBoot canal数据同步解决方案一、需求 微服务多数据库情况下可以使用canal替代触发器，canal是应阿里巴巴跨机房同步的业务需求而提出的，canal基于数据库的日志解析，获取变更进行增量订阅&amp;消费的业务。无论是canal实验需要还是为了增量备份、主从复制和恢复，都是需要开启mysql-binlog日志，数据目录设置到不同的磁盘分区可以降低io等待。 canal 工作原理 canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议 MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal ) canal 解析 binary log 对象(原始为 byte 流) 二、部署环境1、登录mysql查看是否开启binlog，标红的log_bin默认是OFF关12345678910111213141516171819202122232425mysql&gt; show variables like 'log_%';+----------------------------------------+-------------------------------------------------------+| Variable_name | Value |+----------------------------------------+-------------------------------------------------------+| **log_bin | OFF** || log_bin_basename | || log_bin_index | || log_bin_trust_function_creators | OFF || log_bin_use_v1_row_events | OFF || log_builtin_as_identified_by_password | OFF || log_error | F:\\tools\\mysql-5.7.28-winx64\\Data\\DESKTOP-C1LU9IQ.err || log_error_verbosity | 3 || log_output | FILE || log_queries_not_using_indexes | OFF || log_slave_updates | OFF || log_slow_admin_statements | OFF || log_slow_slave_statements | OFF || log_statements_unsafe_for_binlog | ON || log_syslog | ON || log_syslog_tag | || log_throttle_queries_not_using_indexes | 0 || log_timestamps | UTC || log_warnings | 2 |+----------------------------------------+-------------------------------------------------------+19 rows in set (0.03 sec) 2、编辑配置文件1234567891011121314151617181920212223242526272829303132333435[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录，按照个人的实际需要改basedir=F:\\\\tools\\\\mysql-5.7.28-winx64 # 切记此处一定要用双斜杠\\\\，单斜杠我这里会出错，不过看别人的教程，有的是单斜杠。自己尝试吧# 设置mysql数据库的数据的存放目录datadir=F:\\\\tools\\\\mysql-5.7.28-winx64\\\\Data # 此处同上# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_passwordlower_case_table_names=2sql_mode = STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTIONmax_connections=1000#实验重点配置 # 开启 binloglog-bin=mysql-bin# 选择 ROW 模式binlog-format=ROW # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复server_id=1 [mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 3、创建MySQL slave 的权限canal账户并且进行远程连接授权1234CREATE USER canal IDENTIFIED BY 'canal'; GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%';-- GRANT ALL PRIVILEGES ON *.* TO 'canal'@'%' ;FLUSH PRIVILEGES; 4、记得重启mysql服务12345Linux：systemctl restart mysqldWindow:net stop mysql;net start mysql; 三、canal快速部署配置1、修改配置conf/example/instance.properties123456789101112131415161718## mysql serverIdcanal.instance.mysql.slaveId = 1234#position info，需要改成自己的数据库信息canal.instance.master.address = 127.0.0.1:3306 canal.instance.master.journal.name = canal.instance.master.position = canal.instance.master.timestamp = #canal.instance.standby.address = #canal.instance.standby.journal.name =#canal.instance.standby.position = #canal.instance.standby.timestamp = #username/password，需要改成自己的数据库信息canal.instance.dbUsername = canal canal.instance.dbPassword = canalcanal.instance.defaultDatabaseName =canal.instance.connectionCharset = UTF-8#table regexcanal.instance.filter.regex = .\\*\\\\\\\\..\\* 2、通过启动脚本运行：sh bin/startup.sh3、查看 server 日志和instance 的日志1234567891011121314151617$ tail -f logs/canal/canal.log2020-05-28 13:52:03.037 [main] INFO com.alibaba.otter.canal.deployer.CanalLauncher - ## set default uncaught exception handler2020-05-28 13:52:03.065 [main] INFO com.alibaba.otter.canal.deployer.CanalLauncher - ## load canal configurations2020-05-28 13:52:03.072 [main] INFO com.alibaba.otter.canal.deployer.CanalStarter - ## start the canal server.2020-05-28 13:52:03.444 [main] INFO com.alibaba.otter.canal.deployer.CanalController - ## start the canal server[172.36.58.25(172.36.58.25):11111]2020-05-28 13:52:04.604 [main] INFO com.alibaba.otter.canal.deployer.CanalStarter - ## the canal server is running now ......$ tail -f logs/example/example.log2020-05-28 13:52:04.238 [main] WARN o.s.beans.GenericTypeAwarePropertyDescriptor - Invalid JavaBean property 'connectionCharset' being accessed! Ambiguous write methods found next to actually used [public void com.alibaba.otter.canal.parse.inbound.mysql.AbstractMysqlEventParser.setConnectionCharset(java.lang.String)]: [public void com.alibaba.otter.canal.parse.inbound.mysql.AbstractMysqlEventParser.setConnectionCharset(java.nio.charset.Charset)]2020-05-28 13:52:04.264 [main] INFO c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [canal.properties]2020-05-28 13:52:04.265 [main] INFO c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [example/instance.properties]2020-05-28 13:52:04.568 [main] INFO c.a.otter.canal.instance.spring.CanalInstanceWithSpring - start CannalInstance for 1-example2020-05-28 13:52:04.572 [main] WARN c.a.o.canal.parse.inbound.mysql.dbsync.LogEventConvert - --&gt; init table filter : ^.*\\..*$2020-05-28 13:52:04.573 [main] WARN c.a.o.canal.parse.inbound.mysql.dbsync.LogEventConvert - --&gt; init table black filter :2020-05-28 13:52:04.577 [main] INFO c.a.otter.canal.instance.core.AbstractCanalInstance - start successful....2020-05-28 13:52:04.616 [destination = example , address = /127.0.0.1:3306 , EventParser] WARN c.a.o.c.p.inbound.mysql.rds.RdsBinlogEventParserProxy - ---&gt; begin to find start position, it will be long time for reset or first position2020-05-28 13:52:04.616 [destination = example , address = /127.0.0.1:3306 , EventParser] WARN c.a.o.c.p.inbound.mysql.rds.RdsBinlogEventParserProxy - prepare to find start position just show master status2020-05-28 13:52:06.556 [destination = example , address = /127.0.0.1:3306 , EventParser] WARN c.a.o.c.p.inbound.mysql.rds.RdsBinlogEventParserProxy - ---&gt; find start position successfully, EntryPosition[included=false,journalName=mysql-bin.000001,position=4,serverId=1,gtid=&lt;null&gt;,timestamp=1590644973000] cost : 1935ms , the next step is binlog dump 四、初步监听实验12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.net.InetSocketAddress;import java.util.List;import com.alibaba.otter.canal.client.CanalConnectors;import com.alibaba.otter.canal.client.CanalConnector;import com.alibaba.otter.canal.common.utils.AddressUtils;import com.alibaba.otter.canal.protocol.Message;import com.alibaba.otter.canal.protocol.CanalEntry.Column;import com.alibaba.otter.canal.protocol.CanalEntry.Entry;import com.alibaba.otter.canal.protocol.CanalEntry.EntryType;import com.alibaba.otter.canal.protocol.CanalEntry.EventType;import com.alibaba.otter.canal.protocol.CanalEntry.RowChange;import com.alibaba.otter.canal.protocol.CanalEntry.RowData;public class SimpleCanalClientExample &#123; public static void main(String args[]) &#123; // 创建链接 CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(AddressUtils.getHostIp(), 11111), \"example\", \"\", \"\"); int batchSize = 1000; int emptyCount = 0; try &#123; connector.connect(); connector.subscribe(\".*\\\\..*\"); connector.rollback(); int totalEmptyCount = 120; while (emptyCount &lt; totalEmptyCount) &#123; Message message = connector.getWithoutAck(batchSize); // 获取指定数量的数据 long batchId = message.getId(); int size = message.getEntries().size(); if (batchId == -1 || size == 0) &#123; emptyCount++; System.out.println(\"empty count : \" + emptyCount); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; &#125; else &#123; emptyCount = 0; // System.out.printf(\"message[batchId=%s,size=%s] \\n\", batchId, size); printEntry(message.getEntries()); &#125; connector.ack(batchId); // 提交确认 // connector.rollback(batchId); // 处理失败, 回滚数据 &#125; System.out.println(\"empty too many times, exit\"); &#125; finally &#123; connector.disconnect(); &#125; &#125; private static void printEntry(List&lt;Entry&gt; entrys) &#123; for (Entry entry : entrys) &#123; if (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123; continue; &#125; RowChange rowChage = null; try &#123; rowChage = RowChange.parseFrom(entry.getStoreValue()); &#125; catch (Exception e) &#123; throw new RuntimeException(\"ERROR ## parser of eromanga-event has an error , data:\" + entry.toString(), e); &#125; EventType eventType = rowChage.getEventType(); System.out.println(String.format(\"================&amp;gt; binlog[%s:%s] , name[%s,%s] , eventType : %s\", entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(), entry.getHeader().getSchemaName(), entry.getHeader().getTableName(), eventType)); for (RowData rowData : rowChage.getRowDatasList()) &#123; if (eventType == EventType.DELETE) &#123; printColumn(rowData.getBeforeColumnsList()); &#125; else if (eventType == EventType.INSERT) &#123; printColumn(rowData.getAfterColumnsList()); &#125; else &#123; System.out.println(\"-------&amp;gt; before\"); printColumn(rowData.getBeforeColumnsList()); System.out.println(\"-------&amp;gt; after\"); printColumn(rowData.getAfterColumnsList()); &#125; &#125; &#125; &#125; private static void printColumn(List&lt;Column&gt; columns) &#123; for (Column column : columns) &#123; System.out.println(column.getName() + \" : \" + column.getValue() + \" update=\" + column.getUpdated()); &#125; &#125;&#125; 随便插入数据触发1INSERT INTO `demo`.`tb_ad`(`id`, `url`, `status`, `position`, `image`, `start_time`, `end_time`) VALUES (1, 'https://www.baidu.com/', '1', 'web_index_lb', 'https://pics1.baidu.com/feed/c83d70cf3bc79f3d5c30d358deb67a17738b29a6.jpeg?https://kins.oss-cn-shenzhen.aliyuncs.com/yhzb/2020-03-11/ca21b3b17d6f4757b991dd86b8cef3fa-VIP-680.jpeg', '2020-05-22 10:58:08', '2021-06-01 10:58:14'); 从控制台中看到12345678910111213empty count : 66empty count : 67empty count : 68empty count : 69empty count : 70================&amp;gt; binlog[mysql-bin.000001:355] , name[demo,tb_ad] , eventType : INSERTid : 2 update=trueurl : https://www.baidu.com/ update=truestatus : 1 update=trueposition : web_index_lb update=trueimage : https://pics1.baidu.com/feed/c83d70cf3bc79f3d5c30d358deb67a17738b29a6.jpeg?https://kins.oss-cn-shenzhen.aliyuncs.com/yhzb/2020-03-11/ca21b3b17d6f4757b991dd86b8cef3fa-VIP-680.jpeg update=truestart_time : 2020-05-22 10:58:08 update=trueend_time : 2021-06-01 10:58:14 update=true 五、数据监控微服务1234567&lt;!-- 第三方starter快速整合canal https://github.com/NormanGyllenhaal/canal-client--&gt;&lt;!-- https://mvnrepository.com/artifact/top.javatool/canal-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;top.javatool&lt;/groupId&gt; &lt;artifactId&gt;canal-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.1-RELEASE&lt;/version&gt;&lt;/dependency&gt; 订阅数据库的增删改操作12345678910111213141516171819202122232425import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import top.javatool.canal.client.annotation.CanalTable;import top.javatool.canal.client.handler.EntryHandler;@Component@CanalTable(value = \"t_user\")public class UserHandler implements EntryHandler&lt;User&gt; &#123; private Logger logger = LoggerFactory.getLogger(UserHandler.class); public void insert(User user) &#123; logger.info(\"insert message &#123;&#125;\", user); &#125; public void update(User before, User after) &#123; logger.info(\"update before &#123;&#125; \", before); logger.info(\"update after &#123;&#125;\", after); &#125; public void delete(User user) &#123; logger.info(\"delete &#123;&#125;\", user); &#125;&#125; 启动数据监控微服务，修改user表，观察控制台输出。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849502020-05-28 16:23:22.667 INFO 24284 --- [l-client-thread] t.j.c.client.client.AbstractCanalClient : 获取消息 Message[id=23,entries=[header &#123; version: 1 logfileName: \"mysql-bin.000001\" logfileOffset: 18380 serverId: 1 serverenCode: \"UTF-8\" executeTime: 1590654201000 sourceType: MYSQL schemaName: \"\" tableName: \"\" eventLength: 68&#125;entryType: TRANSACTIONBEGINstoreValue: \" \\025\", header &#123; version: 1 logfileName: \"mysql-bin.000001\" logfileOffset: 18505 serverId: 1 serverenCode: \"UTF-8\" executeTime: 1590654201000 sourceType: MYSQL schemaName: \"demo\" tableName: \"t_user\" eventLength: 88 eventType: UPDATE props &#123; key: \"rowsCount\" value: \"1\" &#125;&#125;entryType: ROWDATAstoreValue: \"\\b\\210\\002\\020\\002P\\000b\\370\\003\\n\\033\\b\\000\\020\\004\\032\\002id \\001(\\0000\\000B\\00221R\\aint(11)\\n*\\b\\001\\020\\f\\032\\tuser_name \\000(\\0000\\000B\\005ZeldaR\\fvarchar(255)\\n*\\b\\002\\020\\372\\377\\377\\377\\377\\377\\377\\377\\377\\001\\032\\006gender \\000(\\0000\\000B\\0010R\\ntinyint(4)\\n\\\"\\b\\003\\020\\004\\032\\ncountry_id \\000(\\0000\\000B\\0011R\\aint(11)\\n&amp;\\b\\004\\020[\\032\\bbirthday \\000(\\0000\\000B\\n1998-04-18R\\004date\\n7\\b\\005\\020]\\032\\vcreate_time \\000(\\0000\\000B\\0231991-01-10 05:45:50R\\ttimestamp\\022\\033\\b\\000\\020\\004\\032\\002id \\001(\\0000\\000B\\00221R\\aint(11)\\022.\\b\\001\\020\\f\\032\\tuser_name \\000(\\0010\\000B\\tZelda1111R\\fvarchar(255)\\022*\\b\\002\\020\\372\\377\\377\\377\\377\\377\\377\\377\\377\\001\\032\\006gender \\000(\\0000\\000B\\0010R\\ntinyint(4)\\022\\\"\\b\\003\\020\\004\\032\\ncountry_id \\000(\\0000\\000B\\0011R\\aint(11)\\022&amp;\\b\\004\\020[\\032\\bbirthday \\000(\\0000\\000B\\n1998-04-18R\\004date\\0227\\b\\005\\020]\\032\\vcreate_time \\000(\\0000\\000B\\0231991-01-10 05:45:50R\\ttimestamp\", header &#123; version: 1 logfileName: \"mysql-bin.000001\" logfileOffset: 18593 serverId: 1 serverenCode: \"UTF-8\" executeTime: 1590654201000 sourceType: MYSQL schemaName: \"\" tableName: \"\" eventLength: 31&#125;entryType: TRANSACTIONENDstoreValue: \"\\022\\0041574\"],raw=false,rawEntries=[]]2020-05-28 16:23:22.668 INFO 24284 --- [xecute-thread-6] t.j.canal.example.handler.UserHandler : update before User&#123;id=null, userName='Zelda', gender=null, countryId=null, birthday=null, createTime=null&#125; 2020-05-28 16:23:22.668 INFO 24284 --- [xecute-thread-6] t.j.canal.example.handler.UserHandler : update after User&#123;id=21, userName='Zelda1111', gender=0, countryId=1, birthday=Sat Apr 18 00:00:00 CST 1998, createTime=Thu Jan 10 05:45:50 CST 1991&#125;","tags":[{"name":"Springboot","slug":"Springboot","permalink":"https://caochikai.github.io/tags/Springboot/"}]},{"title":"Swagger关于令牌校验","date":"2020-05-27T14:56:00.000Z","path":"2020/05/27/Swagger关于令牌校验/","text":"Swagger关于令牌校验一、需求 微服务oauth2校验令牌，通过Swagger2的securitySchemes配置全局token参数，也可以创建一个默认测试用户默认启动时候登陆获取永久期限的令牌。 二、swagger配置实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Configuration@EnableSwagger2public class SwaggerConfig &#123; /** * 创建一个Docket对象 * 调用select()方法， * 生成ApiSelectorBuilder对象实例，该对象负责定义外漏的API入口 * 通过使用RequestHandlerSelectors和PathSelectors来提供Predicate，在此我们使用any()方法，将所有API都通过Swagger进行文档管理 * * @return */ @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.xxx\")) .paths(PathSelectors.any()) .build() .securitySchemes(securitySchemes()) .securityContexts(securityContexts()) .globalOperationParameters(globalOperationParameters()); &#125; private List&lt;Parameter&gt; globalOperationParameters()&#123; //添加默认head参数Authorization ParameterBuilder tokenPar = new ParameterBuilder(); List&lt;Parameter&gt; pars = new ArrayList&lt;Parameter&gt;(); tokenPar.name(\"Authorization\").defaultValue(\"Bearer \").description(\"令牌\").modelRef(new ModelRef(\"string\")).parameterType(\"header\").required(false).build(); pars.add(tokenPar.build()); return pars; &#125; private List&lt;ApiKey&gt; securitySchemes() &#123; List&lt;ApiKey&gt; apiKeyList = new ArrayList(); apiKeyList.add(new ApiKey(\"Authorization\", \"Authorization\", \"header\")); return apiKeyList; &#125; private List&lt;SecurityContext&gt; securityContexts() &#123; List&lt;SecurityContext&gt; securityContexts = new ArrayList&lt;&gt;();//通过PathSelectors.regex(\"^(?!auth).*$\")，排除包含\"auth\"的接口不需要使用securitySchemes securityContexts.add( SecurityContext.builder() .securityReferences(defaultAuth()) .forPaths(PathSelectors.regex(\"^(?!auth).*$\")) .build()); return securityContexts; &#125; List&lt;SecurityReference&gt; defaultAuth() &#123; AuthorizationScope authorizationScope = new AuthorizationScope(\"global\", \"accessEverything\"); AuthorizationScope[] authorizationScopes = new AuthorizationScope[1]; authorizationScopes[0] = authorizationScope; List&lt;SecurityReference&gt; securityReferences = new ArrayList&lt;&gt;(); securityReferences.add(new SecurityReference(\"Authorization\", authorizationScopes)); return securityReferences; &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() //标题 .title(\"gold-mall-biz使用Swagger2构建RESTful APIs\") //简介 .description(\"\") //服务条款 .termsOfServiceUrl(\"\") //作者个人信息 .contact(new Contact(\"xxx\", \"\", \"xxx@163.com\")) //版本 .version(\"1.0\") .build(); &#125;&#125; 设置完成后进入SwaggerUI，右上角出现“Authorization”按钮，输入令牌对于除上文所述的包含auth的接口结果都会带上token。 upload successful","tags":[{"name":"swagger","slug":"swagger","permalink":"https://caochikai.github.io/tags/swagger/"}]},{"title":"postman测试脚本自定义token","date":"2020-05-26T14:42:00.000Z","path":"2020/05/26/postman测试脚本自定义token/","text":"postman测试脚本自定义token一、需求 postman在测试微服务需要携带oauth2校验令牌Authorization:Bearer ，通过environment variable环境和test Script脚本，针对单次请求或者整个Collections设置自定义请求，甚至可以编排测试流程做自动化测试。environment一般来说分开发、测试和生产环境，从variable角度分environment variable（环境变量）、gloab variable（全局变量）和Collections variable（集合变量），对应了多项目多环境的测试需求；当然postman不足地方不能做自动化UI测试，遇到bug自动截屏或者内部堆栈记录报告；此外，如何从流行的swagger导入postman，OpenAPI与swagger哪个更适合新需求，个人推荐OpenAPI，它与postman更为兼容。 二、设置token环境变量设置postman的环境变量，添加变量token和host upload successful 在登录请求写test Script脚本获取access_token设置环境变量token，参考官方API文档 12var data = JSON.parse(responseBody);pm.environment.set(\"token\",data.access_token); 单次请求中一次性使用在Headers添加Authorization:Bearer ；如果想复用token，在下图右下角红框点击Prese进入Manage Prese，header添加到Prese管理，在其他请求里选择是否使用该header（手动添加）。 upload successful Pre-request Script全局Collections下所有请求使用该自定义请求头，右键Collections选择Edit进入编辑。 upload successful filename already exists, renamed 1pm.request.headers.upsert(&#123; key: \"Authorization\", value: \"Bearer \" + pm.environment.get(\"token\"), disabled: false&#125;); 三、通过console是否已经携带token，查看请求日志 四、swagger导入postman诀窍 无论通过http://localhost:9999/v2/api-docs下载成json再导入，还是通过链接导入都不能；因为postman目前只支持OpenAPI。 filename already exists, renamed 正确做法是通过swagger在线编辑器导入swagger文档，点击File选择import URL输入本地swagger url，导入成功点击Edit看见Cover to OpenAPI3，转化成openapi3后。 upload successful upload successful 复制openapi脚本通过postman左上角import选择Raw Text导入，如下图所示 upload successful 五、参考资料如下： Test examples Postman之Pre-request Script 使用详解","tags":[{"name":"tool","slug":"tool","permalink":"https://caochikai.github.io/tags/tool/"}]},{"title":"Jmeter压力测试openresty多级缓存","date":"2020-05-25T12:32:00.000Z","path":"2020/05/25/Jmeter压力测试openresty多级缓存/","text":"Jmeter压力测试openresty多级缓存一、快速使用 从Jmeter官网下载Apache JMeter 5.3 (Requires Java 8+)； 解压apache-jmeter-5.3.zip打开apache-jmeter-5.3\\bin\\jmeter.bat，前提是JDK环境变量配好和版本满足要求； 进入GUI界面后默认是英语，点击菜单栏【Options】按钮，依次单击【Choose language】&gt;【Chinese(simplified)】； 如果不喜欢黑暗主题，菜单栏【Options】下的选择第一个外观 二、新建压测实例 参照上一篇文章OpenResty+lua+redis实现多级缓存，我对多级缓存进行压测，先进行缓存预热，再对其进行压测；本地压测虽然不太标准，线程组200循环10次，普通tomcat的sql查询吞吐量TPS100/sec左右，加了redis缓存250/sec左右，OpenResty可以查看报告大概稳定9800/sec（线程2000，循环10次）；为了提升压测结果，可以选择增加数据库连接池和tomcat的最大连接数和初始连接数，以及缓冲区大小优化；先进方式就利用大量测试进行机器学习，找到相对优秀的配置组合。 添加本次测试计划 （Test Plan右键–&gt;添加–&gt;Threads（Users）–&gt;线程组） 设置线程数(并发用户数)和循环次数 upload successful 添加Http请求协议及相关配置信息（Thread Group右键–&gt;添加–&gt;取样器–&gt;Http请求） upload successful 为线程添加监听器——察看结果树、聚合报告和图形结果 upload successful 启动测试计划，查看测试报告 upload successful 三、参考资料 jmeter如何设置语言为中文 分析JMeter聚合报告中的各项指标","tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://caochikai.github.io/tags/jmeter/"}]},{"title":"OpenResty+lua+redis实现多级缓存","date":"2020-05-23T10:59:00.000Z","path":"2020/05/23/OpenResty-lua-redis实现广告缓存/","text":"OpenResty+lua+redis实现多级缓存一、需求 ngx_openresty是一个基于 NGINX的lua可编程模块，在性能方面有着出色的性能，配合redis做二级缓存效果，nginx开启一级本地缓存。 实验数据库sql12345678910111213141516171819202122SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for tb_ad-- ----------------------------DROP TABLE IF EXISTS `tb_ad`;CREATE TABLE `tb_ad` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '广告主键', `url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'URL', `status` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '0：无效 1:有效', `position` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '广告位置', `image` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '图片路径', `start_time` datetime(0) NULL DEFAULT NULL COMMENT '开始时间', `end_time` datetime(0) NULL DEFAULT NULL COMMENT '到期时间', PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of tb_ad-- ----------------------------INSERT INTO `tb_ad` VALUES (1, 'https://www.baidu.com/', '1', 'web_index_lb', 'https://kins.oss-cn-shenzhen.aliyuncs.com/yhzb/2020-03-11/ca21b3b17d6f4757b991dd86b8cef3fa-VIP-680.jpeg', '2020-05-22 10:58:08', '2021-06-01 10:58:14'); 二、一二级缓存实现 查询mysql中上架的所有广告转换为json字符串，放入redis中作为二级缓存，等真正的第一次查询会把缓存加入一级本地缓存。当广告修改时候需要请求，需要请求预热接口。 nginx.conf文件配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#user nobody;user root root;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; #包含redis初始化模块 lua_shared_dict dis_cache 5m; #共享内存开启 server &#123; listen 80; server_name localhost; charset utf-8; #access_log logs/host.access.log main; # 添加预热和读取接口 location /ad_loading&#123; content_by_lua_file /root/lua/ad_loading.lua; &#125; location /ad_read &#123; content_by_lua_file /root/lua/ad_read.lua; &#125; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; ad_loading.lua预热脚本123456789101112131415161718192021222324252627282930313233343536373839ngx.header.content_type=\"application/json;charset=utf8\"local cjson = require(\"cjson\")local mysql = require(\"resty.mysql\")local uri_args = ngx.req.get_uri_args()local position = uri_args[\"position\"]local db = mysql:new()db:set_timeout(1000) local props = &#123; host = \"127.0.0.1\", port = 3306, database = \"business\", user = \"root\", password = \"root\" &#125;local res = db:connect(props) local select_sql = \"select url,image from tb_ad where status ='1' and position='\"..position..\"' and start_time&lt;= NOW() AND end_time&gt;= NOW()\" res = db:query(select_sql) db:close() local redis = require(\"resty.redis\")local red = redis:new()red:set_timeout(2000)local ip =\"127.0.0.1\"local port = 6379red:connect(ip,port)--Redis Authenticationlocal result, err = red:auth(\"redis\")if not result then ngx.say(\"failed to authenticate: \", err) returnendred:set(\"ad_\"..position,cjson.encode(res))red:close()ngx.say(\"&#123;flag:true&#125;\") ad_read.lua读取脚本1234567891011121314151617181920212223242526272829303132--设置响应头类型ngx.header.content_type=\"application/json;charset=utf8\"--获取请求中的参数IDlocal uri_args = ngx.req.get_uri_args();local position = uri_args[\"position\"];--获取本地缓存local cache_ngx = ngx.shared.dis_cache;--根据ID 获取本地缓存数据local adCache = cache_ngx:get('ad_cache_'..position);if adCache == \"\" or adCache == nil then local redis = require(\"resty.redis\"); local red = redis:new() red:set_timeout(2000) local ok, err = red:connect(\"127.0.0.1\", 6379) --Redis Authentication local result, err = red:auth(\"redis\") if not result then ngx.say(\"failed to authenticate: \", err) return end local rescontent=red:get(\"ad_\"..position) ngx.say(rescontent) red:close() --将redis中获取到广告数据存入nginx本地缓存 cache_ngx:set('ad_cache_'..position, rescontent, 10*60);else --nginx本地缓存中获取到数据直接输出 ngx.say(adCache)end 三、拓展方向 lua + nginx可以作为网关进行限流、流控和多级缓存使用，内存小可用性也非常高，配合一些lua模块可以做一些深入拓展。","tags":[{"name":"nginx","slug":"nginx","permalink":"https://caochikai.github.io/tags/nginx/"},{"name":"redis","slug":"redis","permalink":"https://caochikai.github.io/tags/redis/"}]},{"title":"防止jenkins杀掉jar后台运行","date":"2020-05-22T12:09:00.000Z","path":"2020/05/22/防止jenkins杀掉jar后台运行/","text":"一、背景 记录两年前jenkins持续集成遇到需要任务后台执行（nohup执行）结果发现jenkins的job执行完后，看不到运行的进程。shell启动脚本如下： 1nohup java -jar /bootdo.jar &gt; bootdolog.file 2&gt;&amp;1 &amp; 二、解决方法 Jenkins任务结束时候默认使用processTreeKiller自动关掉了所有的子进程，通过下列两种方式都可以让其在后台运行。全局关闭，具体参考：https://wiki.jenkins.io/display/JENKINS/ProcessTreeKiller。 全局启动参数1java -Dhudson.util.ProcessTree.disable=true -jar jenkins.war Tomcat启动修改catalina.sh1JAVA_OPTS=\"$JAVA_OPTS -Dhudson.util.ProcessTree.disable=true\"； 当前job便捷方式12#BUILD_ID可以自定义环境变量名，下面只是举例BUILD_ID=dontKillMe /usr/apache/bin/httpd","tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://caochikai.github.io/tags/jenkins/"}]},{"title":"Jenkins常见技巧和插件加速","date":"2020-05-21T06:53:00.000Z","path":"2020/05/21/Jenkins常见技巧和插件加速/","text":"Jenkins常见技巧和插件加速展望计划 在微服务单体仓库、GitLab和k8s环境下，如何配合测试、运维完成Devops。参数化自动和手动构建同时按需增量，同时多次更新合并到最后一次，成功失败发送邮件和信息到运维。包括静态代码检查、自动化测试和容器热更新，同时探讨JenkinsX和Gitlab CI提高构建效率。 一、如何快速启动、停止、重启、查看日志 采用通用的URL方式，就可以实现Jenins的停止，重启和重载。启动java -jar jenkins.war方式，或者通过tomcat也可。 12345http://[jenkins-server-address][:port]/[command] where [command] can beexit to shutdown jenkinsrestart to restart jenkinsreload to reload the configuration 查看日志根据Jenkins官方文档，tail -f 日志文件位置，遇到过由于docket插件造成日志文件爆磁盘。 123456LinuxBy default logs should be made available in /var/log/jenkins/jenkins.log, unless customized in /etc/default/jenkins (for *.deb) or via /etc/sysconfig/jenkins (for */rpm)WindowsBy default logs should be at %JENKINS_HOME%/jenkins.out and %JENKINS_HOME%/jenkins.err, unless customized in %JENKINS_HOME%/jenkins.xmlDockerIf you run Jenkins inside docker as a detached container, you can use docker logs containerId to view the Jenkins logs. 在Jenkins内部日志是可以设置logs级别和信息，默认使用java.util.logging输出INFO级别日志。插件日志可以添加log recorder，就可以查看到源码级别日志输出，如图所示： https://www.jenkins.io/doc/book/resources/managing/logging-manage-screen.png https://img2018.cnblogs.com/blog/692500/201908/692500-20190811165844377-1762367867.png 二、国内镜像加速插件和版本更新 官方镜像很慢几乎不可用，国内有两家镜像源：清华大学和华为，个人选择华为速度起飞︿(￣︶￣)︿。需要改动两个文件hudson.model.UpdateCenter.xml和/updates/default.json，更新完成通过http://localhost:8080/restart重启，下载插件速度飙升跑满宽带。 镜像列表 清华大学镜像：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 华为镜像：https://mirrors.huaweicloud.com/jenkins/updates/update-center.json 123456789vim hudson.model.UpdateCenter.xml&lt;?xml version='1.1' encoding='UTF-8'?&gt;&lt;sites&gt; &lt;site&gt; &lt;id&gt;default&lt;/id&gt; &lt;url&gt;https://mirrors.huaweicloud.com/jenkins/updates/update-center.json&lt;/url&gt; &lt;/site&gt;&lt;/sites&gt; 123vim updates/default.json:1,$s/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.huaweicloud.com\\/jenkins/g:1,$s/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g 三、参考资料 Jenkins技巧：如何启动、停止、重启、重载Jenkins Viewing logs Table of Contents Logs on the system Jenkins增加日志查看内容. 如何查看Jenkins插件的日志？ jenkins | 使用镜像加速安装插件","tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://caochikai.github.io/tags/jenkins/"}]},{"title":"Spring Cloud Feign连接池okhttp EOF异常","date":"2020-05-18T07:07:00.000Z","path":"2020/05/18/Spring-Cloud-Feign连接池okhttp-EOF异常/","text":"Spring Cloud Feign连接池okhttp EOF异常一、异常说明 所有中台服务有一定概率经常返回远程调用返回null情况，而且在我进入公司之前已经出现过很长一段时间都未曾解决。我第一怀疑的是远程调用时间开销过长，通过埋点FeignFallback记录系统日志记录，一段时间过后sys_log大量类似下面记录，证明我的猜想是错误的；通过Linux tail查看jar日志，追踪源码发现是Okhttp java.io.EOFException: \\n not found: size=0 content= unexpected end，根据okhttp github issue可以得出结论，由于连接池ConnectionPool 默认keep-alive超时时间是5min，超过时间server端会主动关闭这个连接，导致输入流中断，进而抛出EOF 异常；另一种情况就是网络不稳定抖动时候也会出现。 埋点系统日志 id type title service_id create_by create_time update_time remote_addr user_agent request_uri method params time del_flag exception 5179 0 feign接口获取会员信息失败 pig 1868054xxxx 2020-05-15 13:40:17.0 2020-05-15 13:40:17.0 192.168.6.148 Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36 /user/info GET 5 0 EOF 异常控制台日志：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237feign.RetryableException: unexpected end of stream on Connection&#123;192.168.6.55:4000, proxy=DIRECT hostAddress=/192.168.6.55:4000 cipherSuite=none protocol=http/1.1&#125; executing GET http://gold-admin/syssite/getSiteById/1 at feign.FeignException.errorExecuting(FeignException.java:132) at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:113) at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:78) at feign.hystrix.HystrixInvocationHandler$1.run(HystrixInvocationHandler.java:109) at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:302) at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:298) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:46) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48) at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41) at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51) at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.subscribe(Observable.java:10423) at rx.Observable.subscribe(Observable.java:10390) at rx.internal.operators.BlockingOperatorToFuture.toFuture(BlockingOperatorToFuture.java:51) at rx.observables.BlockingObservable.toFuture(BlockingObservable.java:410) at com.netflix.hystrix.HystrixCommand.queue(HystrixCommand.java:378) at com.netflix.hystrix.HystrixCommand.execute(HystrixCommand.java:344) at feign.hystrix.HystrixInvocationHandler.invoke(HystrixInvocationHandler.java:170) at com.sun.proxy.$Proxy289.getSiteById(Unknown Source) at com.gdjs.gold.business.controller.BusinessPortalController.info(BusinessPortalController.java:58) at com.gdjs.gold.business.controller.BusinessPortalController$$FastClassBySpringCGLIB$$66c8c0df.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:93) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) at com.gdjs.gold.business.controller.BusinessPortalController$$EnhancerBySpringCGLIB$$261d70.info(&lt;generated&gt;) at sun.reflect.GeneratedMethodAccessor1225.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:892) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1039) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) at javax.servlet.http.HttpServlet.service(HttpServlet.java:645) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) at javax.servlet.http.HttpServlet.service(HttpServlet.java:750) at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:74) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:129) at org.springframework.boot.actuate.web.trace.servlet.HttpTraceFilter.doFilterInternal(HttpTraceFilter.java:88) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:127) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:91) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:170) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationProcessingFilter.doFilter(OAuth2AuthenticationProcessingFilter.java:176) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:74) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:357) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:270) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.cloud.sleuth.instrument.web.ExceptionLoggingFilter.doFilter(ExceptionLoggingFilter.java:50) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at brave.servlet.TracingFilter.doFilter(TracingFilter.java:99) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.filterAndRecordMetrics(WebMvcMetricsFilter.java:114) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:104) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:84) at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62) at io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:68) at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36) at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:132) at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:57) at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46) at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64) at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60) at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:77) at io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43) at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:292) at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:81) at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:138) at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:135) at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48) at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43) at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:272) at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:81) at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:104) at io.undertow.server.Connectors.executeRootHandler(Connectors.java:364) at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)Caused by: java.io.IOException: unexpected end of stream on Connection&#123;192.168.6.55:4000, proxy=DIRECT hostAddress=/192.168.6.55:4000 cipherSuite=none protocol=http/1.1&#125; at okhttp3.internal.http1.Http1Codec.readResponseHeaders(Http1Codec.java:208) at okhttp3.internal.http.CallServerInterceptor.intercept(CallServerInterceptor.java:88) at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:147) at okhttp3.internal.connection.ConnectInterceptor.intercept(ConnectInterceptor.java:45) at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:147) at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:121) at okhttp3.internal.cache.CacheInterceptor.intercept(CacheInterceptor.java:93) at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:147) at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:121) at okhttp3.internal.http.BridgeInterceptor.intercept(BridgeInterceptor.java:93) at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:147) at okhttp3.internal.http.RetryAndFollowUpInterceptor.intercept(RetryAndFollowUpInterceptor.java:126) at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:147) at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:121) at okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:200) at okhttp3.RealCall.execute(RealCall.java:77) at feign.okhttp.OkHttpClient.execute(OkHttpClient.java:167) at org.springframework.cloud.sleuth.instrument.web.client.feign.TracingFeignClient.execute(TracingFeignClient.java:100) at org.springframework.cloud.sleuth.instrument.web.client.feign.LazyTracingFeignClient.execute(LazyTracingFeignClient.java:60) at org.springframework.cloud.openfeign.ribbon.FeignLoadBalancer.execute(FeignLoadBalancer.java:93) at org.springframework.cloud.openfeign.ribbon.FeignLoadBalancer.execute(FeignLoadBalancer.java:56) at com.netflix.client.AbstractLoadBalancerAwareClient$1.call(AbstractLoadBalancerAwareClient.java:104) at com.netflix.loadbalancer.reactive.LoadBalancerCommand$3$1.call(LoadBalancerCommand.java:303) at com.netflix.loadbalancer.reactive.LoadBalancerCommand$3$1.call(LoadBalancerCommand.java:287) at rx.internal.util.ScalarSynchronousObservable$3.call(ScalarSynchronousObservable.java:231) at rx.internal.util.ScalarSynchronousObservable$3.call(ScalarSynchronousObservable.java:228) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286) at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.onNext(OnSubscribeConcatMap.java:144) at com.netflix.loadbalancer.reactive.LoadBalancerCommand$1.call(LoadBalancerCommand.java:185) at com.netflix.loadbalancer.reactive.LoadBalancerCommand$1.call(LoadBalancerCommand.java:180) at rx.Observable.unsafeSubscribe(Observable.java:10327) at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:94) at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:42) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.subscribe(Observable.java:10423) at rx.Observable.subscribe(Observable.java:10390) at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:443) at rx.observables.BlockingObservable.single(BlockingObservable.java:340) at com.netflix.client.AbstractLoadBalancerAwareClient.executeWithLoadBalancer(AbstractLoadBalancerAwareClient.java:112) at org.springframework.cloud.openfeign.ribbon.LoadBalancerFeignClient.execute(LoadBalancerFeignClient.java:83) at org.springframework.cloud.sleuth.instrument.web.client.feign.TraceLoadBalancerFeignClient.execute(TraceLoadBalancerFeignClient.java:71) at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:108) ... 181 common frames omittedCaused by: java.io.EOFException: \\n not found: limit=0 content=… at okio.RealBufferedSource.readUtf8LineStrict(RealBufferedSource.java:237) at okhttp3.internal.http1.Http1Codec.readHeaderLine(Http1Codec.java:215) at okhttp3.internal.http1.Http1Codec.readResponseHeaders(Http1Codec.java:189) ... 226 common frames omitted 二、如何埋点这种概率性异常呢？ Feign的Fallback机制可以进行日志埋点，由于长时间接触这个异常，发现规律都是因为登录后长时间不进行请求。下面就是埋点日志代码实现： 123456789101112131415161718192021222324/** * 系统日志工具类 * * @author caochikai */@UtilityClasspublic class SysLogUtils &#123; public SysLog getSysLog() &#123; HttpServletRequest request = ((ServletRequestAttributes) Objects .requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest(); SysLog sysLog = new SysLog();//需要记录请求详细信息，根据需要改变细节 sysLog.setCreateBy(Objects.requireNonNull(getUsername())); sysLog.setType(CommonConstants.STATUS_NORMAL); sysLog.setRemoteAddr(ServletUtil.getClientIP(request)); sysLog.setRequestUri(URLUtil.getPath(request.getRequestURI())); sysLog.setMethod(request.getMethod()); sysLog.setUserAgent(request.getHeader(\"user-agent\")); sysLog.setParams(HttpUtil.toParams(request.getParameterMap())); sysLog.setServiceId(getClientId()); return sysLog; &#125;....省略&#125; 12345678910111213141516171819@Slf4j@Componentpublic class MallMemberFeignFallbackImpl implements MallMemberFeign &#123; @Setter private Throwable cause;//Long startTime参数只是为了暂时记录远程调用的开始时间，会去掉 @Override public R&lt;MallMember&gt; getMemberByUserId(String userId, Long startTime) &#123; log.error(\"通过userId获取会员详情失败&#123;&#125;\",userId, cause); SysLog logVo = SysLogUtils.getSysLog(); logVo.setTitle(\"feign接口获取会员信息失败\"); // 发送异步日志事件 Long endTime = System.currentTimeMillis(); logVo.setTime(endTime - startTime);//发送SysLogEvent事件 SpringContextHolder.publishEvent(new SysLogEvent(logVo)); return null; &#125;&#125; 1234567891011121314151617/** * @author caochikai * 异步监听日志事件 */@Slf4j@AllArgsConstructorpublic class SysLogListener &#123; private final RemoteLogService remoteLogService; @Async @Order @EventListener(SysLogEvent.class) public void saveSysLog(SysLogEvent event) &#123; SysLog sysLog = (SysLog) event.getSource(); remoteLogService.saveLog(sysLog); &#125;&#125; 三、Okhttp源码分析 在进行常规的breakpoint之后, 需要重点关注OkHttpLoadBalancingClient、RetryAndFollowUpInterceptor、Http1Codec和RealBufferedSource。 12345678910111213141516171819202122232425262728293031323334353637383940spring-cloud-netflix-ribbon-2.0.0.RELEASE-sources.jar!/org/springframework/cloud/netflix/ribbon/okhttp/OkHttpLoadBalancingClient.javapublic class OkHttpLoadBalancingClient extends AbstractLoadBalancingClient&lt;OkHttpRibbonRequest, OkHttpRibbonResponse, OkHttpClient&gt; &#123; //...... @Override public OkHttpRibbonResponse execute(OkHttpRibbonRequest ribbonRequest, final IClientConfig configOverride) throws Exception &#123; boolean secure = isSecure(configOverride); if (secure) &#123; final URI secureUri = UriComponentsBuilder.fromUri(ribbonRequest.getUri()) .scheme(\"https\").build().toUri(); ribbonRequest = ribbonRequest.withNewUri(secureUri); &#125;//Feign实际调用client OkHttpClient httpClient = getOkHttpClient(configOverride, secure); final Request request = ribbonRequest.toRequest(); Response response = httpClient.newCall(request).execute(); return new OkHttpRibbonResponse(response, ribbonRequest.getUri()); &#125; OkHttpClient getOkHttpClient(IClientConfig configOverride, boolean secure) &#123; IClientConfig config = configOverride != null ? configOverride : this.config; RibbonProperties ribbon = RibbonProperties.from(config);//建造者模式构建http请求 OkHttpClient.Builder builder = this.delegate.newBuilder() .connectTimeout(ribbon.connectTimeout(this.connectTimeout), TimeUnit.MILLISECONDS) .readTimeout(ribbon.readTimeout(this.readTimeout), TimeUnit.MILLISECONDS) .followRedirects(ribbon.isFollowRedirects(this.followRedirects)); if (secure) &#123; builder.followSslRedirects(ribbon.isFollowRedirects(this.followRedirects)); &#125; return builder.build(); &#125; //......&#125; 1234567891011121314151617181920212223242526272829303132333435public class RetryAndFollowUpInterceptor implements Interceptor &#123; //.... @Override public Response intercept(Chain chain) throws IOException &#123; //.... while(true) &#123; try &#123; response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (IOException) &#123; // An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); // 此处非常重要，若不允许恢复，直接将异常向上抛出（调用方接收）,反之 循环继续执行realChain.proceed()方法 if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; &#125; &#125; private boolean recover(IOException e, StreamAllocation streamAllocation, boolean requestSendStarted, Request userRequest) &#123; // .... // The application layer has forbidden retries. // 若客户端配置 retryOnConnectionFailure 为false 则表明不允许重试，直接将异常抛给调用方 if (!client.retryOnConnectionFailure()) return false; &#125; //....&#125; 当执行realChain.proceed() ，将事件继续分发给各个拦截器，最终执行到 Http1Codec#readResponseHeaders 方法。Http1Codec 用于Encode Http Request 以及 解析 Http Response的，用于获取头信息相关参数。 1234567891011121314151617181920212223Http1Codec.javapublic class Http1Codec implements HttpCodec &#123; //... @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException &#123; try&#123; StatusLine statusLine = StatusLine.parse(readHeaderLine()); //后续代码根据statusLine 构造Response &#125; catch(EOFException e) &#123; // 原来异常信息就是从这里抛出来的，接下来需要重点关注下readHeaderLine方法 // Provide more context if the server ends the stream before sending a response. IOException exception = new IOException(\"unexpected end of stream on \" + streamAllocation); exception.initCause(e); &#125; &#125; private String readHeaderLine() throws IOException &#123; // 继续查看RealBufferedSource#readUtf8LineStrict方法 String line = source.readUtf8LineStrict(headerLimit); headerLimit -= line.length(); return line; &#125; //...&#125; 12345678910111213141516171819202122RealBufferedSource.javafinal class RealBufferedSource implements BufferedSource &#123; //... // 由于server端已经closed，故buffer == null 将EOF异常向上抛出 @Override public String readUtf8LineStrict(long limit) throws IOException &#123; if (limit &lt; 0) throw new IllegalArgumentException(\"limit &lt; 0: \" + limit); long scanLength = limit == Long.MAX_VALUE ? Long.MAX_VALUE : limit + 1; long newline = indexOf((byte) '\\n', 0, scanLength); if (newline != -1) return buffer.readUtf8Line(newline); if (scanLength &lt; Long.MAX_VALUE &amp;&amp; request(scanLength) &amp;&amp; buffer.getByte(scanLength - 1) == '\\r' &amp;&amp; request(scanLength + 1) &amp;&amp; buffer.getByte(scanLength) == '\\n') &#123; return buffer.readUtf8Line(scanLength); // The line was 'limit' UTF-8 bytes followed by \\r\\n. &#125; Buffer data = new Buffer(); buffer.copyTo(data, 0, Math.min(32, buffer.size())); //实际抛出异常的栈点 throw new EOFException(\"\\\\n not found: limit=\" + Math.min(buffer.size(), limit) + \" content=\" + data.readByteString().hex() + '…'); &#125; //...&#125; 四、解决办法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.common.core.config;import okhttp3.ConnectionPool;import okhttp3.OkHttpClient;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSocketFactory;import javax.net.ssl.TrustManager;import javax.net.ssl.X509TrustManager;import java.security.KeyManagementException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import java.util.concurrent.TimeUnit;/** * 配置 okhttp 与连接池 * Date 2019/12/11 */@Configurationpublic class OkHttpConfiguration &#123; @Bean public OkHttpClient okHttpClient() &#123; return new OkHttpClient.Builder()//解决重点在这里，发送异常允许重试请求 **.retryOnConnectionFailure(true)** .connectionPool(pool())//设置连接超时 .connectTimeout(3000, TimeUnit.SECONDS)//设置读超时 .readTimeout(3000, TimeUnit.SECONDS)//设置写超时 .writeTimeout(3000,TimeUnit.SECONDS) .build(); &#125; @Bean public X509TrustManager x509TrustManager() &#123; return new X509TrustManager() &#123; @Override public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125;; &#125; @Bean public SSLSocketFactory sslSocketFactory() &#123; try &#123; //信任任何链接 SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, new TrustManager[]&#123;x509TrustManager()&#125;, new SecureRandom()); return sslContext.getSocketFactory(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Bean public ConnectionPool pool() &#123;//ConnectionPool 每个地址的最大空闲连接数200，保持5分钟长连接 return new ConnectionPool(200, 5, TimeUnit.MINUTES); &#125;&#125; 五、参考资料 Spring Cloud Feign 总结问题，注意点，性能调优，切换okhttp3 Spring cloud 超时及重试配置【ribbon及其它http client】 [记录某次解决`Okhttp java.io.EOFException: \\n not found: size=0 content= unexpected end](https://juejin.im/post/5b5efedef265da0f6825e235)","tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://caochikai.github.io/tags/SpringCloud/"}]},{"title":"SpringCloud之Wesocket双向通信","date":"2020-05-12T06:47:00.000Z","path":"2020/05/12/SpringBoot之Wesocket双向通信/","text":"SpringCloud之Wesocket双向通信一、需求 运营中台向某个商家或者全部平台发送实时消息通知，websocket在微服务gateway网关和Oauth2鉴权的环境下，会遇到网关转发Authorization:Bearer 鉴权失败。由于websocket协议在握手时候是不支持Oauth2在header放置token，那么就有两种解决办法，第一种在网关处添加GlobalFilter转发header并且暴露websocket，第二种直接暴露websocket放开鉴权，登录之后直接链接websocket；有了双向通信功能就可以取代轮询，比如PC扫码支付后通知前端支付结果，具体实现参考Github Demo仓库在文章结尾。 二、第一种解决办法 Websocket握手协商报文如下，SockJS注意端点跨域： 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Componentpublic class WebsocketHandler implements GlobalFilter, Ordered &#123; private final static String DEFAULT_FILTER_PATH = \"/user-service/info\"; /** * @param exchange ServerWebExchange是一个HTTP请求-响应交互的契约。提供对HTTP请求和响应的访问， * 并公开额外的 服务器 端处理相关属性和特性，如请求属性 * @param chain * @return */ @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; String upgrade = exchange.getRequest().getHeaders().getUpgrade(); URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR); String scheme = requestUrl.getScheme(); if (\"websocket\".equals(upgrade)) &#123; String queryParam = requestUrl.getRawQuery(); Map&lt;String, String&gt; paramMap = HttpUtil.decodeParamMap(queryParam, CharsetUtil.UTF_8); String token = paramMap.get(\"token\"); if (StrUtil.isNotBlank(token)) &#123; //向headers中放token，记得build ServerHttpRequest host = exchange.getRequest().mutate().header(\"Authorization\", \"Bearer \" + token).build(); //将现在的request 变成 change对象 ServerWebExchange build = exchange.mutate().request(host).build(); return chain.filter(build); &#125; &#125; if (!\"ws\".equals(scheme) &amp;&amp; !\"wss\".equals(scheme)) &#123; return chain.filter(exchange); &#125; else if (DEFAULT_FILTER_PATH.equals(requestUrl.getPath())) &#123; String wsScheme = convertWsToHttp(scheme); URI wsRequestUrl = UriComponentsBuilder.fromUri(requestUrl).scheme(wsScheme).build().toUri(); exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, wsRequestUrl); &#125; return chain.filter(exchange); &#125; @Override public int getOrder() &#123; return Ordered.LOWEST_PRECEDENCE - 2; &#125; static String convertWsToHttp(String scheme) &#123; scheme = scheme.toLowerCase(); return \"ws\".equals(scheme) ? \"http\" : \"wss\".equals(scheme) ? \"https\" : scheme; &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class TokenHandshakeInterceptor implements HandshakeInterceptor &#123; /** * websocket握手认证在registry.addEndpoint(\"/websocket\")添加 */ @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception &#123; ServletServerHttpRequest req = (ServletServerHttpRequest) request; //获取token认证 String token = req.getServletRequest().getParameter(\"token\"); //解析token获取用户信息 Principal user = parseToken(token); if(user == null)&#123; //如果token认证失败user为null，返回false拒绝握手 return false; &#125; //保存认证用户 attributes.put(\"user\", user); return true; &#125; @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception exception) &#123; &#125; /** * 根据token认证授权 * @param token */ private Principal parseToken(String token)&#123; //TODO 解析token并获取认证用户信息，建议通过feight接口 return null; &#125;&#125; 三、第二种SockJS直接连接123456789101112131415161718192021222324252627282930313233343536373839404142@Configuration@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123;//注入跨域配置默认是* @Autowired private CommonConfig commonConfig; @Override public void configureMessageBroker(MessageBrokerRegistry registry) &#123; /*类似mq的Broker主题，通常按中台设计有几大平台就有几类主题 * This enables a simple (in-memory) message broker for our application. * The `/topic` designates that any destination prefixed with `/topic` * will be routed back to the client. * It's important to keep in mind, this will not work with more than one * application instance, and it does not support all of the features a * full message broker like RabbitMQ, ActiveMQ, etc... provide. */ registry.enableSimpleBroker(Arrays.stream(ThemeEnum.values()).map(ThemeEnum::getTheme).toArray(String[]::new)); /*客户端发送消息开头 * The application destination prefix `/app` designates the broker to send * messages prefixed with `/app` to our `@MessageMapping`s. */ registry.setApplicationDestinationPrefixes(\"/app\"); &#125; @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; /* * This configures a STOMP (Simple Text Oriented Messaging Protocol) * endpoint for our websocket to be hosted on &#125;) */ registry.addEndpoint(\"/websocket\").setAllowedOrigins(commonConfig.getOrigins()).withSockJS(); /* * This configures an endpoint with a fallback for SockJS in case the * client (an old browser) doesn't support WebSockets natively */ registry.addEndpoint(\"/sockjs\").setAllowedOrigins(commonConfig.getOrigins()).withSockJS(); &#125;&#125; 四、网页端测试Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link href=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.css\" rel=\"stylesheet\"/&gt; &lt;style&gt; body &#123; background-color: #f5f5f5; &#125; #main-content &#123; max-width: 940px; padding: 2em 3em; margin: 0 auto 20px; background-color: #fff; border: 1px solid #e5e5e5; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; &#125; .from &#123; width: 120px; &#125; .timeStamp &#123; width: 220px; &#125; &lt;/style&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/@stomp/stompjs@5.0.0/bundles/stomp.umd.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var stompClient = null; //根据需要是否进行websocket配合oauth2进行鉴权 var token = \"754741bc-08c1-4433-ab05-c803c589b58f\"; function setConnected(connected) &#123; $(\"#connect\").prop(\"disabled\", connected); $(\"#connectSockJS\").prop(\"disabled\", connected); $(\"#disconnect\").prop(\"disabled\", !connected); if (connected) &#123; $(\"#responses\").show(); &#125; else &#123; $(\"#responses\").hide(); &#125; $(\"#messages\").html(\"\"); &#125; function frameHandler(frame) &#123; setConnected(true); console.log('Connected: ' + frame); //SockJS订阅不同的主题，类似mq的消息队列模式 stompClient.subscribe('/topic', function (message) &#123; showMessage(message.body); &#125;); stompClient.subscribe('/business', function (message) &#123; showMessage(message.body); &#125;); stompClient.subscribe('/business/11', function (message) &#123; showMessage(message.body); &#125;); &#125; function onSocketClose() &#123; if (stompClient !== null) &#123; stompClient.deactivate(); &#125; setConnected(false); console.log(\"Socket was closed. Setting connected to false!\") &#125; function connect() &#123; stompClient = new window.StompJs.Client(&#123; webSocketFactory: function () &#123; return new WebSocket(\"ws://127.0.0.1:9999/common/websocket\"); &#125; &#125;); stompClient.onConnect = function (frame) &#123; frameHandler(frame) &#125;; stompClient.onWebsocketClose = function () &#123; onSocketClose(); &#125;; stompClient.activate(); &#125; function connectSockJs() &#123; stompClient = new window.StompJs.Client(&#123; webSocketFactory: function () &#123; return new window.SockJS(\"http://127.0.0.1:9999/common/sockjs\"); &#125; &#125;); stompClient.onConnect = function (frame) &#123; frameHandler(frame) &#125;; stompClient.onWebsocketClose = function () &#123; onSocketClose(); &#125;; stompClient.activate(); &#125; function disconnect() &#123; if (stompClient !== null) &#123; stompClient.deactivate(); &#125; setConnected(false); console.log(\"Disconnected\"); &#125; function sendMessage() &#123; stompClient.publish(&#123; destination: \"/app/send\", body: JSON.stringify(&#123; 'from': $(\"#from\").val(), 'message': $(\"#message\").val() &#125;) &#125;); &#125; function showMessage(message) &#123; var msg = JSON.parse(message); $(\"#responses\").prepend(\"&lt;tr&gt;\" + \"&lt;td class='timeStamp'&gt;\" + msg['timeStamp'] + \"&lt;/td&gt;\" + \"&lt;td class='from'&gt;\" + msg['from'] + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + msg['message'] + \"&lt;/td&gt;\" + \"&lt;/tr&gt;\"); &#125; $(function () &#123; $(\"form\").on('submit', function (e) &#123; e.preventDefault(); &#125;); $(\"#connect\").click(function () &#123; connect(); &#125;); $(\"#connectSockJS\").click(function () &#123; connectSockJs(); &#125;); $(\"#disconnect\").click(function () &#123; disconnect(); &#125;); $(\"#send\").click(function () &#123; sendMessage(); &#125;); $(\"document\").ready(function () &#123; disconnect(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;noscript&gt;&lt;h2 style=\"color: #ff0000\"&gt;Seems your browser doesn't support Javascript! Websocket relies on Javascript being enabled. Please enable Javascript and reload this page!&lt;/h2&gt;&lt;/noscript&gt;&lt;div class=\"container\" id=\"main-content\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-10\"&gt; &lt;form class=\"form-inline\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"connect\"&gt;WebSocket connection:&lt;/label&gt; &lt;button class=\"btn btn-default\" id=\"connect\" type=\"submit\"&gt;Connect&lt;/button&gt; &lt;button class=\"btn btn-default\" id=\"connectSockJS\" type=\"submit\"&gt;ConnectSockJS&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col-md-2\"&gt; &lt;form class=\"form-inline\"&gt; &lt;div class=\"form-group\"&gt; &lt;button class=\"btn btn-default\" disabled=\"disabled\" id=\"disconnect\" type=\"submit\"&gt; Disconnect &lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;form class=\"form-inline\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"from\"&gt;Username:&lt;/label&gt; &lt;input class=\"form-control\" id=\"from\" placeholder=\"Username...\" type=\"text\"&gt; &lt;label for=\"message\"&gt;Message:&lt;/label&gt; &lt;input class=\"form-control\" id=\"message\" placeholder=\"Your message here...\" type=\"text\"&gt; &lt;/div&gt; &lt;button class=\"btn btn-default\" id=\"send\" type=\"submit\"&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;table class=\"table table-striped\" id=\"responses\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Messages&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=\"messages\"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 五、参考Demo和资料 https://github.com/jmlw/demo-projects https://blog.joshmlwood.com/websockets-with-spring-boot/","tags":[{"name":"Spring","slug":"Spring","permalink":"https://caochikai.github.io/tags/Spring/"}]},{"title":"SpringBoot之Redis定时发送消息","date":"2020-05-09T03:26:00.000Z","path":"2020/05/09/SpringBoot之Redis定时发送消息/","text":"SpringBoot之Redis定时发送消息一、需求 实时发送定时公告，倒计时功能通过监听Redis 缓存过期（Key 失效）事件。类似用途可以用于订单定时关闭，商品或活动上下架。 二、修改 redis.conf 文件，打开 notify-keyspace-events Ex 的注释，开启过期通知功能123456789101112131415161718192021222324252627282930313233343536373839404142434445############################# EVENT NOTIFICATION ############################### Redis can notify Pub/Sub clients about events happening in the key space.# This feature is documented at http://redis.io/topics/notifications## For instance if keyspace events notification is enabled, and a client# performs a DEL operation on key \"foo\" stored in the Database 0, two# messages will be published via Pub/Sub:## PUBLISH __keyspace@0__:foo del# PUBLISH __keyevent@0__:del foo## It is possible to select the events that Redis will notify among a set# of classes. Every class is identified by a single character:## K Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.# E Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.# g Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...# $ String commands# l List commands# s Set commands# h Hash commands# z Sorted set commands# x Expired events (events generated every time a key expires)# e Evicted events (events generated when a key is evicted for maxmemory)# A Alias for g$lshzxe, so that the \"AKE\" string means all the events.## The \"notify-keyspace-events\" takes as argument a string that is composed# of zero or multiple characters. The empty string means that notifications# are disabled.## Example: to enable list and generic events, from the point of view of the# event name, use:## notify-keyspace-events Elg## Example 2: to get the stream of the expired keys subscribing to channel# name __keyevent@0__:expired use:## notify-keyspace-events Ex## By default all notifications are disabled because most users don't need# this feature and the feature has some overhead. Note that if you don't# specify at least one of K or E, no events will be delivered.notify-keyspace-events \"\" 三、重启redis ,测试监听事件是否开启 keyevent@*:expired其实是指所有库，可以指定库下标监听16个默认数据库的某一个，比如*keyevent@1指定壹号库。打开redisclientA**，PSUBSCRIBE指令订阅事件。 12345127.0.0.1:6379&gt; PSUBSCRIBE __keyevent@*__:expiredReading messages... (press Ctrl-C to quit)1) \"psubscribe\"2) \"__keyevent@*__:expired\"3) (integer) 1 再开启另一个redisclientB，发送过期数据指定事件2秒。 12127.0.0.1:6379&gt; setex test 2 2OK redisclientA就会监听到redisclientB过期key 123456789127.0.0.1:6379&gt; PSUBSCRIBE __keyevent@*__:expiredReading messages... (press Ctrl-C to quit)1) \"psubscribe\"2) \"__keyevent@*__:expired\"3) (integer) 11) \"pmessage\"2) \"__keyevent@*__:expired\"3) \"__keyevent@0__:expired\"4) \"test\" 四、监听器配置和实现 KeyExpirationEvent1MessageListener可参考org.springframework.data.redis.listener.KeyExpirationEventMessageListener源码实现的（默认订阅的是keyevent@*:expired），而我们目标是监听壹号库。因为0号库给限流和oauth2用了，里面存在很多短期key，会监听许多不相干的业务key缓存。此外，不能给KeyExpirationEvent1MessageListener加上@Component，因为存在bean循环依赖问题，可以通过SpringContextHolder解决。 123456789101112131415161718192021222324252627282930313233343536373839404142@Slf4jpublic class KeyExpirationEvent1MessageListener extends KeyExpirationEventMessageListener &#123; private static final Topic KEYEVENT1_EXPIRED_TOPIC = new PatternTopic(\"__keyevent@1__:expired\"); /** * @param listenerContainer must not be &#123;@literal null&#125;. */ public KeyExpirationEvent1MessageListener(RedisMessageListenerContainer listenerContainer) &#123; super(listenerContainer); &#125; @Override public void doRegister(RedisMessageListenerContainer listenerContainer) &#123; listenerContainer.addMessageListener(this, KEYEVENT1_EXPIRED_TOPIC); &#125; @Override public void onMessage(Message message, byte[] pattern) &#123; //获取过期的key String expireKey = message.toString(); //设置监听频道 if (expireKey.startsWith(RedisConstant.NOTIFY_RECEIVE)) &#123; log.info(\"过期的键值对的消息ID:\" + expireKey); log.info(\"消息监听频道topic:\" + new String(message.getChannel()));//获取消息发送id，通过 String sendId = expireKey.substring(RedisConstant.NOTIFY_RECEIVE.length()); SysNotifySendService sysNotifySendService = SpringContextHolder.getBean(SysNotifySendService.class);//common服务提供websocket发送远程接口RemoteCommonService RemoteCommonService remoteCommonService = SpringContextHolder.getBean(RemoteCommonService.class); SysNotifyReceiveService receiveService = SpringContextHolder.getBean(SysNotifyReceiveService.class); SysNotifySend sysNotifySend = sysNotifySendService.getOne(Wrappers.&lt;SysNotifySend&gt;lambdaQuery().eq(SysNotifySend::getSendId, sendId)); com.gdjs.gold.admin.api.dto.Message websocketMsg = new com.gdjs.gold.admin.api.dto.Message(); websocketMsg.setSendId(sysNotifySend.getSendId()); websocketMsg.setFrom(sysNotifySend.getSendUserId()); websocketMsg.setDestination(ThemeEnum.BUSINESS.getTheme()); websocketMsg.setMessage(sysNotifySend.getContent()); remoteCommonService.sendMessage(websocketMsg); &#125; &#125;&#125; 123456789101112131415@Configurationpublic class RedisListenerConfig &#123; @Bean public RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory, ApplicationContext context) &#123; RedisMessageListenerContainer container = new RedisMessageListenerContainer(); container.setConnectionFactory(connectionFactory);//通过new监听器，并且往RedisMessageListenerContainer注册监听器 KeyExpirationEvent1MessageListener listener = new KeyExpirationEvent1MessageListener(container); listener.doRegister(container); listener.setApplicationEventPublisher(context); return container; &#125;&#125; 五、发送时候如何自定义切换指定redis库下标SpringBoot 1.X之前的版本123JedisConnectionFactory jedisConnectionFactory = (JedisConnectionFactory) stringRedisTemplate.getConnectionFactory();jedisConnectionFactory.setDatabase(切换到指定的db上);stringRedisTemplate.setConnectionFactory(jedisConnectionFactory); SpringBoot 2.X之后的版本，RedisConnectionFactory动态切换库必须是LettuceConnectionFactory，必须是配置RedisTemplate时候指定，下面看源码。 1234567891011121314151617public class RedisUtil &#123; /** * 切换redis数据库 * * @param redisTemplate springboot封装的redis对象 * @param index 数据库下标 */ public static void select(RedisTemplate redisTemplate, int index) &#123; LettuceConnectionFactory lettuceConnectionFactory = (LettuceConnectionFactory) redisTemplate.getConnectionFactory(); if (lettuceConnectionFactory != null) &#123; lettuceConnectionFactory.setDatabase(index); redisTemplate.setConnectionFactory(lettuceConnectionFactory); lettuceConnectionFactory.resetConnection(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @author caochikai * @date 2019/7/12 * Redis 配置类 */@EnableCaching@Configuration@AllArgsConstructor@AutoConfigureBefore(RedisAutoConfiguration.class)public class RedisTemplateConfig &#123;//@AllArgsConstructor是构造器注入进来LettuceConnectionFactory private final LettuceConnectionFactory lcfactory; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate() &#123; // 关闭共享链接，动态切换的重点在这里 **lcfactory.setShareNativeConnection(false);** RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); redisTemplate.setHashValueSerializer(new JdkSerializationRedisSerializer()); redisTemplate.setConnectionFactory(lcfactory); return redisTemplate; &#125; @Bean public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForHash(); &#125; @Bean public ValueOperations&lt;String, String&gt; valueOperations(RedisTemplate&lt;String, String&gt; redisTemplate) &#123; return redisTemplate.opsForValue(); &#125; @Bean public ListOperations&lt;String, Object&gt; listOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForList(); &#125; @Bean public SetOperations&lt;String, Object&gt; setOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForSet(); &#125; @Bean public ZSetOperations&lt;String, Object&gt; zSetOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForZSet(); &#125;&#125; 六、设置缓存时候技巧 key需要指定key命名规则前缀RedisConstant.NOTIFY_RECEIVE常量（通常取表名），随后加上表的主键。时间计算间距小技巧，博主业务使用的是LocalDateTime，Duration.between(LocalDateTime.now(), 指定发送时间).getSeconds()，过期时间单位使用的是TimeUnit枚举。切换到指定一号库后，记得切换回来零号库，减少对其他业务的影响 12345678910111213/** * redis缓存过期监听 * * @param sysNotifySend 定时发送消息 * @param message 消息内容 */ private void redisSetMsgKey(SysNotifySend sysNotifySend, Message message) &#123; LocalDateTime sendTime = sysNotifySend.getSendTime(); String jsonString = JSONUtil.parseObj(message).toJSONString(0); RedisUtil.select(redisTemplate, 1); redisTemplate.opsForValue().set(RedisConstant.NOTIFY_RECEIVE + sysNotifySend.getSendId(), jsonString, Duration.between(LocalDateTime.now(), sendTime).getSeconds(), TimeUnit.SECONDS); RedisUtil.select(redisTemplate, 0); &#125; 七、参考文章如下: SpringBoot2.0以上整合redis根据下标动态切换数据库 redis缓存过期策略，监听redis缓存","tags":[{"name":"Spring","slug":"Spring","permalink":"https://caochikai.github.io/tags/Spring/"}]},{"title":"Thread分析","date":"2020-03-24T10:38:39.000Z","path":"2020/03/24/Thread分析/","text":"Thread分析一、多线程实现方式 继承Thread 实现Runable 使用FutureTask 使用Executor框架 二、Thread start方法源代码分析123456789101112131415161718192021222324252627282930313233343536/****start方法调用了start0方法，start0方法在JVM中，start0中的逻辑会调用run方法**。***一旦线程开始执行，jvm就会调用run方法；** ***线程只能启动一次，结束后无法重启。** * @exception IllegalThreadStateException if the thread was already * started. * @see #run() * @see #stop() */ public synchronized void start() &#123; /** * 0代表线程状态为NEW * A zero status value corresponds to state \"NEW\". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* 通知组该线程即将开始将其添加到组的线程列表*中，并且该组的未启动计数可以减少。/ group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123;//如果创建失败，线程数组将会删除该线程，未启动计数增加，具体看源码 group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* 什么都不用做，直接被上层堆栈回调 */ &#125; &#125; &#125;//start0是一个native方法 private native void start0(); 三、线程状态分析(6种)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/**在同一时间只有一种状态，只能反映JVM状态却不能反映出系统状态。 * * @since 1.5 * @see #getState */ public enum State &#123; /****线程还未开始，刚刚新建。** * Thread state for a thread which has not yet started. */ NEW, /****可运行状态，正在Java虚拟机中执行，但可能正在等待来自操作系统的其他资源，例如处理器。** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /****阻塞状态。等待锁资源进入同步代码块。** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * &#123;@link Object#wait() Object.wait&#125;. */ BLOCKED, /****等待状态。可能因为如下方法进入该状态：** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul&gt; * &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt; * &lt;/ul&gt; *下面例子很形象 * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt; * on an object is waiting for another thread to call * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt; * is waiting for a specified thread to terminate. */ WAITING, /****等待一定的时间状态。可能因为如下方法进入该状态：** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul&gt; * &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt; * &lt;/ul&gt; */ TIMED_WAITING, /****结束状态。** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; &#125; 四、最后Thread Run方法分析(模版方法模式) Runnable的实现对象通过构造函数传入Thread。 123public Thread(Runnable target) &#123; init(null, target, \"Thread-\" + nextThreadNum(), 0);&#125; Runnable实现作为target对象传递进来。再次调用了init方法。Thread的target被设置为你实现业务逻辑的Runnable实现。 1234567private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals)&#123;...省略其他过程 this.target = target;&#125; 当你传入了target，则会执行target的run方法。 @Override public void run() { if (target != null) { target.run(); } }","tags":[]},{"title":"数据结构之稀疏数组","date":"2020-03-21T08:48:00.000Z","path":"2020/03/21/数据结构之稀疏数组/","text":"数据结构之稀疏数组一、简介 稀疏数组可以简单的看作为是压缩，在开发中也会使用到。比如将数据序列化到磁盘上，减少数据量，在IO过程中提高效率等等。 二、压缩和恢复——稀疏数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * @Description: 稀疏数组 ---&gt; 数组中有很多无效数据，压缩数据 * @Author: Caochikai */public class SparseArrayMy &#123; /** * 先初始化11 X 11 的二维数组代表棋盘，转化为稀疏数组的思路： * 1、先遍历二维数组 得到非0数据的有效个数sum * 2、根据sum有效个数创建对应的稀疏数组int[sum+1][3] * 3、一次读取有效A的位置x，y和值，存进稀疏数组 * * @param args */ public static void main(String[] args) &#123; // 创建一个原始的二维数组 11 * 11 // 0: 表示没有棋子， 1 表示 黑子 2 表蓝子 int chessArr1[][] = new int[11][11]; chessArr1[1][2] = 1; chessArr1[2][3] = 2; chessArr1[4][5] = 2; // 输出原始的二维数组 System.out.println(\"原始的二维数组~~\"); for (int[] row : chessArr1) &#123; for (int data : row) &#123; System.out.printf(\"%d\\t\", data); &#125; System.out.println(); &#125; // 1、先遍历二维数组 得到非0数据的有效个数sum int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; sum++; &#125; &#125; &#125; System.out.println(\"二维数组的有效个数sum = \" + sum); //2、根据sum有效个数创建对应的稀疏数组int[sum+1][3] int sparseArr[][] = new int[sum + 1][3]; //第一行按稀疏数组定义记录总行数、总列数、个数总数 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; // 3、一次读取有效A的位置x，y和值，存进稀疏数组 int index = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; index++; sparseArr[index][0] = i; sparseArr[index][1] = j; sparseArr[index][2] = chessArr1[i][j]; &#125; &#125; &#125; for (int[] ints : sparseArr) &#123; for (int anInt : ints) &#123; System.out.printf(\"%d\\t\", anInt); &#125; System.out.println(); &#125; /* * 将稀疏数组恢复成二维数组思路： * 1、更具第一行的x，y创建二维数组 * 2、遍历1到sum行，取得A有效数值的对应x，y，将值A存进对应二维数组位置 * */ int[][] oldArray = new int[sparseArr[0][0]][sparseArr[0][1]]; for (int i = 1; i &lt;= sparseArr[0][2]; i++) &#123; int x = sparseArr[i][0]; int y = sparseArr[i][1]; oldArray[x][y] = sparseArr[i][2]; &#125; // 输出恢复后的二维数组 System.out.println(); System.out.println(\"恢复后的二维数组\"); for (int[] ints : oldArray) &#123; for (int anInt : ints) &#123; System.out.printf(\"%d\\t\", anInt); &#125; System.out.println(); &#125; &#125;&#125; 三、输出结果1234567891011121314151617181920212223242526272829303132原始的二维数组~~0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 二维数组的有效个数sum = 311 11 3 1 2 1 2 3 2 4 5 2 恢复后的二维数组0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Process finished with exit code 0","tags":[]},{"title":"Web协议详解与抓包实战简记","date":"2019-12-31T08:45:34.000Z","path":"2019/12/31/Web协议详解与抓包实战简记/","text":"notion链接——Web协议详解简记","tags":[]},{"title":"Sublime 配置记录","date":"2019-12-29T03:07:00.000Z","path":"2019/12/29/Sublime-配置记录/","text":"Sublime 配置 多行批量修改数据的必备工具，也是前端最喜欢的文本编辑器之一。下面快捷键配置推荐收藏。 [SFTP 插件] 配置文件 Demo12345678910111213141516&#123; \"host\": \"jinghanco.com\", \"user\": \"root\", \"password\": \"***\", \"port\": \"21\", \"remote_path\": \"/jinghan_web/...\", \"ignore_regexes\": [ \"\\\\.sublime-(project|workspace)\", \"sftp-config(-alt\\\\d?)?\\\\.json\", \"sftp-settings\\\\.json\", \"/venv/\", \"\\\\.svn/\", \"\\\\.hg/\", \"\\\\.git/\", \"\\\\.bzr\", \"_darcs\", \"CVS\", \"\\\\.DS_Store\", \"Thumbs\\\\.db\", \"desktop\\\\.ini\", \"/Runtime/\", \"\\\\/Upload\", \"\\\\.backup\", \"\\\\.save\", \"\\\\.copy\", \"\\\\.test.php\", \".gitignore\", \"index.php\" ],&#125; [Sublime] 用户配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&#123; \"always_show_minimap_viewport\": false, \"auto_complete_commit_on_tab\": false, \"auto_find_in_selection\": true, \"auto_match_enabled\": true, \"bold_folder_labels\": true, \"caret_style\": \"phase\", \"close_windows_when_empty\": false, // \"color_scheme\": \"Packages/Color Scheme - Default/Monokai.tmTheme\", \"default_encoding\": \"UTF-8\", \"default_line_ending\": \"unix\", \"detect_indentation\": true, \"drag_text\": true, \"draw_minimap_border\": true, \"ensure_newline_at_eof_on_save\": true, \"fallback_encoding\": \"UTF-8\", \"font_family\": \"consolas\", \"font_size\": 11, \"highlight_line\": true, \"highlight_modified_tabs\": true, \"ignored_packages\": [ \"ColorPicker\", \"ConvertToUTF8\", \"CSS Extended Completions\", \"DocBlockr\", \"git\", \"Makefile\", \"Markdown Preview\", \"MarkdownEditing\", \"Phpcs\", \"Quick File Move\", \"SideBarEnhancements\", \"Vintage\", \"Vintageous\" ], \"indent_guide_options\": [ \"draw_active\", \"draw_normal\" ], \"indent_to_bracket\": true, \"line_padding_bottom\": 1, \"line_padding_top\": 1, \"match_brackets\": true, \"match_brackets_angle\": true, \"match_brackets_braces\": false, \"match_tags\": true, \"preview_on_click\": true, \"rulers\": [ 80, 120 ], \"scroll_past_end\": true, \"shift_tab_unindent\": true, \"show_encoding\": true, \"show_line_endings\": true, \"show_tab_close_buttons\": false, \"tab_size\": 4, // \"theme\": \"SoDaReloaded Dark.sublime-theme\", \"translate_spaces_to_tabs\": false, \"translate_tabs_to_spaces\": true, \"tree_animation_enabled\": true, \"trim_automatic_white_space\": true, \"trim_trailing_white_space_on_save\": true, \"word_wrap\": false, \"wrap_width\": 0&#125; [Sublime] 快捷键配置1234567891011121314151617181920212223242526[ // 保存所有文件 &#123; \"keys\": [\"ctrl+shift+s\"], \"command\": \"save_all\" &#125;, // 下一个视图 &#123; \"keys\": [\"ctrl+tab\"], \"command\": \"next_view\" &#125;, // 上一个视图 &#123; \"keys\": [\"ctrl+shift+tab\"], \"command\": \"prev_view\" &#125;, // 变为大写 &#123; \"keys\": [\"alt+a\"], \"command\": \"upper_case\" &#125;, // 变为小写 &#123; \"keys\": [\"alt+s\"], \"command\": \"lower_case\" &#125;, // 复制行 &#123; \"keys\": [\"ctrl+shift+d\"], \"command\": \"duplicate_line\" &#125;, // 选择下一个相同的被选字符 &#123; \"keys\": [\"ctrl+d\"], \"command\": \"find_under_expand\" &#125;, // 跳过选择 &#123; \"keys\": [\"ctrl+k\", \"ctrl+d\"], \"command\": \"find_under_expand_skip\" &#125;, // 显示隐藏 &#123; \"keys\": [\"alt+x\"/*, \"alt+z\"*/], \"command\": \"toggle_side_bar\" &#125;, // 快速打开hosts文件 &#123; \"keys\": [\"ctrl+alt+h\"], \"command\": \"prompt_open_file C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts\"&#125;, &#123; \"keys\": [\"ctrl+alt+j\"], \"command\": \"js_format\", \"context\": [&#123;\"key\": \"selector\", \"operator\": \"equal\", \"operand\": \"source.js,source.json\"&#125;] &#125;]","tags":[{"name":"tool","slug":"tool","permalink":"https://caochikai.github.io/tags/tool/"}]},{"title":"maven公共仓库推荐配置","date":"2019-12-28T09:34:00.000Z","path":"2019/12/28/maven公共仓库推荐配置/","text":"maven公共仓库推荐配置 maven公共仓库毕竟是在国外，所以使用maven默认配置仓库地址，下载网络可能就几十KB。推荐在公司里面搭建一个nexus私服仓库，因为有些jar随着时间变化（特别是老项目），maven公服都会丢失，最惨的是莫过于在GitHub项目都没有了。下面是我个人对关于maven仓库配置的一点不成熟建议，为了配合IDEA和命令行，idea已经自带maven，且maven与idea版本做了适配的，通常情况下不建议单独另外下载maven；web项目通常分为三种，第一种常见的maven项目（pom.xml），第二种普通的WebRoot项目，第三种gradle（强大，题外话）。如果贵司有私服那建议maven项目，没有那就推荐WebRoot集成第三方库web-inf/lib。毕竟随着时间流逝，很多第三方库会被淘汰或者维护开发者已经消失在业界。 在onedriver或者云盘里，放置自己常用的开发工具，maven有个config文件夹，下面有个setting.xml，里面有 个mirror的标签，替换掉，IDE环境需要在idea配置maven指定setting地址（建议走下面默认配置，无需改动），项目的部分依赖包在webapp/web-inf/lib下！ 默认推荐：在win系统开发环境下，本地仓库默认在C:\\Users\\cao.m2下repository，建议配置在固态硬盘，把下面推荐mirrors标签配置替换maven/config/settings.xml后直接放置在C:\\Users\\cao.m2（系统当前用户目录）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;&lt;http://maven.aliyun.com/nexus/content/groups/public/&gt;&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;url&gt;&lt;http://repo1.maven.org/maven2/&gt;&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;&lt;http://repo2.maven.org/maven2/&gt;&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;ibiblio&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;&lt;http://mirrors.ibiblio.org/pub/mirrors/maven2/&gt;&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;jboss-public-repository-group&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;JBoss Public Repository Group&lt;/name&gt; &lt;url&gt;&lt;http://repository.jboss.org/nexus/content/groups/public&gt;&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;google&lt;/id&gt; &lt;name&gt;google maven&lt;/name&gt; &lt;url&gt;&lt;https://maven.google.com/&gt;&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;!-- 中央仓库在中国的镜像 --&gt; &lt;mirror&gt; &lt;id&gt;maven.net.cn&lt;/id&gt; &lt;name&gt;oneof the central mirrors in china&lt;/name&gt; &lt;url&gt;&lt;http://maven.net.cn/content/groups/public/&gt;&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt;","tags":[{"name":"maven","slug":"maven","permalink":"https://caochikai.github.io/tags/maven/"}]},{"title":"Mybatis技术内幕源码解析：缓存模块","date":"2019-12-27T14:06:00.000Z","path":"2019/12/27/Mybatis技术内幕源码解析：缓存模块/","text":"2.9、缓存模块 在Mybatis中，最常听见的就是mybatis的查询一二级缓存，本质都是org.apache.ibatis.cache缓存模块下Cache的实现。本文主要是对Cache接口以及实现类进行结束，并涉及到了装饰器模式。该接口实现类众多，只有PerpetualCache提供了Cache接口的基本实现，下面分析Cache接口后，接着PerpetualCache（超级简单）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package org.apache.ibatis.cache;import java.util.concurrent.locks.ReadWriteLock;/**缓存服务发现 * SPI(service provider interface) for cache providers. * &lt;p&gt;一个缓存实例对应着一个namespace命名空间 * One instance of cache will be created for each namespace. * &lt;p&gt; * The cache implementation must have a constructor that receives the cache id as an String parameter.. */public interface Cache &#123; /**缓存对象的唯一ID * @return The identifier of this cache */ String getId(); /**向缓存里添加数据，key通常是CacheKey，value是查询的结果 * @param key Can be any object but usually it is a &#123;@link CacheKey&#125; * @param value The result of a select. */ void putObject(Object key, Object value); /**根据key获取相应的缓存结果 * @param key The key * @return The object stored in the cache. */ Object getObject(Object key); /**从3.3.0开始在回滚rollback期间缓存的值可能会缓存丢失命中， * 为了防止缓存穿透直接命中数据库，可以往key先放null值（会上锁），设置上后就会释放锁。 * As of 3.3.0 this method is only called during a rollback * for any previous value that was missing in the cache. * This lets any blocking cache to release the lock that * may have previously put on the key. * A blocking cache puts a lock when a value is null * and releases it when the value is back again. * This way other threads will wait for the value to be * available instead of hitting the database. */ Object removeObject(Object key); /**清空缓存 * Clears this cache instance. */ void clear(); /**可选实现，因为mybatis核心根本不会使用该方法 * Optional. This method is not called by the core. *返回其元素个数，而不是容器总大小 * @return The number of elements stored in the cache (not its capacity). */ int getSize(); /**可选实现，从 3.2.6版本开始核心方法不再会使用改方法getReadWriteLock * Optional. As of 3.2.6 this method is no longer called by the core. * &lt;p&gt;缓存所需的任何锁都必须​​由缓存提供内部实现 * Any locking needed by the cache must be provided internally by the cache provider. */ default ReadWriteLock getReadWriteLock() &#123; return null; &#125;&#125;package org.apache.ibatis.cache.impl;import ... public class PerpetualCache implements Cache &#123;//缓存对象的唯一id private final String id;//用于记录缓存的容器 private Map&lt;Object, Object&gt; cache = new HashMap&lt;&gt;(); public PerpetualCache(String id) &#123; this.id = id; &#125;//下面记录所有的方法都来自Map对象的相应方法 @Override public String getId() &#123; return id; &#125; ...&#125; org.apache.ibatis.cache.decorators下是装饰器实现，以BlockingCache举例，支持阻塞版本的缓存装饰器，它通过ReentrantLock保证只有一个线程到数据库中查找指定的key对应的数据。可以从putObject和getObject方法入手，下面在源码里了解其具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package org.apache.ibatis.cache.decorators;import .../**简单阻塞版本的缓存装饰器 * Simple blocking decorator *简单而高效版本的EhCache阻塞装饰器，当找不到该缓存就会在key上锁 * Simple and inefficient version of EhCache's BlockingCache decorator. * It sets a lock over a cache key when the element is not found in cache. * This way, other threads will wait until this element is filled instead of hitting the database. *这样，其他线程将等待直到该元素被填充，而不是直接命中访问数据库。 */public class BlockingCache implements Cache &#123;//阻塞超时时长 private long timeout;//被装饰的底层对象 private final Cache delegate;//线程安全的ConcurrentHashMap，每个key都有个重入锁ReentrantLock private final ConcurrentHashMap&lt;Object, ReentrantLock&gt; locks;...省略构造器和一些属性geter\\setter//当查出该值放入该key下，就会释放该线程之前持有的锁 @Override public void putObject(Object key, Object value) &#123; try &#123; delegate.putObject(key, value); &#125; finally &#123; releaseLock(key); &#125; &#125; @Override public Object getObject(Object key) &#123;//获取key对应的锁 acquireLock(key);//获取key对应的缓存项 Object value = delegate.getObject(key); if (value != null) &#123;//释放改key持有的锁 releaseLock(key); &#125; return value; &#125; @Override public Object removeObject(Object key) &#123; // 这个方法虽然名字长成这样，但是依然还是只会调用releaseLock方法 releaseLock(key); return null; &#125; private ReentrantLock getLockForKey(Object key) &#123; return locks.computeIfAbsent(key, k -&gt; new ReentrantLock()); &#125; private void acquireLock(Object key) &#123;//如果没有没有锁就创建 Lock lock = getLockForKey(key); if (timeout &gt; 0) &#123; try &#123;//在指定timeout时间内尝试获取锁，false代表超时 boolean acquired = lock.tryLock(timeout, TimeUnit.MILLISECONDS); if (!acquired) &#123; throw new CacheException(\"Couldn't get a lock in \" + timeout + \" for the key \" + key + \" at the cache \" + delegate.getId()); &#125; &#125; catch (InterruptedException e) &#123; throw new CacheException(\"Got interrupted while trying to acquire lock for key \" + key, e); &#125; &#125; else &#123;//获取锁，不带超时时间 lock.lock(); &#125; &#125; private void releaseLock(Object key) &#123;//从缓存锁的集合中获取指定key对应的锁 ReentrantLock lock = locks.get(key);//判断该锁是否被该线程持有 if (lock.isHeldByCurrentThread()) &#123; lock.unlock();//那就释放掉，其他线程才能进行其他操作 &#125; &#125;&#125; FifoCache&amp;LruCache 上面提到那么多Cache接口实现类，有什么用处呢？在很多场景中，比如为了控制缓存的大小，系统需要通过一定策略清理缓存。FifoCache（Fist in，Fist Oout）是先入先出策略，当向缓存添加数据时，通过设置缓存项的个数上限控制进行清理的阈值。LruCache是最近最少使用（Least Recently Used，LRU）策略，在需要清理缓存时，它会清除最近最少使用的缓存项。下面简略介绍一些比较重要的核心代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/**先入先出 * FIFO (first in, first out) cache decorator. */public class FifoCache implements Cache &#123;//底层被装饰的缓存对象 private final Cache delegate;//通过队列数据结构记录顺序，实际是LinkedList&lt;object&gt;类型的集合对象 private final Deque&lt;Object&gt; keyList;//缓存项的个数上限清理动作的阈值 private int size;...省略setter/getter @Override public void putObject(Object key, Object value) &#123;//检测是否到达阈值，并清理缓存 cycleKeyList(key); delegate.putObject(key, value); &#125; private void cycleKeyList(Object key) &#123;//先记录该缓存 keyList.addLast(key);//判断是达到上限 if (keyList.size() &gt; size) &#123;//清理最老的（排在队头的） Object oldestKey = keyList.removeFirst(); delegate.removeObject(oldestKey); &#125; &#125;&#125;/**最近最少使用 * Lru (least recently used) cache decorator. */public class LruCache implements Cache &#123;//底层被装饰的缓存对象 private final Cache delegate;//实际LinkedHashMap&lt;object，object&gt;类型对象，用于记录key最近的使用情况 private Map&lt;Object, Object&gt; keyMap;//记录最少使用的key private Object eldestKey; public LruCache(Cache delegate) &#123; this.delegate = delegate;//默认大小为1024 setSize(1024); &#125;...省略setter/getter public void setSize(final int size) &#123;//第三个参数控制是否记录其顺序，LinkedHashMap.get方法会改变其顺序（把该节点往最后位置放move node to last） keyMap = new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) &#123;//重写removeEldestEntry最终会被其put方法调用到 @Override protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) &#123;//如果达到缓存上限则更新eldestKey boolean tooBig = size() &gt; size; if (tooBig) &#123; eldestKey = eldest.getKey(); &#125; return tooBig; &#125; &#125;; &#125; @Override public void putObject(Object key, Object value) &#123;//添加缓存项后删除最久未使用项 delegate.putObject(key, value); cycleKeyList(key); &#125; @Override public Object getObject(Object key) &#123; keyMap.get(key); //touch触发LinkedHashMap记录排序 return delegate.getObject(key); &#125; private void cycleKeyList(Object key) &#123; keyMap.put(key, key);//eldestKey不是空代表到了上限，那就执行删除removeObject if (eldestKey != null) &#123; delegate.removeObject(eldestKey); eldestKey = null; &#125; &#125;&#125; SoftCache&amp;WeakCache 这两个缓存实现主要应用场景在不重要且方便GC的需求下，这就不得不提及java的四种引用类型。下面引用从强到弱依次排列介绍： 强引用（Strong Reference）：最常见就是new对象被强引用，GC是不能绝不会回收该类型对象，当然引用类型会变化，并非一成不变。 软引用（Soft Reference）：当JVM内存不足时候，软引用指向的对象会被释放，需要通过Reference.get方法返回值，判断是否对象是否存活。 引用队列（ReferenceQueue）：在创建 SoftReference对象时，当被GC回收时，JVM就会将该SoftReference对象添加到关联的引用队列中。当需要检测时，就可以从引用队列中获取这些SoftReference对象。可参考java.util.WeakHashMap的代码。 弱引用（Weak Reference）：在发生GC检查到该对象的引用类型全是weak reference，就会被回收；参考java.util.WeakHashMap。 幽灵引用（Phantom Reference）：小名（虚引用），必须指定引用队列才能使用，当GC发生回收该引用对象会通知到该队列，作为Object.finalize()被废弃后的代替解决方案。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * Soft Reference cache decorator */public class SoftCache implements Cache &#123;//该队列的缓存对象属于都有强引用存在，代表该部分缓存不会被回收 private final Deque&lt;Object&gt; hardLinksToAvoidGarbageCollection;//ReferenceQueue引用队列，记录被GC回收的缓存项（SoftEntry对象） private final ReferenceQueue&lt;Object&gt; queueOfGarbageCollectedEntries; private final Cache delegate;//强引用的数量，默认是256 private int numberOfHardLinks; public SoftCache(Cache delegate) &#123; this.delegate = delegate;//初始化成员 this.numberOfHardLinks = 256; this.hardLinksToAvoidGarbageCollection = new LinkedList&lt;&gt;(); this.queueOfGarbageCollectedEntries = new ReferenceQueue&lt;&gt;(); &#125;...省略setter/getter和简单方法 @Override public void putObject(Object key, Object value) &#123;//清除已被GC的缓存 removeGarbageCollectedItems();//添加新的缓存 delegate.putObject(key, new SoftEntry(key, value, queueOfGarbageCollectedEntries)); &#125; @Override public Object getObject(Object key) &#123; Object result = null; @SuppressWarnings(\"unchecked\") // assumed delegate cache is totally managed by this cache SoftReference&lt;Object&gt; softReference = (SoftReference&lt;Object&gt;) delegate.getObject(key);//检查是否有缓存项 if (softReference != null) &#123; result = softReference.get();//已经被GC回收了 if (result == null) &#123;//从缓存也删除，与GC同步 delegate.removeObject(key); &#125; else &#123; //修改不仅仅需要读锁（那就是写锁也要） See #586 (and #335) modifications need more than a read lock synchronized (hardLinksToAvoidGarbageCollection) &#123;//重复获取证明属于强引用，记录到hardLinksToAvoidGarbageCollection hardLinksToAvoidGarbageCollection.addFirst(result);//类似先进先出，到达阈值清空老的 if (hardLinksToAvoidGarbageCollection.size() &gt; numberOfHardLinks) &#123; hardLinksToAvoidGarbageCollection.removeLast(); &#125; &#125; &#125; &#125; return result; &#125; @Override public void clear() &#123;//先清空强引用该集合 synchronized (hardLinksToAvoidGarbageCollection) &#123; hardLinksToAvoidGarbageCollection.clear(); &#125;//再清空被GC回收的缓存项 removeGarbageCollectedItems();//清理底层缓存 delegate.clear(); &#125; private void removeGarbageCollectedItems() &#123; SoftEntry sv;//遍历queueOfGarbageCollectedEntries集合 while ((sv = (SoftEntry) queueOfGarbageCollectedEntries.poll()) != null) &#123;//将已被GC的缓存也清除了（与GC同步） delegate.removeObject(sv.key); &#125; &#125; private static class SoftEntry extends SoftReference&lt;Object&gt; &#123; private final Object key; SoftEntry(Object key, Object value, ReferenceQueue&lt;Object&gt; garbageCollectionQueue) &#123;//指向value的是软引用，且关联了队列garbageCollectionQueue super(value, garbageCollectionQueue);//强引用 this.key = key; &#125; &#125;&#125; ScheduledCache&amp;LoggingCache&amp;SynchronizedCache&amp;CacheSerializedCache 最后提一下剩下的几个缓存装饰器，ScheduledCache看名字就知道是周期计划行清空缓存，默认是一小时；LoggingCache是带日志功能的缓存，主要用来统计缓存命中次数和访问次数，以及输出指定的格式；SynchronizedCache添加了同步功能，通过在每个方法上添加synchronized；CacheSerializedCache提供添加针对value进行序列化后byte[]存入缓存，而获取就对byte[]进行反序列化（一个全新对象），使用的是jdk原生序列化。 2.9.3 CacheKey 这个key有点复杂啊，key可能不仅仅是个String，通过CacheKey就添加多个对象updateList影响缓存项key的唯一性。updateList包含MappedStatement的id、指定查询结果集的范围——RowBounds.offset和RowBounds.limit、查询所使用的SQL语句、该SQL语句的实际参数值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package org.apache.ibatis.cache;import ...public class CacheKey implements Cloneable, Serializable &#123; private static final int DEFAULT_MULTIPLIER = 37; private static final int DEFAULT_HASHCODE = 17;//参与计算的hashcode，默认是DEFAULT_MULTIPLIER private final int multiplier;//CacheKey对象的hashcode，默认是DEFAULT_HASHCODE private int hashcode;//校验和 private long checksum;//updateList集合个数 private int count;//由该集合中的所有对象共同决定两个CacheKey是否相同 private List&lt;Object&gt; updateList; public CacheKey() &#123; this.hashcode = DEFAULT_HASHCODE; this.multiplier = DEFAULT_MULTIPLIER; this.count = 0; this.updateList = new ArrayList&lt;&gt;(); &#125;...省略setter/getter和简单方法 public void update(Object object) &#123;//根据不同类型获取其baseHashCode int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); count++; checksum += baseHashCode; baseHashCode *= count;//重新计算hashcode hashcode = multiplier * hashcode + baseHashCode; updateList.add(object); &#125; public void updateAll(Object[] objects) &#123; for (Object o : objects) &#123; update(o); &#125; &#125;//重写equals @Override public boolean equals(Object object) &#123; if (this == object) &#123; return true; &#125; if (!(object instanceof CacheKey)) &#123; return false; &#125; final CacheKey cacheKey = (CacheKey) object;//比较hashcode、checksum、count if (hashcode != cacheKey.hashcode) &#123; return false; &#125; if (checksum != cacheKey.checksum) &#123; return false; &#125; if (count != cacheKey.count) &#123; return false; &#125;//比较updateList每一项 for (int i = 0; i &lt; updateList.size(); i++) &#123; Object thisObject = updateList.get(i); Object thatObject = cacheKey.updateList.get(i); if (!ArrayUtil.equals(thisObject, thatObject)) &#123; return false; &#125; &#125; return true; &#125;&#125; ```","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochikai.github.io/tags/Mybatis/"}]},{"title":"Mybatis技术内幕源码解析：参数和结果集处理","date":"2019-12-26T10:28:00.000Z","path":"2019/12/26/Mybatis技术内幕源码解析：参数和结果集处理/","text":"2.8、binding 模块 org.apache.ibatis.binding模块是为了解决Mapper类接口和对应Xml配置文件之间映射，通常Mapper接口定义了SQL语句对应的方法，而xml里面配置了对应的SQL语句，所以在Mybatis初始化的时候编译器会检查配置Mapper和xml，并关联起来。特别在参数处理那块非常复杂，需要给位看官的耐心分析，下面就要先从核心组件关系入手： upload successful 2.8.1 MapperRegistry&amp;MapperProxyFactory XXXRegistry看后缀命名风格就知道又是个注册类，MapperRegistry是Mapper接口及其对应的代理对象工厂的注册中心。Configuration是MyBatis 全局性的配置对象，在MyBatis初始化的过程中，所有配置信息会被解析成相应的对象并记录到Configuration对象中，后面介绍MyBatis初始化过程时会详细介绍Configuration。我重点要关注Configuration.mapperRegistry属性，它记录当前使用的MapperRegistry对象，下面就让就进行源码导读： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package org.apache.ibatis.binding;import ...public class MapperRegistry &#123;//Configuration对象全局唯一的配置对象，包含所有的配置信息 private final Configuration config;//记录Mapper接口与MapperProxyFactory之间的对应关系,//key为Mapper接口Class，value对应的代理工厂对象MapperProxyFactory private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;(); public MapperRegistry(Configuration config) &#123; this.config = config; &#125;//通过Class type获取MapperProxyFactory工厂对象 public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) &#123; throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\"); &#125; try &#123;//传入sqlSession为Mapper接口创建jdk动态代理对象，下面会详细分析mapperProxyFactory创建过程 return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e); &#125; &#125;//Class类型判断knownMappers是否存在该Mapper接口 public &lt;T&gt; boolean hasMapper(Class&lt;T&gt; type) &#123; return knownMappers.containsKey(type); &#125;//加载完配置文件和类上注解，将解析的mapper接口通过addMapper方法添加到MapperRegistry.knownMappers, public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;//判断是否是接口 if (type.isInterface()) &#123;//检查是否已经存在，避免重复读取 if (hasMapper(type)) &#123; throw new BindingException(\"Type \" + type + \" is already known to the MapperRegistry.\"); &#125;//标志是否完成load加载 boolean loadCompleted = false; try &#123;//将Mapper接口对应的Class对象和MapperproxyFactory对象添加到knownMappers集合 knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type)); // It's important that the type is added before the parser is run // otherwise the binding may automatically be attempted by the // mapper parser. If the type is already known, it won't try.//这个涉及到xml解析和注解方面的处理，后面再详细解答 MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type); parser.parse(); loadCompleted = true; &#125; finally &#123; if (!loadCompleted) &#123; knownMappers.remove(type); &#125; &#125; &#125; &#125; /**通过knownMappers获取Class集合，该集合为不可变容器unmodifiableCollection，避免被修改只能被读取 * @since 3.2.2 */ public Collection&lt;Class&lt;?&gt;&gt; getMappers() &#123; return Collections.unmodifiableCollection(knownMappers.keySet()); &#125; /**通过包名路径读取指定superType父类的mapper（包扫描） * @since 3.2.2 */ public void addMappers(String packageName, Class&lt;?&gt; superType) &#123; ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(superType), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses(); for (Class&lt;?&gt; mapperClass : mapperSet) &#123; addMapper(mapperClass); &#125; &#125; //...addMappers重载&#125;package org.apache.ibatis.binding;import ...public class MapperProxyFactory&lt;T&gt; &#123;//当前MapperProxyFactory工厂对应的产品mapperInterface接口//换而言之就是一个工厂只能生产一种产品 private final Class&lt;T&gt; mapperInterface;//该mapperInterface接口下对应的方法集合，key为java.lang.reflect.Method，value为MapperMethod对象 private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;&gt;();//...geter/setter方法和构造器 @SuppressWarnings(\"unchecked\") protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy); &#125;//创建实现了mapperInterface接口的代理对象 public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); &#125;&#125; 2.8.2 MapperProxy代理 MapperProxy实现了InvocationHandler接口，接口实现方法就是JDK动态代理的核心方法逻辑，下面认真分析针对mapper代理逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package org.apache.ibatis.binding;import ...public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable &#123;//java.lang.invoke.MethodHandles.Lookup是被允许访问的成员类型（访问权限修饰符） private static final int ALLOWED_MODES = MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC;//动态代理Constructor private static final Constructor&lt;Lookup&gt; lookupConstructor;//私有访问类型的方法 private static final Method privateLookupInMethod;//全局引用的sqlSession对象 private final SqlSession sqlSession;//接口对应的Class对象 private final Class&lt;T&gt; mapperInterface;//methodCache缓存方法集合key为Method对象，value为对应的MapperMethod private final Map&lt;Method, MapperMethod&gt; methodCache;//...省略构造器 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123;//如果目标方法继承自object，则直接调用目标方法 if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, args); &#125; else if (method.isDefault()) &#123;//是否的默认方法（public non-abstract） if (privateLookupInMethod == null) &#123;//针对jdk8版本默认方法处理 return invokeDefaultMethodJava8(proxy, method, args); &#125; else &#123;//针对jdk9版本默认方法处理 return invokeDefaultMethodJava9(proxy, method, args); &#125; &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125;//优先在缓存中获取，如果没有就new一个，具体看下面cachedMapperMethod方法 final MapperMethod mapperMethod = cachedMapperMethod(method); return mapperMethod.execute(sqlSession, args); &#125;//新版本的mybatis private MapperMethod cachedMapperMethod(Method method) &#123; return methodCache.computeIfAbsent(method, k -&gt; new MapperMethod(mapperInterface, method, sqlSession.getConfiguration())); &#125;//...省略方法invokeDefaultMethodJava8和invokeDefaultMethodJava9&#125; 2.8.3 MapperMethod MapperMethod封装了接口中对应的方法的元信息，以及对应的SQL语句，与开发者息息相关。另一个比较重要的SqlCommand是MapperMethod中定义的内部类，它使用name字段记录了SQL语句的名称，使用type字段（SqlCommandType类型）记录了SQL语句的类型。SqlCommandType是枚举类型，有效取值为UNKNOWN、INSERT、UPDATE、DELETE、SELECT、FLUSH。MapperMethod源码比较复杂，先分析MapperMethod字段信息，后面会拆分SqlCommand、MethodSignature和ParamNameResolver分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273declaringClasspackage org.apache.ibatis.binding;import ...public class MapperMethod &#123;//SqlCommand记录SQL语句的名称和类型 private final SqlCommand command;//Mapper接口中的方法签名和相关信息，MethodSignature也是MapperMethod的内部类 private final MethodSignature method; public MapperMethod(Class&lt;?&gt; mapperInterface, Method method, Configuration config) &#123; this.command = new SqlCommand(config, mapperInterface, method); this.method = new MethodSignature(config, mapperInterface, method); &#125; public static class SqlCommand &#123;//SQL语句的名称 private final String name;//SqlCommandType枚举类型：UNKNOWN、INSERT、UPDATE、DELETE、SELECT、FLUSH private final SqlCommandType type; public SqlCommand(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123;//初步是先获取方法名称 final String methodName = method.getName();//方法的Method.clazz属性，主要用来判断是否为父接口信息 final Class&lt;?&gt; declaringClass = method.getDeclaringClass(); MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass, configuration);//检查MappedStatement是否创建成功 if (ms == null) &#123;//处理@Flush注解 if (method.getAnnotation(Flush.class) != null) &#123; name = null; type = SqlCommandType.FLUSH; &#125; else &#123; throw new BindingException(\"Invalid bound statement (not found): \" + mapperInterface.getName() + \".\" + methodName); &#125; &#125; else &#123;//初始化name和type name = ms.getId(); type = ms.getSqlCommandType(); if (type == SqlCommandType.UNKNOWN) &#123; throw new BindingException(\"Unknown execution method for: \" + name); &#125; &#125; &#125;//解析创建MappedStatement（SQL语句全部具体信息），后面再重点介绍 private MappedStatement resolveMappedStatement(Class&lt;?&gt; mapperInterface, String methodName, Class&lt;?&gt; declaringClass, Configuration configuration) &#123;//SQL语句的名称是由Mapper接口的名称与对应的方法名称组成的 String statementId = mapperInterface.getName() + \".\" + methodName;//先从Configuration.mappedStatements集合查询缓存 if (configuration.hasStatement(statementId)) &#123; return configuration.getMappedStatement(statementId); &#125; else if (mapperInterface.equals(declaringClass)) &#123;//如果没有父类接口，也没有该sql、方法记录，那就没有了 return null; &#125;//MappperMethod在父接口里面 for (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) &#123;//递归查找父接口类型是declaringClass的MappedStatement if (declaringClass.isAssignableFrom(superInterface)) &#123; MappedStatement ms = resolveMappedStatement(superInterface, methodName, declaringClass, configuration); if (ms != null) &#123; return ms; &#125; &#125; &#125; return null; &#125;//...先省略具体方法后面再分析&#125; MapperMethod另一个比较重要的内部类MethodSignature，通过ParamNameResolver处理接口方法的参数列表。ParamNameResolver的name字段（SortedMap&lt;Integer，String&gt;类型），其中key表示参数在参数列表中的索引位置，value 表示参数名称，参数名称可以通过@Param注解指定，如果没有指定@Param注解，则使用参数索引作为其名称。如果参数列表中包含RowBounds或ResultHandler类型的参数，则这两种类型的参数并不会被记录到name集合中，这就会导致参数的索引与名称不一致。下面源码导读中讲解到例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package org.apache.ibatis.reflection;import ...public class ParamNameResolver &#123;//下标值的前缀名称 private static final String GENERIC_NAME_PREFIX = \"param\"; /** * &lt;p&gt;key为index索引（区别于真实索引，换而言之为按照真正的参数args下标来） * value为参数变量名(通过) * The key is the index and the value is the name of the parameter.&lt;br /&gt; * The name is obtained from &#123;@link Param&#125; if specified. When &#123;@link Param&#125; is not specified, * the parameter index is used. Note that this index could be different from the actual index * when the method has special parameters (i.e. &#123;@link RowBounds&#125; or &#123;@link ResultHandler&#125;). * &lt;/p&gt; * &lt;ul&gt;官方的举例： * &lt;li&gt;aMethod(@Param(\"M\") int a, @Param(\"N\") int b) -&amp;gt; &#123;&#123;0, \"M\"&#125;, &#123;1, \"N\"&#125;&#125;&lt;/li&gt; * &lt;li&gt;aMethod(int a, int b) -&amp;gt; &#123;&#123;0, \"0\"&#125;, &#123;1, \"1\"&#125;&#125;&lt;/li&gt; * &lt;li&gt;aMethod(int a, **RowBounds rb**, int b) -&amp;gt; &#123;&#123;0, \"0\"&#125;, &#123;2, \"1\"&#125;&#125;&lt;/li&gt; * &lt;/ul&gt; */ private final SortedMap&lt;Integer, String&gt; names;//标志是否使用了**@Param注解** private boolean hasParamAnnotation; public ParamNameResolver(Configuration config, Method method) &#123;//通过反射获取参数类型数组 final Class&lt;?&gt;[] paramTypes = method.getParameterTypes();//获取方法上的二维数组注解 final Annotation[][] paramAnnotations = method.getParameterAnnotations();//这个map会在最后转化成不可变容器集合unmodifiableSortedMap final SortedMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;(); int paramCount = paramAnnotations.length; //遍历注解 get names from @Param annotations for (int paramIndex = 0; paramIndex &lt; paramCount; paramIndex++) &#123;//判断特殊类型RowBounds或者ResultHandler，发现则直接跳过本次遍历 if (isSpecialParameter(paramTypes[paramIndex])) &#123; // skip special parameters continue; &#125; String name = null; for (Annotation annotation : paramAnnotations[paramIndex]) &#123; if (annotation instanceof Param) &#123;//只要出现Param注解一次立刻设置标志hasParamAnnotation，结束遍历返回指定的name hasParamAnnotation = true; name = ((Param) annotation).value(); break; &#125; &#125;//判断是否有特殊name if (name == null) &#123; // @Param没有指定，根据Configuration.useActualParamName（默认true）是否使用实际名称 if (config.isUseActualParamName()) &#123;//getActualParamName在下面解析，ParamNameUtil.getParamNames(method).get(paramIndex); name = getActualParamName(method, paramIndex); &#125; if (name == null) &#123; // 使用索引值use the parameter index as the name (\"0\", \"1\", ...) name = String.valueOf(map.size()); &#125; &#125;//记录到map集合 map.put(paramIndex, name); &#125;//初始化成不可变集合 names = Collections.unmodifiableSortedMap(map); &#125;//判断是否是RowBounds和ResultHandler两种类型的参数 private static boolean isSpecialParameter(Class&lt;?&gt; clazz) &#123; return RowBounds.class.isAssignableFrom(clazz) || ResultHandler.class.isAssignableFrom(clazz); &#125;...&#125;package org.apache.ibatis.reflection;import ...//获取参数名称的工具类public class ParamNameUtil &#123;//Method和Constructor的父类都是Executable public static List&lt;String&gt; getParamNames(Method method) &#123; return getParameterNames(method); &#125; public static List&lt;String&gt; getParamNames(Constructor&lt;?&gt; constructor) &#123; return getParameterNames(constructor); &#125; private static List&lt;String&gt; getParameterNames(Executable executable) &#123;//通过父类Executable获取参数列表的名字集合 return Arrays.stream(executable.getParameters()).map(Parameter::getName).collect(Collectors.toList()); &#125; private ParamNameUtil() &#123; super(); &#125;&#125; 解析完ParamNameResolver的功能，回到MethodSignature继续研究。MethodSignature也是MapperMethod中定义的内部类，其中封装了Mapper接口中定义的方法的相关信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static class MethodSignature &#123;//...省略字段下面介绍 public MethodSignature(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123; //解析方法类型信息，具体在之前反射工具箱一章提及 Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface); if (resolvedReturnType instanceof Class&lt;?&gt;) &#123; this.returnType = (Class&lt;?&gt;) resolvedReturnType; &#125; else if (resolvedReturnType instanceof ParameterizedType) &#123; this.returnType = (Class&lt;?&gt;) ((ParameterizedType) resolvedReturnType).getRawType(); &#125; else &#123; this.returnType = method.getReturnType(); &#125;//返回值类型是否为void this.returnsVoid = void.class.equals(this.returnType);//返回值类型是否为Collection或者数组 this.returnsMany = configuration.getObjectFactory().isCollection(this.returnType) || this.returnType.isArray();//返回值是否为Cursor类型 this.returnsCursor = Cursor.class.equals(this.returnType);//是否Optional值容器 this.returnsOptional = Optional.class.equals(this.returnType);//若Methodsignature对应方法的返回值是Map且指定了@MapKey 注解，则使用getMapKey（）方法处理 this.mapKey = getMapKey(method); this.returnsMap = this.mapKey != null;//rowBoundsIndex(RowBounds参数位置)和 resultHandlerIndex（ResultHandler参数位置）字段 this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class); this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);//创建ParamNameResolver对象,后面会重点介绍getNamedParams方法 this.paramNameResolver = new ParamNameResolver(configuration, method); &#125;//getUniqueParamIndex主要功能是查找指定参数类型在方法参数的索引位置 private Integer getUniqueParamIndex(Method method, Class&lt;?&gt; paramType) &#123; Integer index = null; final Class&lt;?&gt;[] argTypes = method.getParameterTypes(); for (int i = 0; i &lt; argTypes.length; i++) &#123; if (paramType.isAssignableFrom(argTypes[i])) &#123; if (index == null) &#123; index = i; &#125; else &#123;//RowBounds和ResultHandler类型的参数只能有一个，不能重复出现 throw new BindingException(method.getName() + \" cannot have multiple \" + paramType.getSimpleName() + \" parameters\"); &#125; &#125; &#125; return index; &#125;&#125; 与语法有重要关系过程就在这里，ParamNameResolver有一个非常重要的方法getNamedParams，负责将args[]数组（用户传入的实参列表）转换成SQL语句对应的参数列表。 123456789101112131415161718192021222324252627282930313233343536/** * &lt;p&gt; * A single non-special parameter is returned without a name. * Multiple parameters are named using the naming rule. * In addition to the default names, this method also adds the generic names (param1, param2, * ...). * &lt;/p&gt; */ public Object getNamedParams(Object[] args) &#123; final int paramCount = names.size();//没有任何参数 if (args == null || paramCount == 0) &#123; return null;//如果没有指定@Param或者参数只有一个，直接返回第一个参数 &#125; else if (!hasParamAnnotation &amp;&amp; paramCount == 1) &#123; return args[names.firstKey()]; &#125; else &#123; final Map&lt;String, Object&gt; param = new ParamMap&lt;&gt;(); int i = 0; for (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;//将names属性SortedMap&lt;Integer，String&gt;类型反转//names的value（参数名）为param新集合的key，names的key（参数索引）为param新集合的value param.put(entry.getValue(), args[entry.getKey()]); //参数索引添加前缀、并且从i + 1（1、2、3开始）//例子：add generic param names (param1, param2, ...) final String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + 1); // ensure not to overwrite parameter named with @Param//确保不会覆盖@Param指定的特殊参数名，换而言之就是通过param1或者@Param都可以取到同样的参数 if (!names.containsValue(genericParamName)) &#123; param.put(genericParamName, args[entry.getKey()]); &#125; i++; &#125; return param; &#125; &#125; 最后就是结果集处理，也是MapperMethod重要的方法execute，它会根据SQL语句的类型调用SqlSession对应的方法完成数据库操作。如果是是指定了ResultHandler，那就通过org.apache.ibatis.binding.MapperMethod#executeWithResultHandler处理结果集。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public Object execute(SqlSession sqlSession, Object[] args) &#123; Object result; switch (command.getType()) &#123;//method.convertArgsToSqlCommandParam会调用上面解释到的ParamNameResolver.getNamedParams//rowCountResult处理方法返回值影响行数rowCount，进行结果类型转换 case INSERT: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.insert(command.getName(), param)); break; &#125; case UPDATE: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.update(command.getName(), param)); break; &#125; case DELETE: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.delete(command.getName(), param)); break; &#125; case SELECT: if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123; executeWithResultHandler(sqlSession, args); result = null;//返回的是Collection接口实现类或者数组，由executeForMany方法处理 &#125; else if (method.returnsMany()) &#123; result = executeForMany(sqlSession, args);//返回的是Map集合结果，由executeForMap方法处理 &#125; else if (method.returnsMap()) &#123; result = executeForMap(sqlSession, args);//返回的是Cursor结果 &#125; else if (method.returnsCursor()) &#123; result = executeForCursor(sqlSession, args); &#125; else &#123;//最后查询结果只有一条 Object param = method.convertArgsToSqlCommandParam(args); result = sqlSession.selectOne(command.getName(), param);//如果是Optional包装返回值 if (method.returnsOptional() &amp;&amp; (result == null || !method.getReturnType().equals(result.getClass()))) &#123;//那就进行Optional包装 result = Optional.ofNullable(result); &#125; &#125; break; case FLUSH: result = sqlSession.flushStatements(); break; default: throw new BindingException(\"Unknown execution method for: \" + command.getName()); &#125;//边界检查 if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123; throw new BindingException(\"Mapper method '\" + command.getName() + \" attempted to return null from a method with a primitive return type (\" + method.getReturnType() + \").\"); &#125; return result; &#125;private void executeWithResultHandler(SqlSession sqlSession, Object[] args) &#123;//获取SOL语句对应的MappedStatement对象，MappedStatement中记录了SQL语句相关信息， MappedStatement ms = sqlSession.getConfiguration().getMappedStatement(command.getName());//StatementType不是存储过程（CALLABLE），并且没有指定ResultMap或ResultType，直接抛出BindingException if (!StatementType.CALLABLE.equals(ms.getStatementType()) &amp;&amp; void.class.equals(ms.getResultMaps().get(0).getType())) &#123; throw new BindingException(\"method \" + command.getName() + \" needs either a @ResultMap annotation, a @ResultType annotation,\" + \" or a resultType attribute in XML so a ResultHandler can be used as a parameter.\"); &#125; Object param = method.convertArgsToSqlCommandParam(args);//该方法是否有RowBounds类型参数 if (method.hasRowBounds()) &#123;//获取指定RowBounds类型的参数 RowBounds rowBounds = method.extractRowBounds(args);//通过sqlSession.select查询方法指定查询，并由指定的ResultHandler处理结果对象 sqlSession.select(command.getName(), param, rowBounds, method.extractResultHandler(args)); &#125; else &#123; sqlSession.select(command.getName(), param, method.extractResultHandler(args)); &#125; &#125;//Collection接口实现类或者数组处理过程private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) &#123; List&lt;E&gt; result; Object param = method.convertArgsToSqlCommandParam(args);//参考上几句 if (method.hasRowBounds()) &#123; RowBounds rowBounds = method.extractRowBounds(args); result = sqlSession.selectList(command.getName(), param, rowBounds); &#125; else &#123; result = sqlSession.selectList(command.getName(), param); &#125;//将结果集转换为数组或Collection集合 issue #510 Collections &amp; arrays support if (!method.getReturnType().isAssignableFrom(result.getClass())) &#123; if (method.getReturnType().isArray()) &#123; return convertToArray(result); &#125; else &#123;//根据Configuration对结果对象的转换类型 return convertToDeclaredCollection(sqlSession.getConfiguration(), result); &#125; &#125; return result; &#125;private &lt;E&gt; Object convertToDeclaredCollection(Configuration config, List&lt;E&gt; list) &#123;//使用前面介绍的ObjectFactory对象工厂，通过反射方式创建集合对象 Object collection = config.getObjectFactory().create(method.getReturnType());//创建collection集合反射对象MetaObject，实际上还是调用的CCollection接口的addAll方法 MetaObject metaObject = config.newMetaObject(collection); metaObject.addAll(list); return collection; &#125; @SuppressWarnings(\"unchecked\") private &lt;E&gt; Object convertToArray(List&lt;E&gt; list) &#123;//获取数组的元素类型 Class&lt;?&gt; arrayComponentType = method.getReturnType().getComponentType();//创建数组对象 Object array = Array.newInstance(arrayComponentType, list.size());//判断数组元素是否基本原始类型的 if (arrayComponentType.isPrimitive()) &#123;//将list每一项数据都放置到数组中 for (int i = 0; i &lt; list.size(); i++) &#123; Array.set(array, i, list.get(i)); &#125; return array; &#125; else &#123;//否直接转数组 return list.toArray((E[])array); &#125; &#125;//返回的是Map集合结果，由executeForMap方法处理，Cursor处理方法是sqlSession.selectCursorprivate &lt;K, V&gt; Map&lt;K, V&gt; executeForMap(SqlSession sqlSession, Object[] args) &#123; Map&lt;K, V&gt; result;//转化成实参 Object param = method.convertArgsToSqlCommandParam(args); if (method.hasRowBounds()) &#123; RowBounds rowBounds = method.extractRowBounds(args);//调用selectMap方法返回结果就是Map类型 result = sqlSession.selectMap(command.getName(), param, method.getMapKey(), rowBounds); &#125; else &#123; result = sqlSession.selectMap(command.getName(), param, method.getMapKey()); &#125; return result; &#125;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochikai.github.io/tags/Mybatis/"}]},{"title":"Mybatis技术内幕源码解析：Transaction事务","date":"2019-12-25T12:51:00.000Z","path":"2019/12/25/Mybatis技术内幕源码解析：Transaction事务/","text":"2.7、Transaction事务 控制数据库事务是业务型操作（CRUD）的基本功，Mybatis本身通过Transaction(org.apache.ibatis.transaction)接口对数据库进行了抽象化，具体分析如下： 123456789101112131415161718192021222324252627282930313233343536373839package org.apache.ibatis.transaction;import java.sql.Connection;import java.sql.SQLException;/**包装数据库连接关于创建、预处理、提交/回滚和关闭的生命周期 * Wraps a database connection. * Handles the connection lifecycle that comprises: * its creation, preparation, commit/rollback and close. */public interface Transaction &#123; /**获取数据库连接对象 * Retrieve inner database connection. * @return DataBase connection */ Connection getConnection() throws SQLException; /**提交事务 * Commit inner database connection. */ void commit() throws SQLException; /**回滚事务 * Rollback inner database connection. */ void rollback() throws SQLException; /**关闭数据库连接 * Close inner database connection. */ void close() throws SQLException; /**获取事务的超时时间 * Get transaction timeout if set. */ Integer getTimeout() throws SQLException;&#125; Transaction 接口有JdbcTransaction、ManagedTransaction两个实现。ManagedTransaction的实现非常简单，它同样依赖其中的dataSource字段获取连接，但其commit、rollback方法都是空实现，事务的提交和回滚都是依靠容器管理的，关闭方法通过closeConnection字段的值控制数据库连接。JdbcTransaction依赖JDBC Connection控制数据库事务，接下就要进入对JdbcTransaction的分析： 12345678910111213141516171819202122232425package org.apache.ibatis.transaction.jdbc;import.../**下面操作方法都是直接使用java.sql.Connection直接进行操作事务，getTimeout是空实现 *如果autocommit已经开启，那么commit和rollback方法就会被忽略掉 * &#123;@link Transaction&#125; that makes use of the JDBC commit and rollback facilities directly. * It relies on the connection retrieved from the dataSource to manage the scope of the transaction. * Delays connection retrieval until getConnection() is called. * Ignores commit or rollback requests when autocommit is on. * */public class JdbcTransaction implements Transaction &#123;//事务对应的数据库连接 protected Connection connection;//数据库连接对应的数据源 protected DataSource dataSource;//事务的隔离级别 protected TransactionIsolationLevel level;//是否自动提交 protected boolean autoCommit; ...省略下面方法和构造器&#125; JdbcTransaction、ManagedTransaction两个实现，其对象分别由JdbcTransactionFactory 和Managed TransactionFactory负责创建。这里也使用了工厂方法模式。下面就分析工厂创建产品UML和接口规范： Transaction.png 123456789101112131415161718package org.apache.ibatis.transaction;import ...public interface TransactionFactory &#123;//接口默认方法，通常在创建完Transaction后进行自定义配置事务 default void setProperties(Properties props) &#123; // NOP &#125;//在指定Connection上创建Transaction Transaction newTransaction(Connection conn);//从指定的DataSource获取数据库连接，并在此连接之上创建事务对象，后面就算配置TransactionIsolationLevel和autoCommit Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);&#125; 在实践中，MyBatis通常会与Spring集成使用，数据库的事务是交给Spring进行管理的，以后会介绍Transaction接口的另一实现SpringManagedTransaction。","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochikai.github.io/tags/Mybatis/"}]},{"title":"idea插件第二弹推荐","date":"2019-12-24T09:33:00.000Z","path":"2019/12/24/idea插件第二弹推荐/","text":"idea插件第二弹推荐工具收藏——idea推荐插件一、概念 工欲善其事必先利其器，博主是个死忠工具派，为了解决一个大问题可能会收集多个工具和方案，然后求证对比出体验报告。后续文章有一大类就是工具类推荐，而本篇文章重点就是idea 安装插件记录，简要记录安装方法快速搭建个性化idea，还有一些关于UI方面插件可谓多不胜数，而且每个人口味不一，请各位自行选择——插件搜索技巧tags为Theme或者UI。 插件列表最强大插件卫冕之王——lambda表达式 名称 描述 JRebel 代替springboot dev热部署方案，最方便激活方式 Lombok 精简bean，各种功能强大又实用注解，搬砖人的MVP，结合Hutool实在完美 AceJump 光标跳跃，替代vim不二之选 CodeGlance 代码地图，方便查阅跳转 MavenHelper 快速分析maven 包冲突的问题，搜索包名 MyBatis Log Plugin Restore the mybatis generate sql to original whole sql.（拼接完整sql） Log Support 2 快速log.info()，结合Lombok插件注解@Slf4j可以说无敌 Grep Console 针对控制台日志不同等级进行染色高亮 MyBatisCodeHelperPro 对Mybatis支持非常强，请认真参考https://gejun123456.github.io/MyBatisCodeHelper-Pro/#/README，提高生产力的工具啊（收费可破解）！ Free Mybatis plugin Mybaits支持跳转，有钱大爷请收费版Mybatis plugin强大破解较少，差评 Rainbow Brackets 彩虹括号，多层嵌套代码显示助手 String Manipulation 强大的字符串格式转化 GitToolBox git的强大助手，定时拉取代码、代码逐行展示日志（各种辅助金手指） RestfulToolkit 辅助通过URL定位Controller，简洁版的PostMan Alibaba Cloud Toolkit 结合阿里云（非阿里也支持），多节点发布工具加强力linux客户端 stackoverflow stackoverflow快速搜索bug插件 Translation 最强大的翻译插件，支持中文替换英文，解决起英文变量名难的重度患者 Key Promoter X 所有操作的快捷键提示，忘记鼠标真的 Cyan Light Theme A light theme，偏青色对眼睛很柔和舒服，黑暗主题实在不适应 Hiberbee theme 黑暗主题的色彩分明版本 反馈与建议 2012年java程序员可以说非常吃香，今年2019从业人数暴增，职业发展挑战变得越来越大！现在流行自动构建和自动部署CI，开发运维一体化docker，整个互联网都在追求敏捷开发的今天。掌握一款追求效率功能的IDE非常重要，很多群和公众号对ide和Eclipse争议很大。但请记住斯大林名言——落后就要挨打，ide本身代表高效，但是插件也别装太多，免得启动还要半天哈哈哈😀 （首推）慕课网免费教程：IntelliJ IDEA神器使用技巧 （推荐）尚硅谷IDEA视频教程：链接：https://pan.baidu.com/s/11biVBv9EI9yfL6Cee0r0LQ，密码：n7hn 看完上面两个教程，你会怀疑自己用的idea是假的，原来写代码还可以这样的。 邮箱：caochikai@qq.com","tags":[{"name":"tool","slug":"tool","permalink":"https://caochikai.github.io/tags/tool/"},{"name":"plugin","slug":"plugin","permalink":"https://caochikai.github.io/tags/plugin/"}]},{"title":"Mybatis技术内幕源码解析：DataSource数据源","date":"2019-12-23T10:20:00.000Z","path":"2019/12/23/Mybatis技术内幕源码解析：DataSource数据源/","text":"2.6、DataSource数据源 数据源组件都要实现javax.sql.DataSource接口，常见的有Druid、HikariCP和C3PO。Mybatis提供两个实现：PooledDataSource和UnpooledDataSource，通过工厂模式创建。 DataSourceFactory 123456789101112131415package org.apache.ibatis.datasource;import java.util.Properties;import javax.sql.DataSource;/** * @author Clinton Begin */public interface DataSourceFactory &#123; //通过Properties 配置数据源 void setProperties(Properties props); //工厂获取数据源实例接口 DataSource getDataSource();&#125; 2.6.2 DataSourceFactory 数据源工厂接口的实现类是DataSourceFactory，UnpooledDataSourceFactory和PooledDataSource是具体产品实现类，JndiDataSourceFactory是依赖JNDI服务从容器中获取用户配置的DataSource，我们以UnpooledDataSourceFactory举例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package org.apache.ibatis.datasource.unpooled;import java.util.Properties;import javax.sql.DataSource;import org.apache.ibatis.datasource.DataSourceException;import org.apache.ibatis.datasource.DataSourceFactory;import org.apache.ibatis.reflection.MetaObject;import org.apache.ibatis.reflection.SystemMetaObject;/** * @author Clinton Begin */public class UnpooledDataSourceFactory implements DataSourceFactory &#123; //属性前缀为driver. private static final String DRIVER_PROPERTY_PREFIX = \"driver.\"; //driver.文字长度 private static final int DRIVER_PROPERTY_PREFIX_LENGTH = DRIVER_PROPERTY_PREFIX.length(); //数据源属性 protected DataSource dataSource; public UnpooledDataSourceFactory() &#123; this.dataSource = new UnpooledDataSource(); &#125; @Override public void setProperties(Properties properties) &#123; Properties driverProperties = new Properties(); //根据dataSource创建MetaObject （反射获取该对象元数据） MetaObject metaDataSource = SystemMetaObject.forObject(dataSource); for (Object key : properties.keySet()) &#123; String propertyName = (String) key; //检查属性名称是否以driver.开头 if (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) &#123; String value = properties.getProperty(propertyName); //截取driver.后记录到driverProperties成员变量 driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value); &#125; else if (metaDataSource.hasSetter(propertyName)) &#123; //判断是否有该对象set对应的属性名 String value = (String) properties.get(propertyName); //根据属性类型进行转化 Object convertedValue = convertValue(metaDataSource, propertyName, value); metaDataSource.setValue(propertyName, convertedValue); &#125; else &#123; throw new DataSourceException(\"Unknown DataSource property: \" + propertyName); &#125; &#125; if (driverProperties.size() &gt; 0) &#123; metaDataSource.setValue(\"driverProperties\", driverProperties); &#125; &#125; @Override public DataSource getDataSource() &#123; return dataSource; &#125;//支持属性类型进行类型转换，主要是Integer、Long、Boolean三种类型的转换 private Object convertValue(MetaObject metaDataSource, String propertyName, String value) &#123; Object convertedValue = value; Class&lt;?&gt; targetType = metaDataSource.getSetterType(propertyName); if (targetType == Integer.class || targetType == int.class) &#123; convertedValue = Integer.valueOf(value); &#125; else if (targetType == Long.class || targetType == long.class) &#123; convertedValue = Long.valueOf(value); &#125; else if (targetType == Boolean.class || targetType == boolean.class) &#123; convertedValue = Boolean.valueOf(value); &#125; return convertedValue; &#125;&#125; 2.6.3 UnpooledDataSource javax.sql.DataSource接口在数据源模块中扮演了产品接口的角色，MyBatis提供了两个DataSource 接口的实现类，分别是UnpooledDataSource和PooledDataSource，它们扮演着具体产品类的角色。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package org.apache.ibatis.datasource.unpooled;import ...public class UnpooledDataSource implements DataSource &#123;//数据源类加载器 private ClassLoader driverClassLoader;//配置属性对象 private Properties driverProperties;//缓存注册过的数据源驱动 private static Map&lt;String, Driver&gt; registeredDrivers = new ConcurrentHashMap&lt;&gt;();//驱动 private String driver;//数据库URL private String url;//用户名和密码 private String username; private String password;//是否自动提交 private Boolean autoCommit;//默认事务隔离等级 **private Integer defaultTransactionIsolationLevel;//网络超时时间 private Integer defaultNetworkTimeout; static &#123; Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers(); while (drivers.hasMoreElements()) &#123; Driver driver = drivers.nextElement();//向DriverManager添加JDBC驱动 registeredDrivers.put(driver.getClass().getName(), driver); &#125; &#125;... private Connection doGetConnection(Properties properties) throws SQLException &#123; //初始化驱动Driver对象 initializeDriver(); //创建真正的数据库链接对象 Connection connection = DriverManager.getConnection(url, properties); //配置autoCommit、defaultTransactionIsolationLevel和defaultNetworkTimeout configureConnection(connection); return connection; &#125; private synchronized void initializeDriver() throws SQLException &#123;//判断注册过，避免重复 if (!registeredDrivers.containsKey(driver)) &#123; Class&lt;?&gt; driverType; try &#123;//通过对应的类加载器获得对应的driverType if (driverClassLoader != null) &#123; driverType = Class.forName(driver, true, driverClassLoader); &#125; else &#123; driverType = Resources.classForName(driver); &#125; // DriverManager requires the driver to be loaded via the system ClassLoader. // http://www.kfu.com/~nsayer/Java/dyn-jdbc.html//真正创建Driver过程 Driver driverInstance = (Driver)driverType.getDeclaredConstructor().newInstance();//DriverProxy是UnpooledDataSource的内部类，是Driver的静态代理类 DriverManager.registerDriver(new DriverProxy(driverInstance)); registeredDrivers.put(driver, driverInstance); &#125; catch (Exception e) &#123; throw new SQLException(\"Error setting driver on UnpooledDataSource. Cause: \" + e); &#125; &#125; &#125;&#125; 2.6.4 PooledDataSource PooledDataSource支持数据库连接池的数据源，依赖UnpooledDataSource创建数据库连接。而且PooledDataSource 并不会直接管理java.sql.Connection对象，而是管理PooledConnection对象。在PooledConnection中封装了真正的数据库连接对象（java.sql.Connection）以及其代理对象，这里的代理对象是通过JDK动态代理产生的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package org.apache.ibatis.datasource.pooled;import .../** * @author Clinton Begin */class PooledConnection implements InvocationHandler &#123;//关闭的方法名称，并不是真正关闭而是返还到池子 private static final String CLOSE = \"close\";//动态代理的类Class private static final Class&lt;?&gt;[] IFACES = new Class&lt;?&gt;[] &#123; Connection.class &#125;;//connection的哈希值 private final int hashCode; private final PooledDataSource dataSource;//真正的数据库连接 private final Connection realConnection;//数据库连接的代理对象 private final Connection proxyConnection;//取出的时间戳 private long checkoutTimestamp;//创建的时间戳 private long createdTimestamp;//最近一次使用的时间戳 private long lastUsedTimestamp;//由数据库URL、用户名和密码计算出来的hash值，可用于标识该连接所在的连接池 private int connectionTypeCode;//检查PooledConnection是否有效，防止归还依然使用该连接操作数据库 private boolean valid;...省略一大堆geter/seter方法 /** * Required for InvocationHandler implementation. * * @param proxy - not used * @param method - the method to be executed * @param args - the parameters to be passed to the method * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[]) */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName();//如果是CLOSE方法就向dataSource归还连接池，而不是直接关闭 if (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123; dataSource.pushConnection(this); return null; &#125; try &#123; if (!Object.class.equals(method.getDeclaringClass())) &#123; // issue #579 toString() should never fail // throw an SQLException instead of a Runtime//检查valid是否有效，无效直接抛出异常SQLException checkConnection(); &#125;//调用真正的数据库对象的方法 return method.invoke(realConnection, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125;&#125; PoolState 管理PooledConnection对象状态的组件，它通过两个ArrayList集合分别管理空闲状态的连接和活跃状态的连接，定义如下： 123456789101112131415161718192021222324252627282930package org.apache.ibatis.datasource.pooled;import ...public class PoolState &#123; protected PooledDataSource dataSource;//空闲状态的连接 protected final List&lt;PooledConnection&gt; idleConnections = new ArrayList&lt;&gt;();//**活跃状态**的连接 protected final List&lt;PooledConnection&gt; activeConnections = new ArrayList&lt;&gt;();//以下就是一些统计字段//请求数据库次数 protected long requestCount = 0;//获取连接累计的时间 protected long accumulatedRequestTime = 0;//checkoutTime表示应用从连接池中取出连接，到归还连接这段时长，//accumulatedCheckoutTime记录了所有连接累积的checkoutTime时长 protected long accumulatedCheckoutTime = 0;//累计超时连接个数 protected long claimedOverdueConnectionCount = 0;//累计超时时间 protected long accumulatedCheckoutTimeOfOverdueConnections = 0;//累计等待时间 protected long accumulatedWaitTime = 0;//等待次数 protected long hadToWaitCount = 0;、//无效的连接数 protected long badConnectionCount = 0;...&#125; PooledDataSource中管理的真正的数据库连接对象是由PooledDataSource中封装的UnpooledDataSource对象创建的，并由PoolState管理所有连接的状态。PooledDataSource中核心字段如下： 123456789101112131415161718192021222324252627282930313233package org.apache.ibatis.datasource.pooled;import .../** * This is a simple, synchronous, thread-safe database connection pool. */public class PooledDataSource implements DataSource &#123;//管理连接池状态以及统计信息 private final PoolState state = new PoolState(this);//UnpooledDataSource对象，用于生成真实的数据库连接对象，构造函数中会初始化该字段 private final UnpooledDataSource dataSource;//默认的最大活跃连接数量 // OPTIONAL CONFIGURATION FIELDS protected int poolMaximumActiveConnections = 10;、//最大空闲连接数量 protected int poolMaximumIdleConnections = 5;//最长的checkout等待时间 protected int poolMaximumCheckoutTime = 20000;//在无法获取连接时候，线程的等待时长 protected int poolTimeToWait = 20000;//最大容忍的本地无效连接数量，如果大于（最大活跃连接数量 + 最大空闲连接数量）,直接抛出异常 protected int poolMaximumLocalBadConnectionTolerance = 3;//检查数据库是否SQL语句 protected String poolPingQuery = \"NO PING QUERY SET\";//是否允许发送上面的poolPingQuery 测试SQL语句 protected boolean poolPingEnabled;//当连接超过poo1PingconnectionsNotUsedFor毫秒未使用时，会发送一次测试sQL语句，检测连接是否正常 protected int poolPingConnectionsNotUsedFor;//根据数据库的URL、用户名和密码生成的一个hash值，该哈希值用于标志着当前的连接池 private int expectedConnectionTypeCode;...&#125; PooledDataSource.getConnection()方法首先会调用PooledDataSource.popConnection()方法获取PooledConnection对象，然后通过PooledConnection.getProxyConnection()方法获取数据库连接的代理对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105private PooledConnection popConnection(String username, String password) throws SQLException &#123; boolean countedWait = false; PooledConnection conn = null; long t = System.currentTimeMillis(); int localBadConnectionCount = 0; while (conn == null) &#123; synchronized (state) &#123;//同步锁//检测是否有空闲连接 if (!state.idleConnections.isEmpty()) &#123; // Pool has available connection//获取空闲连接 conn = state.idleConnections.remove(0); if (log.isDebugEnabled()) &#123; log.debug(\"Checked out connection \" + conn.getRealHashCode() + \" from pool.\"); &#125; &#125; else &#123;//没有空闲的 Pool does not have available connection//判断当前活跃连接数量是否已经超过的最大活跃数量限制 if (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123; // 没有就创建一个并封装成PooledConnection conn = new PooledConnection(dataSource.getConnection(), this); if (log.isDebugEnabled()) &#123; log.debug(\"Created connection \" + conn.getRealHashCode() + \".\"); &#125; &#125; else &#123;//超过了限制，获取最先创建的活跃连接 PooledConnection oldestActiveConnection = state.activeConnections.get(0);//获取其超时时间，判断是否已经超时 long longestCheckoutTime = oldestActiveConnection.getCheckoutTime(); if (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;// 对超时连接进行统计 state.claimedOverdueConnectionCount++; state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime; state.accumulatedCheckoutTime += longestCheckoutTime;//并移出活跃连接集合 state.activeConnections.remove(oldestActiveConnection);//如果连接超时且未提交，则自动回滚（省略try/catch代码块） if (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123; oldestActiveConnection.getRealConnection().rollback(); &#125;//创建新Pooledconnection对象，但是真正的数据库连接并未创建新的 conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this); conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp()); conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());//将超时连接设置成为无效状态 oldestActiveConnection.invalidate(); if (log.isDebugEnabled()) &#123; log.debug(\"Claimed overdue connection \" + conn.getRealHashCode() + \".\"); &#125; &#125; else &#123; //无空闲连接、无法创建新连接且无超时连接，则只能阻塞等待 try &#123; if (!countedWait) &#123; state.hadToWaitCount++;//统计等待信息 countedWait = true; &#125; if (log.isDebugEnabled()) &#123; log.debug(\"Waiting as long as \" + poolTimeToWait + \" milliseconds for connection.\"); &#125; long wt = System.currentTimeMillis();//阻塞等待poolTimeToWait，下面就统计一下等待信息 state.wait(poolTimeToWait); state.accumulatedWaitTime += System.currentTimeMillis() - wt; &#125; catch (InterruptedException e) &#123; break; &#125; &#125; &#125; &#125; if (conn != null) &#123; // ping to server and check the connection is valid or not if (conn.isValid()) &#123; if (!conn.getRealConnection().getAutoCommit()) &#123; conn.getRealConnection().rollback(); &#125;//配置PooledConnection的属性，connectionTypeCode由url + username + password组成后的hashCode conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));//记录checkout时间 conn.setCheckoutTimestamp(System.currentTimeMillis());//最近一次使用的时间 conn.setLastUsedTimestamp(System.currentTimeMillis());//进行相关统计 state.activeConnections.add(conn); state.requestCount++; state.accumulatedRequestTime += System.currentTimeMillis() - t; &#125; else &#123; if (log.isDebugEnabled()) &#123; log.debug(\"A bad connection (\" + conn.getRealHashCode() + \") was returned from the pool, getting another connection.\"); &#125;//无效连接数量统计 state.badConnectionCount++; localBadConnectionCount++; conn = null; if (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"PooledDataSource: Could not get a good connection to the database.\"); &#125; throw new SQLException(\"PooledDataSource: Could not get a good connection to the database.\"); &#125; &#125; &#125; &#125; &#125; 看名字就知道（Pool）是支持连接池，那通过前面对PooledConnection.invoke方法的分析我们知道，当调用连接的代理对象的close方法时，并未关闭真正的数据连接，而是代理调用PooledDataSource.pushConnection方法将PooledConnection 对象归还给连接池。下面就分析归还规程是如何实现的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849protected void pushConnection(PooledConnection conn) throws SQLException &#123;//同步state synchronized (state) &#123;//从activeConnections集合里面移除该对象 state.activeConnections.remove(conn);//检查连接对象是否有效 if (conn.isValid()) &#123;//若当前空闲连接集合数量小于最大空闲阈值，并且该连接的connectionTypeCode和数据源本身的hashCode一致 if (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123;//累计checkout时长 state.accumulatedCheckoutTime += conn.getCheckoutTime(); if (!conn.getRealConnection().getAutoCommit()) &#123; conn.getRealConnection().rollback(); &#125;//为返还连接对象包装成PooledConnection PooledConnection newConn = new PooledConnection(conn.getRealConnection(), this); state.idleConnections.add(newConn);//添加到空闲集合idleConnections newConn.setCreatedTimestamp(conn.getCreatedTimestamp()); newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());//将原PooledConnection设置为无效 conn.invalidate(); if (log.isDebugEnabled()) &#123; log.debug(\"Returned connection \" + newConn.getRealHashCode() + \" to pool.\"); &#125;//唤醒通知其他等待阻塞的线程 state.notifyAll(); &#125; else &#123;//空闲连接到达上限或者hashCode不匹配（意味着不属于该连接池） state.accumulatedCheckoutTime += conn.getCheckoutTime(); if (!conn.getRealConnection().getAutoCommit()) &#123; conn.getRealConnection().rollback(); &#125;//关闭真正的数据库连接 conn.getRealConnection().close(); if (log.isDebugEnabled()) &#123; log.debug(\"Closed connection \" + conn.getRealHashCode() + \".\"); &#125;//设置成无效 conn.invalidate(); &#125; &#125; else &#123; if (log.isDebugEnabled()) &#123; log.debug(\"A bad connection (\" + conn.getRealHashCode() + \") attempted to return to the pool, discarding connection.\"); &#125;//统计无效连接数量 state.badConnectionCount++; &#125; &#125; &#125; 在上面代码分析当中，我们可以多次看见isValid()方法，除了校验PooledConnection.valid属性外，还会调用dataSource.pingConnection方法让数据库执行poolPingQuery的测试SQL数据库语句，下面让我讨论下关于校验连接有效的过程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 /**检查连接有效性 * @return True if the connection is usable */ public boolean isValid() &#123; return valid &amp;&amp; realConnection != null &amp;&amp; dataSource.pingConnection(this); &#125;/**通过发送ping检查SQL判断当前数据库连接是否已经失效，毕竟数据库对长时间的链接也会做失效处理 * Method to check to see if a connection is still usable * * @param conn - the connection to check * @return True if the connection is still usable */ protected boolean pingConnection(PooledConnection conn) &#123;//ping操作成功的标志 boolean result = true; try &#123;//先检查数据库连接是否已经关闭 result = !conn.getRealConnection().isClosed(); &#125; catch (SQLException e) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Connection \" + conn.getRealHashCode() + \" is BAD: \" + e.getMessage()); &#125; result = false; &#125;//1、如果没关闭进一步检查 if (result) &#123;//2、检查SQL检查的心跳开关 if (poolPingEnabled) &#123;//3、检查poolPingConnectionsNotUsedFor是否已经超过（当前时间距离最近一次使用的时间间距） if (poolPingConnectionsNotUsedFor &gt;= 0 &amp;&amp; conn.getTimeElapsedSinceLastUse() &gt; poolPingConnectionsNotUsedFor) &#123; try &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Testing connection \" + conn.getRealHashCode() + \" ...\"); &#125; Connection realConn = conn.getRealConnection();//下面是执行SQL测试语句 try (Statement statement = realConn.createStatement()) &#123; statement.executeQuery(poolPingQuery).close(); &#125; if (!realConn.getAutoCommit()) &#123; realConn.rollback(); &#125; result = true; if (log.isDebugEnabled()) &#123; log.debug(\"Connection \" + conn.getRealHashCode() + \" is GOOD!\"); &#125; &#125; catch (Exception e) &#123; log.warn(\"Execution of ping query '\" + poolPingQuery + \"' failed: \" + e.getMessage()); try &#123; conn.getRealConnection().close(); &#125; catch (Exception e2) &#123; //ignore &#125; result = false; if (log.isDebugEnabled()) &#123; log.debug(\"Connection \" + conn.getRealHashCode() + \" is BAD: \" + e.getMessage()); &#125; &#125; &#125; &#125; &#125; return result; &#125;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochikai.github.io/tags/Mybatis/"}]},{"title":"设计模式原则","date":"2019-12-22T15:43:00.000Z","path":"2019/12/22/设计模式原则/","text":"幕布：软件设计原则 思维导图","tags":[{"name":"software engineering","slug":"software-engineering","permalink":"https://caochikai.github.io/tags/software-engineering/"}]},{"title":"Mybatis技术内幕源码解析：资源加载","date":"2019-12-22T06:10:00.000Z","path":"2019/12/22/Mybatis技术内幕源码解析：资源加载/","text":"2.5、资源加载2.5.1、类加载器 JVM类加载器（ClassLoader）负责加载各种资源（主要是class字节码文件)，来源比如文件系统、网络资源或者其他来源，且默认使用的是双亲委派模式。类加载器基本三大特性为延迟加载、职责分明、传递性。而JVM 中内置了三个重要的 ClassLoader： BootstrapClassLoader、ExtensionClassLoader 和 AppClassLoader。URLClassLoader 不但可以加载远程类库，还可以加载本地路径的类库，取决于构造器中不同的地址形式。ExtensionClassLoader 和 AppClassLoader 都是 URLClassLoader 的子类，它们都是从本地文件系统里加载类库。 BootstrapClassLoader（根加载器）：加载JVM核心类，比如$JAVA_HOME/lib/rt.jar； ExtensionClassLoader（扩展加载器）：加载扩展类，以 javax 开头的swing 系列、内置的 js 引擎、xml 解析器等等； AppClassLoader（用户加载器）：ClassLoader.getSystemClassLoader()获得，加载Classpath 环境变量下目录和jar； Thread.contextClassLoader（线程上下文类加载器）：主要是类隔离或者共享； 双亲委派模式：简单了来说子类有个parent 属性指向它的父加载器（类似指针），先检查自己是否已经加载过了，如果没有加载过就优先让父类尝试加载（理解为很懒都坑爹），如果已经加载或者坑爹不成那就自己干。 自定义类加载器：继承java.lang.ClassLoader，比如Tomcat（WebAppClassLoader）、JBoss类加载器； 12345678910package java.lang;...public abstract class ClassLoader &#123; // The parent class loader for delegation // Note: VM hardcoded the offset of this field, thus all new fields // must be added *after* it.//如果parent为空（比如ExtensionClassLoader），那默认null就是根加载器BootstrapClassLoader private final ClassLoader parent; ...&#125; 2.5.2 ClassloaderWrapper 看名字就知道是ClassLoader的包装器，org.apache.ibatis.io包就封装了资源加载文件的相关API，通过ClassloaderWrapper包装器就可以调整多个ClassLoader的使用顺序。ClassLoaderWrapper的主要方法可以分为三类，分别是getResourceAsURL方法、classForName方法、getResourceAsStream方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package org.apache.ibatis.io;import java.io.InputStream;import java.net.URL;/** * A class to wrap access to multiple class loaders making them work as one * * @author Clinton Begin */public class ClassLoaderWrapper &#123; //指定的默认类加载器 ClassLoader defaultClassLoader; //SecurityManager系统类加载器 ClassLoader systemClassLoader; ClassLoaderWrapper() &#123; try &#123; //初始化类加载器 systemClassLoader = ClassLoader.getSystemClassLoader(); &#125; catch (SecurityException ignored) &#123; // AccessControlException on Google App Engine &#125; &#125; ClassLoader[] getClassLoaders(ClassLoader classLoader) &#123; return new ClassLoader[]&#123; classLoader,//参数指定加载器 defaultClassLoader,//默认加载器 Thread.currentThread().getContextClassLoader(),//线程上下文类加载器 getClass().getClassLoader(),//当前类所使用的类加载器 systemClassLoader&#125;;//System ClassLoader &#125; ...省略部分重载方法 /** * Try to get a resource from a group of classloaders * * @param resource - the resource to get * @param classLoader - the classloaders to examine * @return the resource or null */ InputStream getResourceAsStream(String resource, ClassLoader[] classLoader) &#123; for (ClassLoader cl : classLoader) &#123; if (null != cl) &#123; // try to find the resource as passed InputStream returnValue = cl.getResourceAsStream(resource); // now, some class loaders want this leading \"/\", so we'll add it and try again if we didn't find the resource if (null == returnValue) &#123; returnValue = cl.getResourceAsStream(\"/\" + resource); &#125; if (null != returnValue) &#123; return returnValue; &#125; &#125; &#125; return null; &#125; /** * Get a resource as a URL using the current class path * * @param resource - the resource to locate * @param classLoader - the class loaders to examine * @return the resource or null */ URL getResourceAsURL(String resource, ClassLoader[] classLoader) &#123; URL url; for (ClassLoader cl : classLoader) &#123; if (null != cl) &#123; // look for the resource as passed in... url = cl.getResource(resource); // ...but some class loaders want this leading \"/\", so we'll add it // and try again if we didn't find the resource if (null == url) &#123; url = cl.getResource(\"/\" + resource); &#125; // \"It's always in the last place I look for it!\" // ... because only an idiot would keep looking for it after finding it, so stop looking already. if (null != url) &#123; return url; &#125; &#125; &#125; // didn't find it anywhere. return null; &#125; /** * Attempt to load a class from a group of classloaders * * @param name - the class to load * @param classLoader - the group of classloaders to examine * @return the class * @throws ClassNotFoundException - Remember the wisdom of Judge Smails: Well, the world needs ditch diggers, too. */ Class&lt;?&gt; classForName(String name, ClassLoader[] classLoader) throws ClassNotFoundException &#123; for (ClassLoader cl : classLoader) &#123; if (null != cl) &#123; try &#123; Class&lt;?&gt; c = Class.forName(name, true, cl) if (null != c) &#123; return c; &#125; &#125; catch (ClassNotFoundException e) &#123; // we'll ignore this until all classloaders fail to locate the class &#125; &#125; &#125; throw new ClassNotFoundException(\"Cannot find class: \" + name); &#125;&#125; 2.5.3 ResolverUtil ResolverUtil根据指定的条件查找指定包下的类，其中条件由Test接口中定义了matches方法提供。 upload successful 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package org.apache.ibatis.io;import ***import org.apache.ibatis.logging.Log;import org.apache.ibatis.logging.LogFactory;public class ResolverUtil&lt;T&gt; &#123; /** * A simple interface that specifies how to test classes to determine if they * are to be included in the results produced by the ResolverUtil. */ public interface Test &#123; /** * Will be called repeatedly with candidate classes. Must return True if a class * is to be included in the results, false otherwise. */ boolean matches(Class&lt;?&gt; type); &#125; /** * A Test that checks to see if each class is assignable to the provided class. Note * that this test will match the parent type itself if it is presented for matching. */ public static class IsA implements Test &#123; private Class&lt;?&gt; parent; //...构造方法初始化parent /** Returns true if type is assignable to the parent type supplied in the constructor. */ @Override public boolean matches(Class&lt;?&gt; type) &#123; //判断parent是否是type的父类（继承） return type != null &amp;&amp; parent.isAssignableFrom(type); &#125; &#125; /** * A Test that checks to see if each class is annotated with a specific annotation. If it * is, then the test returns true, otherwise false. */ public static class AnnotatedWith implements Test &#123; private Class&lt;? extends Annotation&gt; annotation; //...构造方法初始化annotation /** Returns true if the type is annotated with the class provided to the constructor. */ @Override public boolean matches(Class&lt;?&gt; type) &#123; //判断Type类上是否添加了annotation注解 return type != null &amp;&amp; type.isAnnotationPresent(annotation); &#125; &#125; /** The set of matches being accumulated. */ private Set&lt;Class&lt;? extends T&gt;&gt; matches = new HashSet&lt;&gt;(); /** * The ClassLoader to use when looking for classes. If null then the ClassLoader returned * by Thread.currentThread().getContextClassLoader() will be used. */ private ClassLoader classloader; /** * Provides access to the classes discovered so far. If no calls have been made to * any of the &#123;@code find()&#125; methods, **this set will be empty**. * * @return 匹配的类. */ public Set&lt;Class&lt;? extends T&gt;&gt; getClasses() &#123; return matches; &#125; /** * Returns the classloader that will be used for scanning for classes. If no explicit * ClassLoader has been set by the calling,the context class loader will be used. * 默认是线程上下文类加载器 */ public ClassLoader getClassLoader() &#123; return classloader == null ? Thread.currentThread().getContextClassLoader() : classloader; &#125; public void setClassLoader(ClassLoader classloader) &#123; this.classloader = classloader; &#125; /** * Scans for classes starting at the package provided and descending into subpackages. * Each class is offered up to the Test as it is discovered, and if the Test returns * true the class is retained. Accumulated classes can be fetched by calling * * @param test an instance of &#123;@link Test&#125; that will be used to filter classes * @param packageName the name of the package from which to start scanning for * classes, e.g. */ public ResolverUtil&lt;T&gt; find(Test test, String packageName) &#123; //根据包名获取对应的路径 String path = getPackagePath(packageName); try &#123; //根据VFS结果集合查找上面path下的资源 List&lt;String&gt; children = VFS.getInstance().list(path); for (String child : children) &#123; if (child.endsWith(\".class\")) &#123; //检查class是否符合结果 addIfMatching(test, child); &#125; &#125; &#125; catch (IOException ioe) &#123; log.error(\"Could not read package: \" + packageName, ioe); &#125; return this; &#125; ​ 12345678910111213141516171819202122232425262728293031323334 /** * Add the class designated by the fully qualified class name provided to the set of * resolved classes if and only if it is approved by the Test supplied. * * @param test the test used to determine if the class matches 查找条件 * @param fqn the fully qualified name of a class 类的完全限定名称 */ @SuppressWarnings(\"unchecked\") protected void addIfMatching(Test test, String fqn) &#123; try &#123; String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.'); ClassLoader loader = getClassLoader(); if (log.isDebugEnabled()) &#123; log.debug(\"Checking to see if class \" + externalName + \" matches criteria [\" + test + \"]\"); &#125; Class&lt;?&gt; type = loader.loadClass(externalName);//加载指定的类 if (test.matches(type)) &#123; //如果条件过滤在添加到匹配结果集合matches matches.add((Class&lt;T&gt;) type); &#125; &#125; catch (Throwable t) &#123; log.warn(\"Could not examine class '\" + fqn + \"'\" + \" due to a \" + t.getClass().getName() + \" with message: \" + t.getMessage()); &#125; &#125;&#125;//使用例子：在pkg1和pkg2这两个包下查找实现了ActionBean这个类ResolverUtil&lt;ActionBean&gt; resolver = new ResolverUtil&lt;ActionBean&gt;();resolver.findImplementation(ActionBean.class, pkg1, pkg2);resolver.find(new CustomTest(), pkg1);resolver.find(new CustomTest(), pkg2);//获取上面三个方法三次查找的结果集Collection&lt;ActionBean&gt; beans = resolver.getClasses(); 2.5.5 VFS（虚拟文件系统） VFS是Virtual File System缩写，用来查找指定路径下的资源。VFS也是一个抽象类，Mybatis在org.apache.ibatis.io下有DefaultVFS和JBoss6VFS的实现，UML图如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package org.apache.ibatis.io;import ...import org.apache.ibatis.logging.Log;import org.apache.ibatis.logging.LogFactory;/** * Provides a very simple API for accessing resources within an application server. * * @author Ben Gunter */public abstract class VFS &#123; /** The built-in implementations.记录了两个实现类 */ public static final Class&lt;?&gt;[] IMPLEMENTATIONS = &#123; JBoss6VFS.class, DefaultVFS.class &#125;; /** The list to which implementations are added by &#123;@link #addImplClass(Class)&#125;. *用户自定义的VES实现类。addImplClass（）方法会将指定的VES实现Class对象添加到集合。 */ public static final List&lt;Class&lt;? extends VFS&gt;&gt; USER_IMPLEMENTATIONS = new ArrayList&lt;&gt;(); ... /** Singleton instance holder.单例 */ private static class VFSHolder &#123; static final VFS INSTANCE = createVFS(); @SuppressWarnings(\"unchecked\") static VFS createVFS() &#123; // Try the user implementations first, then the built-ins List&lt;Class&lt;? extends VFS&gt;&gt; impls = new ArrayList&lt;&gt;();//优先使用用户定义的VFS的实现类 impls.addAll(USER_IMPLEMENTATIONS);//随后使用Mybatis提供的JBoss6VFS.class, DefaultVFS.class impls.addAll(Arrays.asList((Class&lt;? extends VFS&gt;[]) IMPLEMENTATIONS));//遍历所有实现类，依次实例化VFS对象并判断是否可用，可用就返回对象结束循环 // Try each implementation class until a valid one is found VFS vfs = null; for (int i = 0; vfs == null || !vfs.isValid(); i++) &#123; Class&lt;? extends VFS&gt; impl = impls.get(i); try &#123; vfs = impl.getDeclaredConstructor().newInstance(); if (!vfs.isValid()) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"VFS implementation \" + impl.getName() + \" is not valid in this environment.\"); &#125; &#125; &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123; log.error(\"Failed to instantiate \" + impl, e); return null; &#125; &#125; if (log.isDebugEnabled()) &#123; log.debug(\"Using VFS adapter \" + vfs.getClass().getName()); &#125; return vfs; &#125; &#125; /**单例模式体现，通过静态类创建 * Get the singleton &#123;@link VFS&#125; instance. If no &#123;@link VFS&#125; implementation can be found for the * current environment, then this method returns null. */ public static VFS getInstance() &#123; return VFSHolder.INSTANCE; &#125;//抽象方法 /*isValid()负责检测当前VFS对象在当前环境下是否有效* Return true if the &#123;@link VFS&#125; implementation is valid for the current environment. */ public abstract boolean isValid(); /**负责查找指定的资源名称列表 * Recursively list the full resource path of all the resources that are children of the * resource identified by a URL. * * @param url The URL that identifies the resource to list. * @param forPath The path to the resource that is identified by the URL. Generally, this is the * value passed to &#123;@link #getResources(String)&#125; to get the resource URL. * @return A list containing the names of the child resources. * @throws IOException If I/O errors occur */ protected abstract List&lt;String&gt; list(URL url, String forPath) throws IOException;&#125; VFS中定义了list（URL，String）和isValid()两个抽象方法，在ResolverUtil.find()方法查找类文件时会调用list()方法的重载方法，该重载最终会调用list（URL，String）这个重载。我们以DefaultVFS为例进行分析，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173ackage org.apache.ibatis.io;import ***import org.apache.ibatis.logging.Log;import org.apache.ibatis.logging.LogFactory;/**VFS的默认实现方法，适用于大多数的应用服务 * A default implementation of &#123;@link VFS&#125; that works for most application servers. * * @author Ben Gunter */public class DefaultVFS extends VFS &#123; private static final Log log = LogFactory.getLog(DefaultVFS.class); //判断是否是jar文件的字节特征 /** The magic header that indicates a JAR (ZIP) file. */ private static final byte[] JAR_MAGIC = &#123; 'P', 'K', 3, 4 &#125;; @Override public boolean isValid() &#123; return true; &#125; @Override public List&lt;String&gt; list(URL url, String path) throws IOException &#123; InputStream is = null; try &#123; List&lt;String&gt; resources = new ArrayList&lt;&gt;(); // First, try to find the URL of a JAR file containing the requested resource. If a JAR // file is found, then we'll list child resources by reading the JAR. //尝试读取jar文件，返回对应的URL，如果为空那就代表不是jar资源 URL jarUrl = findJarForResource(url); if (jarUrl != null) &#123; is = jarUrl.openStream(); if (log.isDebugEnabled()) &#123; log.debug(\"Listing \" + url); &#125; //遍历jar包中以path开头的资源列表 resources = listResources(new JarInputStream(is), path); &#125; else &#123; //遍历url的子目录并记录到children List&lt;String&gt; children = new ArrayList&lt;&gt;(); try &#123; if (isJar(url)) &#123; // Some versions of JBoss VFS might give a JAR stream even if the resource // referenced by the URL isn't actually a JAR is = url.openStream(); try (JarInputStream jarInput = new JarInputStream(is)) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Listing \" + url); &#125; for (JarEntry entry; (entry = jarInput.getNextJarEntry()) != null; ) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Jar entry: \" + entry.getName()); &#125; children.add(entry.getName()); &#125; &#125; &#125; else &#123; /* 大意是部分应用是资源列表在文本文件的里，下面尝试逐行读取资源， *路径为path + \"/\" + line（每行内容）若读取成功为文件，否则为文件夹 * Some servlet containers allow reading from directory resources like a * text file, listing the child resources one per line. However, there is no * way to differentiate between directory and file resources just by reading * them. To work around that, as each line is read, try to look it up via * the class loader as a child of the current resource. If any line fails * then we assume the current resource is not a directory. */ is = url.openStream(); List&lt;String&gt; lines = new ArrayList&lt;&gt;(); try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) &#123; for (String line; (line = reader.readLine()) != null;) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Reader entry: \" + line); &#125; lines.add(line); if (getResources(path + \"/\" + line).isEmpty()) &#123; lines.clear(); break; &#125; &#125; &#125; if (!lines.isEmpty()) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Listing \" + url); &#125; children.addAll(lines); &#125; &#125; &#125; catch (FileNotFoundException e) &#123; /*若读取URL失败则直接整个文件夹下所有的文件 * For file URLs the openStream() call might fail, depending on the servlet * container, because directories can't be opened for reading. If that happens, * then list the directory directly instead. */ if (\"file\".equals(url.getProtocol())) &#123; File file = new File(url.getFile()); if (log.isDebugEnabled()) &#123; log.debug(\"Listing directory \" + file.getAbsolutePath()); &#125; if (file.isDirectory()) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Listing \" + url); &#125; children = Arrays.asList(file.list()); &#125; &#125; else &#123; // No idea where the exception came from so rethrow it throw e; &#125; &#125; // The URL prefix to use when recursively listing child resources String prefix = url.toExternalForm(); if (!prefix.endsWith(\"/\")) &#123; prefix = prefix + \"/\"; &#125; // Iterate over immediate children, adding files and recursing into directories for (String child : children) &#123; String resourcePath = path + \"/\" + child; resources.add(resourcePath); URL childUrl = new URL(prefix + child); resources.addAll(list(childUrl, resourcePath)); &#125; &#125; return resources; &#125; finally &#123; ...关闭流 &#125; &#125; /** * List the names of the entries in the given &#123;@link JarInputStream&#125; that begin with the * specified &#123;@code path&#125;. Entries will match with or without a leading slash. * * @param jar The JAR input stream * @param path The leading path to match * @return The names of all the matching entries * @throws IOException If I/O errors occur */ protected List&lt;String&gt; listResources(JarInputStream jar, String path) throws IOException &#123; // Include the leading and trailing slash when matching names //...如果path不是以/开始和结束，则在其开始和结束位置添加/（略） // Iterate over the entries and collect those that begin with the requested path List&lt;String&gt; resources = new ArrayList&lt;&gt;(); //遍历jar包,将以path开头资源加入到resources 集合 for (JarEntry entry; (entry = jar.getNextJarEntry()) != null;) &#123; if (!entry.isDirectory()) &#123; // Add leading slash if it's missing StringBuilder name = new StringBuilder(entry.getName()); if (name.charAt(0) != '/') &#123; name.insert(0, '/'); &#125; // Check file name-&gt;path开头 if (name.indexOf(path) == 0) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Found resource: \" + name); &#125; // Trim leading slash resources.add(name.substring(1)); &#125; &#125; &#125; return resources; &#125; ...&#125; 参考文章 Oracle Location-Independent Access to Resources 老大难的 Java ClassLoader 再不理解就老了","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochikai.github.io/tags/Mybatis/"}]},{"title":"Mybatis技术内幕源码解析：日志模块","date":"2019-12-21T13:19:00.000Z","path":"2019/12/21/Mybatis技术内幕源码解析：日志模块/","text":"2.4、日志模块 Mybatis日志模块使用了适配器模式，内部调用org.apache.ibatis.logging.Log 接口。为了整合第三方的日志组件Log4J2、Log4J，mybatis提供了多种Adapter适配这些日志组件的API，并遵守Log 接口标准。在日志级别支持中，Mybatis提供了trace、debug、warn、eror四个级别，只能说基本满足绝大多数场景的日志。 12345678910111213141516171819202122package org.apache.ibatis.logging;/** * @author Clinton Begin */public interface Log &#123; //is开头方法为判断登记方法 boolean isDebugEnabled(); boolean isTraceEnabled(); //下面四个分别支持四种等级日志调用 void error(String s, Throwable e); void error(String s); void debug(String s); void trace(String s); void warn(String s);&#125; LogFactory负责创建对应的日志组件的适配器，其内部逻辑基本公共静态代码块加载支持的日志适配器，然后使用logConstructor集合记录所有支持的日志适配器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package org.apache.ibatis.logging;import java.lang.reflect.Constructor;/** * @author Clinton Begin * @author Eduardo Macarron */public final class LogFactory &#123; /** * Marker to be used by logging implementations that support markers. */ public static final String MARKER = \"MYBATIS\"; //第三方日志组件的集合 private static Constructor&lt;? extends Log&gt; logConstructor; static &#123; tryImplementation(LogFactory::useSlf4jLogging); tryImplementation(LogFactory::useCommonsLogging); tryImplementation(LogFactory::useLog4J2Logging); tryImplementation(LogFactory::useLog4JLogging); tryImplementation(LogFactory::useJdkLogging); tryImplementation(LogFactory::useNoLogging); &#125; private LogFactory() &#123; // disable construction &#125; public static Log getLog(Class&lt;?&gt; aClass) &#123; return getLog(aClass.getName()); &#125; public static Log getLog(String logger) &#123; try &#123; //返回logger对象 return logConstructor.newInstance(logger); &#125; catch (Throwable t) &#123; throw new LogException(\"Error creating logger for logger \" + logger + \". Cause: \" + t, t); &#125; &#125; ...use开头方法省略都会走下面方法setImplementation（对应适配器类） private static void tryImplementation(Runnable runnable) &#123; if (logConstructor == null) &#123; try &#123; runnable.run(); &#125; catch (Throwable t) &#123; // ignore &#125; &#125; &#125; private static void setImplementation(Class&lt;? extends Log&gt; implClass) &#123; try &#123; //获取指定适配器的构造方法 Constructor&lt;? extends Log&gt; candidate = implClass.getConstructor(String.class); //实例化适配器 Log log = candidate.newInstance(LogFactory.class.getName()); if (log.isDebugEnabled()) &#123; log.debug(\"Logging initialized using '\" + implClass + \"' adapter.\"); &#125; //初始化logConstructor logConstructor = candidate; &#125; catch (Throwable t) &#123; throw new LogException(\"Error setting Log implementation. Cause: \" + t, t); &#125; &#125;&#125; 2.4.4、JDBC调试日志 org.apache.ibatis.logging.jdbc是Mybatis通过动态代理的方式，将JDBC操作通过指定的日志框架打印出来，输出内容包含sql语句、绑定参数、影响行数等等。BaseJdbcLogger是jdbc下所有logger类的父类，继承树如下： upload successful 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package org.apache.ibatis.logging.jdbc;import ...省略部分导入import org.apache.ibatis.logging.Log;import org.apache.ibatis.reflection.ArrayUtil;/** * Base class for proxies to do logging. * * @author Clinton Begin * @author Eduardo Macarron */public abstract class BaseJdbcLogger &#123; //PreparedStatement接口中定义的常用的set*（）方法名 protected static final Set&lt;StrinSg&gt; SET_METHODS; //Statement接口和PreparedStatement接口中与执行SQL语句相关的方法名 protected static final Set&lt;String&gt; EXECUTE_METHODS = new HashSet&lt;&gt;(); //PreparedStatement.set*（）方法设置的键值对，key为parameterIndex下标，value为列值 private final Map&lt;Object, Object&gt; columnMap = new HashMap&lt;&gt;(); //parameterIndex集合 private final List&lt;Object&gt; columnNames = new ArrayList&lt;&gt;(); //value集合 private final List&lt;Object&gt; columnValues = new ArrayList&lt;&gt;(); //当前支持的适配器实例 protected final Log statementLog; //Sql层数，用于格式化sql，buffer堆栈的深度-&gt;char[] buffer = new char[queryStack * 2 + 2]; protected final int queryStack; /* * Default constructor，传入适配器实例 */ public BaseJdbcLogger(Log log, int queryStack) &#123; this.statementLog = log; if (queryStack == 0) &#123; this.queryStack = 1; &#125; else &#123; this.queryStack = queryStack; &#125; &#125; static &#123; //lambada获取PreparedStatement开通setXXX方法名称集合 SET_METHODS = Arrays.stream(PreparedStatement.class.getDeclaredMethods()) .filter(method -&gt; method.getName().startsWith(\"set\")) .filter(method -&gt; method.getParameterCount() &gt; 1) .map(Method::getName) .collect(Collectors.toSet()); //执行方法代理目标 EXECUTE_METHODS.add(\"execute\"); EXECUTE_METHODS.add(\"executeUpdate\"); EXECUTE_METHODS.add(\"executeQuery\"); EXECUTE_METHODS.add(\"addBatch\"); &#125; static &#123; //往SET_METHODS集合添加记录 SET_METHODS.add(\"setString\"); SET_METHODS.add(\"setNString\"); SET_METHODS.add(\"setInt\"); SET_METHODS.add(\"setByte\"); SET_METHODS.add(\"setShort\"); SET_METHODS.add(\"setLong\"); SET_METHODS.add(\"setDouble\"); SET_METHODS.add(\"setFloat\"); SET_METHODS.add(\"setTimestamp\"); SET_METHODS.add(\"setDate\"); SET_METHODS.add(\"setTime\"); SET_METHODS.add(\"setArray\"); SET_METHODS.add(\"setBigDecimal\"); SET_METHODS.add(\"setAsciiStream\"); SET_METHODS.add(\"setBinaryStream\"); SET_METHODS.add(\"setBlob\"); SET_METHODS.add(\"setBoolean\"); SET_METHODS.add(\"setBytes\"); SET_METHODS.add(\"setCharacterStream\"); SET_METHODS.add(\"setNCharacterStream\"); SET_METHODS.add(\"setClob\"); SET_METHODS.add(\"setNClob\"); SET_METHODS.add(\"setObject\"); SET_METHODS.add(\"setNull\"); EXECUTE_METHODS.add(\"execute\"); EXECUTE_METHODS.add(\"executeUpdate\"); EXECUTE_METHODS.add(\"executeQuery\"); EXECUTE_METHODS.add(\"addBatch\"); &#125; protected void setColumn(Object key, Object value) &#123; columnMap.put(key, value); columnNames.add(key); columnValues.add(value); &#125; ...&#125; PreparedStatementLogger继承了BaseJdbcLogger并实现了InvocationHandler接口。PreparedStatementLogger.invoke方法会为EXECUTE_METHODS集合中的方法、SET_METHODS集合中的方法、getResultSet等方法提供代理，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package org.apache.ibatis.logging.jdbc;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import org.apache.ibatis.logging.Log;import org.apache.ibatis.reflection.ExceptionUtil;/** * PreparedStatement proxy to add logging. * * @author Clinton Begin * @author Eduardo Macarron * */public final class PreparedStatementLogger extends BaseJdbcLogger implements InvocationHandler &#123; private final PreparedStatement statement; private PreparedStatementLogger(PreparedStatement stmt, Log statementLog, int queryStack) &#123; super(statementLog, queryStack); this.statement = stmt; &#125; @Override public Object invoke(Object proxy, Method method, Object[] params) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, params); &#125; //调用了EXECUTE_METHODS集合中的方法 if (EXECUTE_METHODS.contains(method.getName())) &#123; if (isDebugEnabled()) &#123; //日志输出，输出的是参数值以及参数类型-&gt;() debug(\"Parameters: \" + getParameterValueString(), true); &#125; clearColumnInfo();//清空BaseJdbcLogger中定义的三个column*集合 //如果是executeQuery方法，则为ResultSet创建代理对象，不是则直接返回结果 if (\"executeQuery\".equals(method.getName())) &#123; ResultSet rs = (ResultSet) method.invoke(statement, params); return rs == null ? null : ResultSetLogger.newInstance(rs, statementLog, queryStack); &#125; else &#123; return method.invoke(statement, params); &#125; &#125; else if (SET_METHODS.contains(method.getName())) &#123; //如果是SET_METHODS集合中的方法，则通过setColumn记录到 //BaseJdbcLogger的三个column*集合 if (\"setNull\".equals(method.getName())) &#123; setColumn(params[0], null); &#125; else &#123; setColumn(params[0], params[1]); &#125; return method.invoke(statement, params); &#125; else if (\"getResultSet\".equals(method.getName())) &#123; //如果调用getResultSet（）方法，则为ResultSet创建代理对象 ResultSet rs = (ResultSet) method.invoke(statement, params); return rs == null ? null : ResultSetLogger.newInstance(rs, statementLog, queryStack); &#125; else if (\"getUpdateCount\".equals(method.getName())) &#123; int updateCount = (Integer) method.invoke(statement, params); if (updateCount != -1) &#123; debug(\" Updates: \" + updateCount, false); &#125; //返回影响条数 return updateCount; &#125; else &#123; return method.invoke(statement, params); &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; /** * Creates a logging version of a PreparedStatement. * * @param stmt - the statement * @param statementLog - the statement log * @param queryStack - the query stack * @return - the proxy 使用JDK动态代理的方式创建代理对象 */ public static PreparedStatement newInstance(PreparedStatement stmt, Log statementLog, int queryStack) &#123; InvocationHandler handler = new PreparedStatementLogger(stmt, statementLog, queryStack); ClassLoader cl = PreparedStatement.class.getClassLoader(); return (PreparedStatement) Proxy.newProxyInstance(cl, new Class[]&#123;PreparedStatement.class, CallableStatement.class&#125;, handler); &#125; /** * Return the wrapped prepared statement. * * @return the PreparedStatement */ public PreparedStatement getPreparedStatement() &#123; return statement; &#125;&#125; ResultSetLogger 中封装了ResultSet对象，也继承了BaseldbcLogger抽象类并实现了InvocationHandler 接口。ResultSetLogger中定义的字段如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package org.apache.ibatis.logging.jdbc;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.sql.Types;import java.util.HashSet;import java.util.Set;import org.apache.ibatis.logging.Log;import org.apache.ibatis.reflection.ExceptionUtil;/** * ResultSet proxy to add logging * * @author Clinton Begin * @author Eduardo Macarron * */public final class ResultSetLogger extends BaseJdbcLogger implements InvocationHandler &#123; //记录了超大长度的类型 private static Set&lt;Integer&gt; BLOB_TYPES = new HashSet&lt;&gt;(); //是否是ResultSet结果集的第一行 private boolean first = true; //统计行数 private int rows; private final ResultSet rs; //记录了超大字段的列编号 private final Set&lt;Integer&gt; blobColumns = new HashSet&lt;&gt;(); static &#123; //所有超大长度的类型 BLOB_TYPES.add(Types.BINARY); BLOB_TYPES.add(Types.BLOB); BLOB_TYPES.add(Types.CLOB); BLOB_TYPES.add(Types.LONGNVARCHAR); BLOB_TYPES.add(Types.LONGVARBINARY); BLOB_TYPES.add(Types.LONGVARCHAR); BLOB_TYPES.add(Types.NCLOB); BLOB_TYPES.add(Types.VARBINARY); &#125; @Override public Object invoke(Object proxy, Method method, Object[] params) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, params); &#125; Object o = method.invoke(rs, params); if (\"next\".equals(method.getName())) &#123; //是否还有下一行 if ((Boolean) o) &#123; rows++; if (isTraceEnabled()) &#123; ResultSetMetaData rsmd = rs.getMetaData(); //获取数据集的列数 final int columnCount = rsmd.getColumnCount(); if (first) &#123; first = false; //输出表头，并填充超大长度的类型到集合中 printColumnHeaders(rsmd, columnCount); &#125; //输出该行记录，注意会过滤掉blobColumns中记录的列， //这些列的数据较大，不会输出到日志 printColumnValues(columnCount); &#125; &#125; else &#123; //遍历ResultSet之后输出总，完例子：Total: 1 debug(\" Total: \" + rows, false); &#125; &#125; clearColumnInfo();//清空BaseJdbcLogger的三个column*集合 return o; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; //例子：Header: [count(*)] private void printColumnHeaders(ResultSetMetaData rsmd, int columnCount) throws SQLException &#123; StringBuilder row = new StringBuilder(); row.append(\" Columns: \"); for (int i = 1; i &lt;= columnCount; i++) &#123; if (BLOB_TYPES.contains(rsmd.getColumnType(i))) &#123; blobColumns.add(i); &#125; String colname = rsmd.getColumnLabel(i); row.append(colname); if (i != columnCount) &#123; row.append(\", \"); &#125; &#125; trace(row.toString(), false); &#125; //例子：Row: 39 private void printColumnValues(int columnCount) &#123; StringBuilder row = new StringBuilder(); row.append(\" Row: \"); for (int i = 1; i &lt;= columnCount; i++) &#123; String colname; try &#123; if (blobColumns.contains(i)) &#123; colname = \"&lt;&lt;BLOB&gt;&gt;\"; &#125; else &#123; colname = rs.getString(i); &#125; &#125; catch (SQLException e) &#123; // generally can't call getString() on a BLOB column colname = \"&lt;&lt;Cannot Display&gt;&gt;\"; &#125; row.append(colname); if (i != columnCount) &#123; row.append(\", \"); &#125; &#125; trace(row.toString(), false); &#125;...&#125;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochikai.github.io/tags/Mybatis/"}]},{"title":"Mybatis技术内幕源码解析：类型转换","date":"2019-12-20T12:40:00.000Z","path":"2019/12/20/Mybatis技术内幕-第二章：2-3类型转换/","text":"2.3、类型转换 JDBC数据类型与Java语言中的数据类型并不是完全对应的，所以在PreparedStatement为SOL语句绑定参数时，需要从Java类型转换成JDBC类型，而从结果集中获取数据时，则需要从JDBC类型转换成Java类型。MyBatis使用类型处理器完成上述两种转换。 upload successful 2.3.1、TypeHandler Mybatis当中所有类型转化器都继承BaseTypeHandler，而BaseTypeHandler又实现了TypeHandler接口。接口定义了四个方法，分成两类：setParameter()方法负责将数据由JdbcType 类型转换成Java类型；getResult()方法及其重载负责将数据由Java类型转换成JdbcType类型。 1234567891011121314151617181920212223242526package org.apache.ibatis.type;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;&#x2F;** * @author Clinton Begin *&#x2F;public interface TypeHandler&lt;T&gt; &#123; &#x2F;&#x2F;在通过Preparedstatement为SQL语句绑定参数时，会将数据由JdbcType类型转换成Java类型 void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException; &#x2F;** * @param columnName Colunm name, when configuration &lt;code&gt;useColumnLabel&lt;&#x2F;code&gt; is &lt;code&gt;false&lt;&#x2F;code&gt; *&#x2F; &#x2F;&#x2F;从ResultSet中获取数据，通过字段名称将数据由Java类型转换成JdbcType类型 T getResult(ResultSet rs, String columnName) throws SQLException; &#x2F;&#x2F;从ResultSet中获取数据，通过字段下标（同上面getResult） T getResult(ResultSet rs, int columnIndex) throws SQLException; &#x2F;&#x2F;CallableStatement中通过下标获取结果 T getResult(CallableStatement cs, int columnIndex) throws SQLException;&#125; 一般类型转换器适用于单个参数或者单个列值完成类型转换，大多数是直接调用PreparedStatement、ResultSet、CallableStatement的对应方法， 以org.apache.ibatis.type.StringTypeHandler为例子如下： 1234567891011121314151617181920212223242526272829public class StringTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123; //调用PreparedStatement.setXXX(Type)绑定参数 ps.setString(i, parameter); &#125; @Override public String getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; //ResultSet.getXXX(Type)(列名称)获取列值 return rs.getString(columnName); &#125; @Override public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; //ResultSet.getXXX(Type)(列下标)获取列值 return rs.getString(columnIndex); &#125; @Override public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return cs.getString(columnIndex); &#125;&#125; 2.3.2、TypeHandlerRegistry TypeHandlerRegistry管理所有的类型转化器，register()方法实现了注册功能，过程中会向下述字段集合添加TypeHandler。 1234567891011121314151617181920212223package org.apache.ibatis.type;import .../** * @author Clinton Begin * @author Kazuki Shimizu */public final class TypeHandlerRegistry &#123; //在读取结果数据时候，依靠该集合映射从jdbcType转换成javaType， //而JdbcType类型为org.apache.ibatis.type.JdbcType枚举类型 private final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcTypeHandlerMap = new EnumMap&lt;&gt;(JdbcType.class); //记录了Java类型向指定Jdbcrype转换时，需要使用的TypeHandler对象。例如；Java类型中的string可能 //转换成教据库的 char、varchar等多种类型，所以存在一对多关系 private final Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = new ConcurrentHashMap&lt;&gt;(); //Object类型TypeHandler处理类 private final TypeHandler&lt;Object&gt; unknownTypeHandler = new UnknownTypeHandler(this); //全部Java类型以及对应的TypeHandler private final Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap = new HashMap&lt;&gt;(); //空TypeHandler集合的标识 private static final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; NULL_TYPE_HANDLER_MAP = Collections.emptyMap(); //枚举类型的TypeHandler集合 private Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler = EnumTypeHandler.class;&#125;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochikai.github.io/tags/Mybatis/"}]},{"title":"Mybatis技术内幕源码解析：反射工具箱","date":"2019-12-19T13:24:00.000Z","path":"2019/12/19/Mybatis技术内幕-第二章：基础层/","text":"第二章：基础支持层 Mybatis以SqlSessionFactory为核心，通过SqlSessionFactoryBuilder解析xml配置文件或Configration实例构建出SqlSessionFactory的实例。 一、重要概念 命名空间（Namespaces）：通常包名加类目组成完全限定名（com.MyMapper.selectAll），实现语句隔离确定唯一性。 作用域（Scope）和生命周期 SqlSessionFactoryBuilder：完成创建SqlSessionFactory后就不再需要。 SqlSessionFactory：最佳作用域是应用作用域，最优解是使用单例模式或者静态单例模式。 SqlSession：最佳的作用域是请求或方法作用域 2.2、反射工具箱 Mybatis进行参数处理、结果映射会涉及到大量的反射操作。Java反射功能虽然强大，但是代码复杂易错，所以在mybaits源码包org.apache.ibatis.reflection有专门的反射模块。 2.2.1 Reflector&amp;ReflectorFactory Reflector是反射模块的基础类，一个reflecotr实例对应一个类的元信息。根据Java Bean规范，封装的对getter、setter属性方法映射。 Reflector成员字段分析如下： 12345678910111213141516171819202122232425262728293031package org.apache.ibatis.reflection;import ....（省略导入类）&#x2F;** * This class represents a cached set of class definition information that * allows for easy mapping between property names and getter&#x2F;setter methods. * * @author Clinton Begin *&#x2F;public class Reflector &#123; &#x2F;&#x2F;对应的class类型 private final Class&lt;?&gt; type; &#x2F;&#x2F;getter方法对应的属性名称数组 private final String[] readablePropertyNames; &#x2F;&#x2F;setter方法对应的属性名称数组 private final String[] writablePropertyNames; &#x2F;&#x2F;属性对应的setter方法集合，key是属性名称，value是Invoker对象 private final Map&lt;String, Invoker&gt; setMethods &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F;属性对应的getter方法集合，key是属性名称，value是Invoker对象 private final Map&lt;String, Invoker&gt; getMethods &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F;记录了属性相应的setter方法的参数值类型，key是属性名称，value是setter方法的参数类型 private final Map&lt;String, Class&lt;?&gt;&gt; setTypes &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F;记录了属性相应的getter方法的参数值类型，key是属性名称，value是setter方法的参数类型 private final Map&lt;String, Class&lt;?&gt;&gt; getTypes &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F;记录默认构造器 private Constructor&lt;?&gt; defaultConstructor; &#x2F;&#x2F;所有属性名称集合 private Map&lt;String, String&gt; caseInsensitivePropertyMap &#x3D; new HashMap&lt;&gt;(); &#125; ReflectorFactory接口定义了Reflector对象创建或者缓存 12345678910package org.apache.ibatis.reflection;public interface ReflectorFactory &#123; &#x2F;&#x2F;确定是否需要缓存该Reflector对象 boolean isClassCacheEnabled(); &#x2F;&#x2F;设置是否缓存该Reflector对象 void setClassCacheEnabled(boolean classCacheEnabled); &#x2F;&#x2F;刘建指定Class对应的Reflector对象 Reflector findForClass(Class&lt;?&gt; type);&#125; DefaultReflectorFactory默认实现ReflectorFactory，而CustomReflectorFactory继承DefaultReflectorFactory并且空实现，其关系图如下 DefaultReflectorFactory 12345678910111213141516171819202122232425262728293031323334353637package org.apache.ibatis.reflection;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;public class DefaultReflectorFactory implements ReflectorFactory &#123; &#x2F;&#x2F;该字段决定是否开启对Reflector对象 private boolean classCacheEnabled &#x3D; true; &#x2F;&#x2F;使用ConcurrentMap集合实现对Reflector对象的缓存 private final ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap &#x3D; new ConcurrentHashMap&lt;&gt;(); public DefaultReflectorFactory() &#123; &#125; @Override public boolean isClassCacheEnabled() &#123; return classCacheEnabled; &#125; @Override public void setClassCacheEnabled(boolean classCacheEnabled) &#123; this.classCacheEnabled &#x3D; classCacheEnabled; &#125; @Override public Reflector findForClass(Class&lt;?&gt; type) &#123; if (classCacheEnabled) &#123;&#x2F;&#x2F;检测是否开启缓存 &#x2F;&#x2F; synchronized (type) removed see issue #461 &#x2F;&#x2F;通过线程安全ConcurrentHashMap获取缓存Reflector，没有则通过lambada调用构造新建对象 return reflectorMap.computeIfAbsent(type, Reflector::new); &#125; else &#123; &#x2F;&#x2F;未开启缓存则直接new Reflector对象 return new Reflector(type); &#125; &#125;&#125;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://caochikai.github.io/tags/Mybatis/"}]},{"title":"HttpServletRequest流重复读","date":"2019-12-18T12:30:00.000Z","path":"2019/12/18/HttpServletRequest流重复读/","text":"HttpServletRequest流重复读 springmvc controller @RequestBody接受参数报错，原因为http POST请求报文体为二进制流，在HttpServletRequest.getInputStream()中流只能被读取一次，重复读取会报如下： 1getRead() has already been called for this request&#x2F;getInputStream() has already been called for this request 一、解决方式 第一种方式：重写HttpServletRequestWrapper 将InputStream 替换成可重复读的ByteArrayInputStream，原理就是在Filter或者springmvc的interceptor中通过构造器包装HttpServletRequest，并且把当前流缓存起来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.ServletRequest;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.nio.charset.Charset;/** * 自定义HttpServletRequestWrapper * 解决InputStream不能重复读问题 * */public class BufferedServletRequestWrapper extends HttpServletRequestWrapper &#123; private final byte[] body; BufferedServletRequestWrapper(HttpServletRequest request) throws IOException &#123; super(request); String sessionStream = getBodyString(request); body = sessionStream.getBytes(Charset.forName(\"UTF-8\")); &#125; /** * 获取请求Body */ private String getBodyString(final ServletRequest request) &#123; StringBuilder sb = new StringBuilder(); InputStream inputStream = null; BufferedReader reader = null; try &#123; inputStream = cloneInputStream(request.getInputStream()); reader = new BufferedReader(new InputStreamReader(inputStream, Charset.forName(\"UTF-8\"))); String line = \"\"; while ((line = reader.readLine()) != null) &#123; sb.append(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return sb.toString(); &#125; /** * 复制输入流 */ private InputStream cloneInputStream(ServletInputStream inputStream) &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; try &#123; while ((len = inputStream.read(buffer)) &gt; -1) &#123; byteArrayOutputStream.write(buffer, 0, len); &#125; byteArrayOutputStream.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); &#125; @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; final ByteArrayInputStream bais = new ByteArrayInputStream(body); return new ServletInputStream() &#123; @Override public int read() throws IOException &#123; return bais.read(); &#125; &#125;; &#125;&#125; 第二种方式：Springmvc提供了解决方案ContentCachingRequestWrapper，思路也是一样，只不过代码更加严谨点。源码我就不贴了，开头注释说明贴一下，然后需要注意事项和正确的使用方式如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** *ContentCachingRequestWrapper源码注释如下 * &#123;@link javax.servlet.http.HttpServletRequest&#125; wrapper that caches all content read from * the &#123;@linkplain #getInputStream() input stream&#125; and &#123;@linkplain #getReader() reader&#125;, * and allows this content to be retrieved via a &#123;@link #getContentAsByteArray() byte array&#125;. * * &lt;p&gt;Used e.g. by &#123;@link org.springframework.web.filter.AbstractRequestLoggingFilter&#125;. * * @author Juergen Hoeller * @author Brian Clozel * @since 4.1.3 * @see ContentCachingResponseWrapper */package com.qm.interceptor;import org.springframework.web.util.ContentCachingRequestWrapper;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;/** * 配置哪些请求可以进行重复读数据 * */public class cachingRequestBodyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // 防止流读取一次后就没有了, 所以需要将流继续写出去 HttpServletRequest httpServletRequest = (HttpServletRequest) request; String requestURI = httpServletRequest.getRequestURI(); // 这里将原始request传入，读出流并存储 //PATH 为可重复读的路径开始或者接受部分 例如：caching.do if (requestURI.endsWith(\"caching.do\")) &#123; // 这里将原始request传入，读出流并存储 ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(httpServletRequest); // 这里将原始request替换为包装后的request，此后所有进入controller的request均为包装后的request chain.doFilter(requestWrapper, response); &#125; else &#123;// 不要覆盖所有的请求，防止覆盖其他人请求 chain.doFilter(request, response); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; 二、参考如下：HttpServletRequest数据流重复读问题","tags":[{"name":"Spring","slug":"Spring","permalink":"https://caochikai.github.io/tags/Spring/"}]},{"title":"BigDecimal金额计算","date":"2019-12-16T16:26:58.000Z","path":"2019/12/17/BigDecimal金额计算/","text":"关于金额计算，通常有加减乘除，四舍五入等。 add()加法函数：要注意BigDecimal加法得到的结果为零，因为BigDecimal的加法需要一个值去接收，加法不会改变调用者自身的值。 subtract()减法函数：同加法； multiply()乘法函数：注意Double转BigDecimal，尽量用字符串的形式初始化。因为使用BigDecimal类构造方法传入double类型时，计算的结果是不精确的！ divide()除法函数：避免抛出除零异常，方式将除运算尽量转换成等价的乘运算。 保留两位小数且四舍五入：value.setScale(2, BigDecimal.ROUND_HALF_UP); BigDecimal静态常量值，比如BigDecimal.ZERO等； 例子刨析：1234567891011121314151617181920212223242526BigDecimal num1 = new BigDecimal(0.005); BigDecimal num2 = new BigDecimal(1000000); BigDecimal num3 = new BigDecimal(-1000000); //尽量用字符串的形式初始化 BigDecimal num12 = new BigDecimal(\"0.005\"); BigDecimal num22 = new BigDecimal(\"1000000\"); BigDecimal num32 = new BigDecimal(\"-1000000\");//加法 BigDecimal result1 = num1.add(num2); BigDecimal result12 = num12.add(num22); //减法 BigDecimal result2 = num1.subtract(num2); BigDecimal result22 = num12.subtract(num22); //乘法 BigDecimal result3 = num1.multiply(num2); BigDecimal result32 = num12.multiply(num22); //绝对值 BigDecimal result4 = num3.abs(); BigDecimal result42 = num32.abs(); //除法 BigDecimal result5 = num2.divide(num1,20,BigDecimal.ROUND_HALF_UP); BigDecimal result52 = num22.divide(num12,20,BigDecimal.ROUND_HALF_UP); result全部输出结果，初始化建议使用String 结果 参考如下BigDecimal加减乘除计算","tags":[]},{"title":"Springboot+vue部署路由404","date":"2019-12-15T08:32:00.000Z","path":"2019/12/15/hello-world/","text":"问题背景vue单页面路由，刷新地址或者请求链接，都会404 user www; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; events { worker_connections 51200; multi_accept on; } http { include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; #gzip on; gzip on; server { listen 80; root /www/app/; server_name gdhxy.cn; try_files $uri $uri/ /index.html; } server { listen 80; root /www/app/; server_name www.gdhxy.cn; try_files $uri $uri/ /index.html; } server { listen 80; server_name admin.gdhxy.cn; try_files $uri $uri/ /index.html; location / { proxy_redirect off; proxy_pass http://127.0.0.1:38806; } } }解决方式 1、nginx配置：try_files $uri $uri/ /index.html；2、springboot指定404到index.html. import org.springframework.boot.web.servlet.error.ErrorController; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpServletRequest; @Controller public class MyErrorController implements ErrorController { @RequestMapping(&quot;/error&quot;) public String handleError(HttpServletRequest request) { //获取statusCode:404,重定向到首页 Integer statusCode = (Integer) request.getAttribute(&quot;javax.servlet.error.status_code&quot;); if (statusCode == 404) { return &quot;/index.html&quot;; } else { return &quot;/500&quot;; } } @Override public String getErrorPath() { return &quot;/error&quot;; } }","tags":[{"name":"Spring","slug":"Spring","permalink":"https://caochikai.github.io/tags/Spring/"}]},{"title":"服务器配置记录","date":"2019-09-27T16:48:12.000Z","path":"2019/09/28/服务器配置记录/","text":"服务器配置记录一、背景 真实生产环境部署：nginx、tomcat配置https证书 二、nginx安装过程：123456789101112131415//一键安装上面四个依赖yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel//下载tar包wget http://nginx.org/download/nginx-1.16.1.tar.gztar xzf nginx-1.16.1.tar.gz -C /usr/local//文件名改nginx-1.16.1成nginx//进入nginx目录cd /usr/local/nginx//关联编译https模块 ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module//执行make命令编译源码make//执行make install安装可执行binmake install//新建logs（日志）和ssl（证书）文件夹 https浏览器影响——混合内容 解决Nginx反代Tomcat Http、Https混合内容报错，浏览器认为https请求中资源是http的css、js和图片都无法正常加载，造成无法双协议兼容！ 12浏览器访问后开发者模式看到的报错信息：Mixed Content: The page at &#39;https:&#x2F;&#x2F;dashboard.domain.com&#x2F;wire&#39; was loaded over HTTPS, but requested an insecure stylesheet &#39;http:&#x2F;&#x2F;dashboard.domain.com&#x2F;static&#x2F;css&#x2F;flickity.css&#39;. This request has been blocked; the content must be served over HTTPS. nginx解决配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061user www;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;events &#123; worker_connections 51200; multi_accept on;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; #gzip on; gzip on; server &#123; listen 80; listen 443 ssl; server_name chinaffxz.com; #charset koi8-r; ssl_certificate /usr/local/nginx/ssl/2879444_chinagzhxy.com.pem; ssl_certificate_key /usr/local/nginx/ssl/2879444_chinagzhxy.com.key; location / &#123; proxy_pass http://127.0.0.1:xxxx/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #解决兼容配置要点 proxy_set_header X-Forwarded-Proto $scheme; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; Tomcat配置1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;Server port=\"8006\" shutdown=\"SHUTDOWN\"&gt; &lt;Listener className=\"org.apache.catalina.core.JreMemoryLeakPreventionListener\" /&gt; &lt;Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" /&gt; &lt;Listener className=\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\" /&gt; &lt;Listener className=\"org.apache.catalina.core.AprLifecycleListener\" /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name=\"UserDatabase\" auth=\"Container\" type=\"org.apache.catalina.UserDatabase\" description=\"User database that can be updated and saved\" factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\" pathname=\"conf/tomcat-users.xml\" /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name=\"Catalina\"&gt; &lt;Connector port=\"38080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" maxThreads=\"1000\" minSpareThreads=\"20\" acceptCount=\"1000\" maxHttpHeaderSize=\"65536\" debug=\"0\" disableUploadTimeout=\"true\" useBodyEncodingForURI=\"true\" enableLookups=\"false\" URIEncoding=\"UTF-8\" /&gt; &lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt; &lt;!-- 解决兼容要点--&gt; &lt;Valve className=\"org.apache.catalina.valves.RemoteIpValve\" remoteIpHeader=\"X-Forwarded-For\" protocolHeader=\"X-Forwarded-Proto\" protocolHeaderHttpsValue=\"https\"/&gt; &lt;Realm className=\"org.apache.catalina.realm.LockOutRealm\"&gt; &lt;Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\" resourceName=\"UserDatabase\" /&gt; &lt;/Realm&gt; &lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html Note: The pattern used is equivalent to using pattern=\"common\" --&gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt; &lt;Context path=\"\" docBase =\"mall\" debug=\"0\" reloadable=\"true\" crossContext=\"false\"/&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; git持续部署shell脚本 解决Linux CentOS中cp -f 复制强制覆盖的命令无效的方法，系统默认使用cp -i使用交互方式避免误操作，但在自动脚本中应当避免，推荐\\cp。 123456789101112#update codecd /root/dowload/mall/duoshanghugit fetch origin git pull &gt; /root/dowload/mall/logs/mall_git.log &amp;#package mvn package -Dmaven.test.skip=truesleep 2s#cp war to tomcat webapp\\cp -fr /root/dowload/mall/duoshanghu/target/mall.war /usr/local/env/tomcat/webapps/mall.warsleep 1s#restart.shsh /usr/local/env/tomcat/bin/restart.sh tomcat重启脚本1234567891011121314151617181920212223242526272829303132#!/bin/sh#初始化全局环境变量. /etc/profile#set java environmentexport CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib#查找tomcat的pidpid=`ps aux | grep tomcat | grep -v grep | grep -v Restart | grep -v restart | awk '&#123;print $2&#125;'`echo \"the tomcat pid is $pid\"#判断tomcat进程是否存在if [ -n \"$pid\" ];then sleep 1 pid=`ps aux | grep tomcat | grep -v grep | grep -v restart | grep -v Restart | awk '&#123;print $2&#125;'` if [ -n \"$pid\" ]; then sleep 1 echo \"tomcat进程将被杀?\" kill -9 $pid fi sleep 1 echo \"tomcat进程已经被杀死，先重新启动tomcat.\" service tomcat status sleep 1s service tomcat startelse echo \"tomcat进程不存在，先重新启动tomcat.\" service tomcat status sleep 1s service tomcat startfi maven编译完整依赖管理1、来源 解决webapp/WEB-INF/lib目录下的jar包无法用maven打包，且在linuxMaven编译报错[ERROR] Fatal Error: Unable to find package java.lang in classpath or bootclasspath，致命错误: 在类路径或引导类路径中找不到程序包 java.lang 2、解决方法Linux解决办法，使用maven自带的变量${path.separator}路径分隔符，原因是在Windows下是分号;，在linux下是冒号: 同时配置导入webapp/WEB-INF/lib和jdk的rt.jar、jce.jar，完美解决环境配置带来的无法package找不到依赖问题。 pom.xml：12345678910111213141516171819202122232425262728293031323334&lt;build&gt; &lt;finalName&gt;$&#123;artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;compilerArguments&gt; &lt;verbose /&gt; &lt;bootclasspath&gt;$&#123;java.home&#125;/lib/rt.jar$&#123;path.separator&#125;$&#123;java.home&#125;/lib/jce.jar&lt;/bootclasspath&gt; &lt;extdirs&gt;$&#123;basedir&#125;/src/main/webapp/WEB-INF/lib&lt;/extdirs&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 参考解决Nginx反代Tomcat Http、Https混合内容报错 解决WEB-INF/lib目录下的jar包无法用maven打包 反馈与建议 当了组长面试加运维，对接一堆支付和物流、短信和推送账号，今天记录一下面向DevOps！ markdown原文件在github里面，感谢各位大佬看官star，面试我要往脸上贴金哈哈哈😂。 邮箱：caochikai@qq.com，有问题发邮件。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://caochikai.github.io/tags/Linux/"},{"name":"nginx","slug":"nginx","permalink":"https://caochikai.github.io/tags/nginx/"},{"name":"maven","slug":"maven","permalink":"https://caochikai.github.io/tags/maven/"},{"name":"tomcat","slug":"tomcat","permalink":"https://caochikai.github.io/tags/tomcat/"}]},{"title":"JVM记录","date":"2019-09-14T04:32:49.000Z","path":"2019/09/14/JVM记录/","text":"JVM记录一、错误 背景：自动答题爬虫由于买的腾讯云1核2G1M，Jenkins、springboot爬虫和火狐浏览器驱动。 知识背景：JDWP：调试网络协议(Java Debug Wire Protocol)；调试线协议；jvmti：（Java Virtual Machine Tool Interface）jvm代理； 猜测：Selenium通过driver驱动Firefox浏览器，多次无法关闭浏览器造成内存无法释放最后溢出； 引用文章（有兴趣可深入了解）：jvmti agent黑科技，阿里云云监控； 1FATAL ERROR in native method: JDWP Can&#39;t allocate jvmti memory, jvmtiError&#x3D;JVMTI_ERROR_OUT_OF_MEMORY(110) 反馈与建议 立个flag：不定期更新，一更一周。 markdown原文件在github里面，感谢各位大佬看官star，面试我要往脸上贴金哈哈哈😂。 邮箱：caochikai@qq.com，有问题发邮件。","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"},{"name":"JVM","slug":"JVM","permalink":"https://caochikai.github.io/tags/JVM/"}]},{"title":"工具收藏——idea推荐插件","date":"2019-05-22T12:34:48.000Z","path":"2019/05/22/工具收藏——idea推荐插件/","text":"工具收藏——idea推荐插件一、概念 ​ 工欲善其事必先利其器，博主是个死忠工具派，为了解决一个大问题可能会收集多个工具和方案，然后求证对比出体验报告。后续文章有一大类就是工具类推荐，而本篇文章重点就是idea 安装插件记录，简要记录安装方法快速搭建个性化idea，还有一些关于UI方面插件可谓多不胜数，而且每个人口味不一，请各位自行选择——插件搜索技巧tags为Theme或者UI。 插件列表最强大插件卫冕之王——lambda表达式 名称 描述 JRebel 代替springboot dev热部署方案，最方便激活方式 Lombok 精简bean，各种功能强大又实用注解，搬砖人的MVP，结合Hutool实在完美 AceJump 光标跳跃，替代vim不二之选 MavenHelper 快速分析maven 包冲突的问题，搜索包名 MyBatis Log Plugin Restore the mybatis generate sql to original whole sql.（拼接完整sql） Log Support 2 快速log.info()，结合Lombok插件注解@Slf4j可以说无敌 Free Mybatis plugin Mybaits支持跳转，有钱大爷请收费版Mybatis plugin强大破解较少，差评 Rainbow Brackets 彩虹括号，多层嵌套代码显示助手 String Manipulation 各种各样字符串格式转化 RestfulToolkit 一套 RESTful 服务开发辅助工具集 Alibaba Cloud Toolkit 结合阿里云（非阿里也支持），多节点发布工具加强力linux客户端 stackoverflow stackoverflow快速搜索bug插件 Translation 最强大的翻译插件，支持中文替换英文，解决起英文变量名难的重度患者 Key Promoter X 所有操作的快捷键提示，忘记鼠标真的 Cyan Light Theme A light theme，偏青色对眼睛很柔和舒服，黑暗主题实在不适应 反馈与建议 2012年java程序员可以说非常吃香，今年2019从业人数暴增，职业发展挑战变得越来越大！现在流行自动构建和自动部署CI，开发运维一体化docker，整个互联网都在追求敏捷开发的今天。掌握一款追求效率功能的IDE非常重要，很多群和公众号对ide和Eclipse争议很大。但请记住斯大林名言——落后就要挨打，ide本身代表高效，但是插件也别装太多，免得启动还要半天哈哈哈😀 （首推）慕课网免费教程：IntelliJ IDEA神器使用技巧 （推荐）尚硅谷IDEA视频教程：链接：https://pan.baidu.com/s/11biVBv9EI9yfL6Cee0r0LQ，密码：n7hn 看完上面两个教程，你会怀疑自己用的idea是假的，原来写代码还可以这样的。 邮箱：caochikai@qq.com","tags":[{"name":"tool","slug":"tool","permalink":"https://caochikai.github.io/tags/tool/"},{"name":"plugin","slug":"plugin","permalink":"https://caochikai.github.io/tags/plugin/"},{"name":"idea","slug":"idea","permalink":"https://caochikai.github.io/tags/idea/"}]},{"title":"springboot整合elasticsearch","date":"2019-05-21T13:40:31.000Z","path":"2019/05/21/springboot整合elasticsearch/","text":"springboot整合elasticsearch一、概念 elasticsearch官网是一个分布式多用户能力的全文搜索引擎，也是一个具有RESTful web接口的java应用。目前开源软件商业比较不错的例子，与Solr一样都是基于Lucene，大数据hadoop也是脱胎于Lucene。Solr开源而且生态比较成熟，elasticsearch目前最火也是商业应用方面非常好的搜索引擎。 3w原则： question what：常见站内/app内搜索服务需求：商品文章的模糊搜索，精确搜索，拼音搜索 。 question why：借助elasticsearch和analysis-ik中文分词器，快速实现搜索服务功能。 how：在微服务当中，通常利用mq消息中间件来同步数据集群搜索服务（脚手架里没有mq），借助ElasticsearchTemplate（spring 模板工具类强大）API维护索引和搜索查询。 二、落地实现 根据码云企业级搜索脚手架的文档可知，注意版本为Springboot2.1.1+elasticsearch6.5.3，elasticsearch和analysis-ik插件版本必须统一，而且新版本elasticsearch 7不适用于该工程。这个参考工程的中文分词搜索效果不太理想，一般富文本的内容进入索引之前要利用字符过滤器清洗不正常的字符。通常为了保证索引时覆盖度和搜索时准确度,索引分词器采用ik_max_word,搜索分析器采用ik_smart模式。具体elasticsearch6.5.3的安装过程请参考码云的README.md，目前正在在公司项目使用请放心，单元测试的效果也非常nice。 1、添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置引导类12345#============================# 默认的节点名称elasticsearchspring.data.elasticsearch.cluster-name=my-application# elasticsearch 调用地址，多个使用“,”隔开spring.data.elasticsearch.cluster-nodes=localhost:9300 3、DWMQSender包装rabbitTemplate发送消息同步数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//服务类的简写如下&#123;//注入sender @AutowiredDWMQSender sender;//发送写法ArticlesMessage extends DWMQMessage&lt;消息内容类型&gt;JSONObject jsonObject = JSON.parseObject(JSON.toJSONString(articles)); jsonObject.put(Groups.ACTION, Groups.ADD); sender.sendMessage(new ArticlesMessage(jsonObject));&#125;//封装发送mq messageimport com.alibaba.fastjson.JSON;import com.dwalk.common.exception.EU;import com.dwalk.common.mq.mto.DWMQMessage;import com.dwalk.common.utils.SU;import com.rabbitmq.client.Channel;import lombok.extern.slf4j.Slf4j;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.amqp.AmqpException;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.MessagePostProcessor;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.amqp.rabbit.support.CorrelationData;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.util.concurrent.atomic.AtomicLong;/** * 消息成功发送到MQ服务器后的回调确认 */@Slf4j@Componentpublic class DWMQSender &#123; @Autowired RabbitTemplate rabbitTemplate; @Autowired DWMQRetry retry; // public void sendMessage(DWMQMessage mto) &#123; if( mto.getObj()==null ) &#123; EU.te(\"消息内容为空\"); &#125; if( SU.isNull( mto.getRoutingKey()) ) &#123; EU.te(\"路由规则为空\"); &#125; log.info(String.format(\"准备发送【%s】\", mto.getInfo())); mto.setId(retry.generateId()); if( SU.isNull(mto.getExchange()) &amp;&amp; mto.getExpire()&lt;1 ) &#123; //默认的没有交换器，则直接发送到指定的队列 rabbitTemplate.convertAndSend(mto.getRoutingKey(), mto.getObj(), new CorrelationData(mto.getId())); &#125; else if (mto.getExpire()&lt;1)&#123; //经过交换器，按路由规则匹配队列 rabbitTemplate.convertAndSend(mto.getExchange(), mto.getRoutingKey(), mto.getObj(), new CorrelationData(mto.getId())); &#125; else &#123; //默认的没有交换器，则直接发送到指定的队列，发送延迟消息 rabbitTemplate.convertAndSend(mto.getRoutingKey(), mto.getObj(), message -&gt; &#123; message.getMessageProperties().setExpiration(mto.getExpire()+\"\"); return message; &#125;, new CorrelationData(mto.getId())); &#125; mto.setCtime(System.currentTimeMillis()); retry.add(mto, this); &#125;&#125; 4、RabbitListener接收到消息同步数据123456789101112131415161718192021222324252627282930313233343536373839/** * 搜索服务接收到管理后台用户修改文章同步消息 */@Component@Slf4j//配置mq消息队列，接收文件同步消息@RabbitListener(queues = DirectMQConfig.DIRECT_ARTICLES_ELASTIC_QUEUE)public class ArticlesReceiver extends DWMQBaseReceiver&lt;String&gt; &#123; @Autowired private ArticleETOService etoService; @Override public Class getClazz() &#123; return String.class; &#125; @Override public boolean processMessage(String mto) &#123; log.info(\"Received 管理后台用户-修改文章同步消息接收:&#123;&#125;\", mto); JSONObject jsonObject = JSON.parseObject(mto); String action = jsonObject.getString(Groups.ACTION); //删除操作要删除索引，更新操作先删除后 ArticleETO articles = JSON.parseObject(jsonObject.toJSONString(), ArticleETO.class); String articlesId = articles.getId(); switch (action) &#123; case Groups.ADD: etoService.save(articles); break; case Groups.UPDATE: etoService.delete(articlesId); etoService.save(articles); break; case Groups.DELETE: etoService.delete(articlesId); break; &#125; return true; &#125;&#125; 5、公共搜索方法12345678910111213141516171819202122232425262728/** * 高亮显示，返回分页 * @auther: zhoudong * @date: 2018/12/18 10:29 */ @Override public IPage&lt;Map&lt;String, Object&gt;&gt; queryHitByPage(int pageNo, int pageSize, String keyword, String indexName, String... fieldNames) &#123; // 构造查询条件,使用标准分词器. QueryBuilder matchQuery = createQueryBuilder(keyword, fieldNames); // 设置高亮,使用默认的highlighter高亮器 HighlightBuilder highlightBuilder = createHighlightBuilder(fieldNames); // 设置查询字段 SearchResponse response = elasticsearchTemplate.getClient().prepareSearch(indexName) .setQuery(bool) .highlighter(highlightBuilder) .setFrom((pageNo - 1) * pageSize) .setSize(pageNo * pageSize) // 设置一次返回的文档数量，最大值：10000 .get(); // 返回搜索结果 SearchHits hits = response.getHits(); Long totalCount = hits.getTotalHits(); IPage&lt;Map&lt;String, Object&gt;&gt; page = new Page&lt;&gt;(pageNo, pageSize, totalCount); page.setRecords(getHitList(hits)); return page; &#125; 反馈与建议 今天终于出了elasticsearch文章，以后我会在对应专题的文章放出相关的百度云资源，这些都是网上流传比较广的资源，想找好的学习资源也可以与我合伙买绝版视频，有钱买正版吧（作者很穷，找工作从来没有造假包装，只能混成这个卵样😭，世道维艰，如果不是感觉做码农还算有点天赋，早就转行了）。 百度云 :下载街/01.Elasticsearch顶尖高手系列课程，密码：iw7f 邮箱：caochikai@qq.com","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://caochikai.github.io/tags/elasticsearch/"}]},{"title":"Springboot整合Quartz定时器","date":"2019-05-20T12:25:37.000Z","path":"2019/05/20/Spring boot整合Quartz定时器/","text":"Spring boot整合Quartz定时器一、概念 quartz官网是一个完全由 Java 编写的开源作业调度框架，结合数据库甚至可以做到分布式调度。目前参考的RuoYi后台脚手架的定时任务模块，支持在线（添加、修改、删除)任务调度，并记录执行日志作业结果。 3w原则： question what：定时任务，比如定时答题、商家结算等需求，并且支持立即运行、暂停和禁止。 question why：借助quartz springboot生态和后台脚手架，快速实现定时调度功能。 how：实现JobDetail运行任务详情，Trigger 触发器定义触发规则，Scheduler 调度中心/容器注册多个 JobDetail 和 Trigger。Trigger 与 JobDetail 组合即可被Scheduler调用。 二、落地实现 根据若依脚手架的文档可知，定时任务工程模块为ruoyi-quartz，结合sql/quartz.sql导入关于定时器数据库表。当然这种做法需要数据库和bootstrap，为了简化，我采取的替代方案是保留定时和立即执行功能，抛弃手动在代码硬编码新加定时器，web管理面板则通过swagger触发任务调度立即执行一次。极端偷懒方式，@Scheduled(cron = “”)放在在cotroller方法，同事推荐给我的😀。 1、添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置引导类1234567//模块加载@EnableScheduling@EnableSwagger2@SpringBootApplicationpublic class WeixinApplication &#123;......&#125; 3、注册JobDetail和Trigger1234567891011121314151617181920212223/** * 在线表达式：http://cron.qqe2.com/ */@Slf4j@Configurationpublic class QuartzConfig &#123; public static final String TASK_CLASS_NAME = \"reportNowTask\"; @Bean public JobDetail reportNowTask() &#123; return JobBuilder.newJob(reportNowTask.class).withIdentity(TASK_CLASS_NAME).storeDurably().build(); &#125; @Bean public Trigger reportNowTaskTrigger(JobDetail reportNowTask) &#123; //cronSchedule等于@Scheduled(cron = \"\"),但是通过注解无法配置jobkey return TriggerBuilder.newTrigger().forJob(reportNowTask) .withIdentity(\"reportNowTaskTrigger\") .withSchedule(CronScheduleBuilder.cronSchedule(\"9 0 19 * * ?\")) .build(); &#125;&#125; 4、任务详情继承QuartzJobBean或者实现Job接口12345678@Slf4jpublic class reportNowTask extends QuartzJobBean &#123; @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123; ......//任务内容 &#125;&#125; 5、立即执行123456789101112131415161718@Slf4j@Api(tags = \"问题模块\")@RequestMapping(value = \"question\")@RestControllerpublic class QuestionController &#123; /** * 任务调度立即执行一次 */ @PostMapping(\"/run\") @ResponseBody public ResponseEntity run() throws SchedulerException &#123; //api秘诀就在这里根据QuartzConfig jobKey触发作业调度 scheduler.triggerJob(JobKey.jobKey(QuartzConfig.TASK_CLASS_NAME)); return ResponseEntity.ok(\"执行成功！\"); &#125;&#125; 反馈与建议 今天粗略简易版的定时任务,功能强大的请查看若依后台脚手架,github和码云有很多类似脚手架,但是我们有选择性copy学习才是重点😊。 邮箱：caochikai@qq.com","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"},{"name":"quartz","slug":"quartz","permalink":"https://caochikai.github.io/tags/quartz/"}]},{"title":"springboot源码分析之启动过程","date":"2019-05-19T13:50:35.000Z","path":"2019/05/19/springboot源码分析之启动过程/","text":"springboot源码分析之启动过程一、概念 计划写一波springboot 2.x源码分析，只写实用性比较高的特性，从GitHub上看出更新频率在一个月左右，更新极快非常活跃。 版本发行: 版本 时间线 说明 v0.5.0.M1 2013-08-06 第一个版本 v2.2.0.M3 2019-05-15 当前最新版本 二、源码分析 SpringBoot的启动引导类写法多样，标记了@SpringBootApplication的class作为源类，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//简易版@SpringBootApplication public class MyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyApplication.class, args); &#125; &#125;//通过 SpringApplicationBuilder API@SpringBootApplicationpublic class DiveInSpringBootApplication &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(DiveInSpringBootApplication.class) .bannerMode(Banner.Mode.CONSOLE) .web(WebApplicationType.NONE) .profiles(\"prod\") .headless(true) .run(args); &#125;&#125;//声明newpublic class SpringApplicationBootstrap &#123; public static void main(String[] args) &#123;// SpringApplication.run(ApplicationConfiguration.class,args); Set sources = new HashSet(); // 配置Class 名称 sources.add(ApplicationConfiguration.class.getName()); SpringApplication springApplication = new SpringApplication(); //配置源 springApplication.setSources(sources); //配置控制台banner springApplication.setBannerMode(Banner.Mode.CONSOLE); //声明web类型 springApplication.setWebApplicationType(WebApplicationType.NONE); //多环境配置激活 springApplication.setAdditionalProfiles(\"prod\"); //java.awt.headless禁用模式 springApplication.setHeadless(true); springApplication.run(args); &#125; @SpringBootApplication public static class ApplicationConfiguration &#123; &#125;&#125; 从代码上可以看出，调用了SpringApplication的静态方法run。这个run方法会构造一个SpringApplication的实例，然后再调用这里实例的run方法就表示启动SpringBoot。因此，想要分析SpringBoot的启动过程，我们需要熟悉SpringApplication的构造过程以及SpringApplication的run方法执行过程即可。 SpringApplication的准备过程 配置 Spring Boot Bean 源：Java 配置 Class 或 XML 上下文配置文件集合，用于 Spring Boot BeanDefinitionLoader 读取 ，并且将配置源解析加载为Spring Bean 定义。 推断 Web 应用类型：根据当前应用 ClassPath 中是否存在相关实现类来推断 Web 应用的类型。参考方法：org.springframework.boot.SpringApplication#deduceWebApplicationType。 123456789101112private WebApplicationType deduceWebApplicationType() &#123; if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null) &amp;&amp; !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)) &#123; return WebApplicationType.REACTIVE; &#125; for (String className : WEB_ENVIRONMENT_CLASSES) &#123; if (!ClassUtils.isPresent(className, null)) &#123; return WebApplicationType.NONE; &#125; &#125; return WebApplicationType.SERVLET;&#125; 推断引导类（Main Class）：根据 Main 线程执行堆栈判断实际的引导类。参考方法： org.springframework.boot.SpringApplication#deduceMainApplicationClass 123456789101112131415private Class deduceMainApplicationClass() &#123; try &#123;//获取堆栈输出方法名称 StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) &#123; if (\"main\".equals(stackTraceElement.getMethodName())) &#123; return Class.forName(stackTraceElement.getClassName()); &#125; &#125; &#125; catch (ClassNotFoundException ex) &#123; // Swallow and continue &#125; return null; &#125; 加载应用上下文初始器 （ ApplicationContextInitializer ）：利用 Spring 工厂加载机制，实例化 ApplicationContextInitializer 实现类，并排序对象集合。 1234567891011121314//实现类： org.springframework.core.io.support.SpringFactoriesLoader//配置资源： META-INF/spring.factories//排序： AnnotationAwareOrderComparator#sortprivate Collection getSpringFactoriesInstances(Class type, Class[] parameterTypes, Object... args) &#123; ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); // Use names and ensure unique to protect against duplicates Set names = new LinkedHashSet&lt;&gt;( SpringFactoriesLoader.loadFactoryNames(type, classLoader)); List instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); AnnotationAwareOrderComparator.sort(instances); return instances; &#125;· 加载应用事件监听器（ ApplicationListener ）：利用 Spring 工厂加载机制，实例化 ApplicationListener 实现类，并排序对象集合。 SpringApplication 运行阶段 加载 SpringApplication 运行监听器（ SpringApplicationRunListeners ）：利用 Spring 工厂加载机制，读取 SpringApplicationRunListener 对象集合，并且封装到组合类SpringApplicationRunListeners。 运行 SpringApplication 运行监听器（ SpringApplicationRunListeners ）： started(run方法执行的时候立马执行；对应事件的类型是ApplicationStartedEvent) environmentPrepared(ApplicationContext创建之前并且环境信息准备好的时候调用；对应事件的类型是ApplicationEnvironmentPreparedEvent) contextPrepared(ApplicationContext创建好并且在source加载之前调用一次；没有具体的对应事件) contextLoaded(ApplicationContext创建并加载之后并在refresh之前调用；对应事件的类型是ApplicationPreparedEvent) finished(run方法结束之前调用；对应事件的类型是ApplicationReadyEvent或ApplicationFailedEvent) 创建 Spring 应用上下文（ ConfigurableApplicationContext ）:根据准备阶段的推断 Web 应用类型创建对应ConfigurableApplicationContext 实例： Web Reactive： AnnotationConfigReactiveWebServerApplicationContext Web Servlet： AnnotationConfigServletWebServerApplicationContext 非 Web： AnnotationConfigApplicationContext 创建 Environment：根据准备阶段的推断 Web 应用类型创建对应的 ConfigurableEnvironment 实例。 Web Reactive： StandardEnvironment Web Servlet： StandardServletEnvironment 非 Web： StandardEnvironment run方法分析1234567891011121314151617181920212223242526272829303132public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); // 构造一个任务执行观察器 stopWatch.start(); // 开始执行，记录开始时间 ConfigurableApplicationContext context = null; configureHeadlessProperty(); // 获取SpringApplicationRunListeners，内部只有一个EventPublishingRunListener SpringApplicationRunListeners listeners = getRunListeners(args); // 上面分析过，会封装成SpringApplicationEvent事件然后广播出去给SpringApplication中的listeners所监听 // 这里接受ApplicationStartedEvent事件的listener会执行相应的操作 listeners.started(); try &#123; // 构造一个应用程序参数持有类 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // 创建Spring容器 context = createAndRefreshContext(listeners, applicationArguments); // 容器创建完成之后执行额外一些操作 afterRefresh(context, applicationArguments); // 广播出ApplicationReadyEvent事件给相应的监听器执行 listeners.finished(context, null); stopWatch.stop(); // 执行结束，记录执行时间 if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; // 返回Spring容器 &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, ex); // 这个过程报错的话会执行一些异常操作、然后广播出ApplicationFailedEvent事件给相应的监听器执行 throw new IllegalStateException(ex); &#125;&#125; 反馈与建议 为了快大多分析的不好写的很乱，凑合看下我以后改下排版😂。 邮箱：caochikai@qq.com","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"},{"name":"quartz","slug":"quartz","permalink":"https://caochikai.github.io/tags/quartz/"}]},{"title":"地理定位业务实现","date":"2019-05-18T12:19:01.000Z","path":"2019/05/18/地理定位业务实现/","text":"地理定位业务实现一、概念3w原则： question what：a、附近一定范围的目标（电子围栏）；b、该经纬度的地理位置名称（省市县街道）。 why：解决上述问题的本质是获得经纬度，途径为硬件、GPS定位服务、基站定位，地理位置通过百度、谷歌、腾讯地图，基本所有地图免费版都有日访问量限制。 how：通过安卓或者IOS获取经纬度，再借助百度地图接口获取地理位置，距离也可通过接口或者谷歌地图算法。 GPS是英文Global Positioning System（全球定位系统）的简称。 二、解决方式 场景：小程序获取附近的好友，微信官方文档 wx.getLocation(Object object)。 现象：需要用户授权，前端获得gps 坐标通过接口传数据后台，保存到用户表（1：1关系）。 地图选择：其实纯前端基本也能解决基本问题，腾讯地图对小程序支持最好，根据JavaScript SDK文档可以拥有如下功能：绘制地图，地点搜索，关键词输入提示，逆地址解析（坐标位置描述），地址解析（地址转坐标，路线规划，距离计算，获取城市列表，获取城市区县。 业务前提：用户必须授权才能使用该功能，当拥有所有用户经纬度，通过数据库语句获取当前用户经纬度在一定距离，并且可以排行。 三、落地编码sql版例子：123456789101112131415161718192021222324252627#mysql版，根据谷歌地图公式计算点歌经纬度之间距离，单位为m（米）select e.id, e.longitude, e.latitude, ROUND( 6378.138 * 2 * ASIN( SQRT( POW( SIN( ( e.latitude * PI() / 180 - 23.12463 * PI() / 180 ) / 2 ), 2 ) + COS(e.latitude * PI() / 180) * COS(23.12463 * PI() / 180) * POW( SIN( ( e.longitude * PI() / 180 - 113.36189 * PI() / 180 ) / 2 ), 2 ) ) ) * 1000 ) AS distanceFROM dw_dbei_user ehaving distance &lt; 4000 工具类（获取两点距离）：12345678910111213141516171819202122232425262728293031323334public class MapUtils &#123; //private static double EARTH_RADIUS = 6378.137; private static double EARTH_RADIUS = 6371.393; private static double rad(double d) &#123; return d * Math.PI / 180.0; &#125; /** * 计算两个经纬度之间的距离 * * @param lat1 纬度1 * @param lng1 经度1 * @param lat2 纬度2 * @param lng2 经度2 * @return 计算结果单位：米 */ public static double GetDistance(double lat1, double lng1, double lat2, double lng2) &#123; double radLat1 = rad(lat1); double radLat2 = rad(lat2); double a = radLat1 - radLat2; double b = rad(lng1) - rad(lng2); double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(b / 2), 2))); s = s * EARTH_RADIUS; s = Math.round(s * 1000); return s; &#125; public static void main(String[] args) &#123; double v = GetDistance(113.36199, 23.12463, 113.36189, 23.12463); System.out.println(v); &#125;&#125; 反馈与建议 尽量每天不断更，做个自律者，markdown原文件在github里面，感谢各位大佬看官star，面试我要往脸上贴金哈哈哈😂。 邮箱：caochikai@qq.com","tags":[{"name":"sql","slug":"sql","permalink":"https://caochikai.github.io/tags/sql/"},{"name":"im","slug":"im","permalink":"https://caochikai.github.io/tags/im/"}]},{"title":"初探缓存","date":"2019-05-17T15:34:21.000Z","path":"2019/05/17/初探缓存/","text":"多级缓存架构缓存设计理念： 缓存常用的对象或者数据，减少系统开销提高效率。 缓存命中率 即从缓存中读取数据的次数 与 总读取次数的比率，命中率越高越好： 缓存策略： 移除策略：FIFO（First In First Out），LRU（Least Recently Used），LFU（Least Frequently Used）。 TTL（Time To Live）：缓存存活期 TTI（Time To Idle）：空闲存活期 spring cache 一、概念 自Spring 3.1起，提供注解缓存，并且提供事务回滚时也自动回滚缓存，并且支持SPEL表达式。 二、入门代码1、添加依赖，例如maven的pom.xml(Springboot); 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 2、添加一种cacheManager的bean实现类，常见ConcurrentMapCache、EhCacheCache、RedisCache； 123456@Beanpublic CacheManager cacheManager() &#123; SimpleCacheManager cacheManager &#x3D; new SimpleCacheManager(); cacheManager.setCaches(Collections.singletonList(new ConcurrentMapCache(&quot;models&quot;))); return cacheManager;&#125; 3、配置模块加载注解@EnableCaching 三、主要注解1、@Cacheable：将方法返回值作为缓存 value (也可使用 cacheNames) : 可看做命名空间，表示存到哪个缓存里了。 key : 表示命名空间下缓存唯一key,使用Spring Expression Language(简称SpEL,详见参考文献[5])生成。 condition : 表示在哪种情况下才缓存结果(对应的还有unless,哪种情况不缓存),同样使用SpEL 2、@CacheEvict：删除缓存注解 3、@CachePut：刷新注解 ehcache 一、概念二、入门代码1、缓存分组，要对分组进行全新CacheConfiguration ，为了高效使用配置自定义属性提取器。默认的属性处理器是JavaBeanAttributeExtractor。 123456789101112131415161718192021222324252627282930@Bean public EhCacheGroupBeanPostProcessor addCache() &#123; System.out.println(&quot;.......添加缓存组........&quot;); return new EhCacheGroupBeanPostProcessor(); &#125; &#x2F;&#x2F;后置处理器 public static class EhCacheGroupBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; &#x2F;&#x2F;根据前面初始化完成的beanName进一步操作 if(beanName.equals(&quot;appEhCacheCacheManager&quot;) ) &#123; EhCacheCacheManager manager &#x3D; (EhCacheCacheManager)bean; CacheManager cacheManager &#x3D; manager.getCacheManager();&#x2F;&#x2F; 文章缓存命中配置needUpdate CacheConfiguration configuration &#x3D; new CacheConfiguration(ReadCacheNames.文章缓存,10000); Searchable searchable &#x3D; new Searchable(); searchable.setKeys(false); searchable.setValues(false); &#x2F;&#x2F;动态索引 searchable.setAllowDynamicIndexing(true); searchable.addSearchAttribute(new SearchAttribute().name(&quot;needUpdate&quot;).className(&quot;com.dwalk.social.common.util.ArticlesAttributeExtractor&quot;)); configuration.eternal(true).addSearchable(searchable); Cache articlesCache &#x3D; new Cache(configuration); cacheManager.addCache(articlesCache); cacheManager.addCache(ReadCacheNames.热点文章缓存); &#125; return bean; &#125; &#125; 2、使用spring内置定时器，并使用ehcache查询api进行缓存查询。 123456789101112131415161718192021222324 @Scheduled(cron &#x3D; &quot;0 0&#x2F;1 * * * ?&quot;) private void synchronize() &#123; Cache cache &#x3D; cacheManager.getCache(ReadCacheNames.文章缓存); int size &#x3D; cache.getSize(); if (size &gt; 0) &#123; Query query &#x3D; cache.createQuery(); Attribute searchAttribute &#x3D; cache.getSearchAttribute(&quot;needUpdate&quot;); &#x2F;&#x2F;指定查询的 query.includeAttribute(searchAttribute); query.includeValues(); Results execute &#x3D; query.addCriteria(searchAttribute.eq(true)).execute(); List all &#x3D; execute.all(); log.info(&quot;查询文章缓存的大小：&#123;&#125;&quot;, all.size()); for (Result result : all) &#123; ArticlesDTO articles &#x3D; (ArticlesDTO) result.getValue(); articles.setNeedUpdate(false); Articles target &#x3D; new Articles();&#x2F;&#x2F; 同步浏览量、视频播放量、评论数、点赞数、收藏数 target.setVisitorNum(articles.getVisitorNum()).setCommentNum(articles.getCommentNum()). setPlayNum(articles.getPlayNum()).setLikeNum(articles.getLikeNum()).setCollectNum(articles.getCollectNum()); articlesService.updateById(target); &#125; &#125; &#125; 三、总结1、需要熟悉spring接口设计，以接口使用框架，要不然官方api使用需了解诸多细节。 四、一二级缓存 当遇到@Cacheable返回为null记录，为了成功序列化null，使用了org.springframework.cache.support.NullValue对象代替null。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889com.alibaba.fastjson.JSONException: autoType is not support. org.springframework.cache.support.NullValue1、起源一二级缓存重写get()方法public class EhRedisCache extends AbstractValueAdaptingCache &#123; 部分代码省略…… @Override public T get(Object key, Callable valueLoader) &#123; try &#123; lock.lock(); value &#x3D; lookup(key); if(value !&#x3D; null) &#123; return (T) value; &#125; value &#x3D; valueLoader.call(); &#x2F;&#x2F;toStoreValue是AbstractValueAdaptingCache抽象类的方法 Object storeValue &#x3D; toStoreValue(value); put(key, storeValue); return (T) value; &#125; catch (Exception e) &#123; throw new ValueRetrievalException(key, valueLoader, e.getCause()); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;2、toStoreValue判断userValue &#x3D;&#x3D; null 则return NullValue.INSTANCE -&gt; public static final Object INSTANCE &#x3D; new NullValue();public abstract class AbstractValueAdaptingCache implements Cache &#123; protected Object toStoreValue(@Nullable Object userValue) &#123; if (userValue &#x3D;&#x3D; null) &#123; if (this.allowNullValues) &#123; return NullValue.INSTANCE; &#125; throw new IllegalArgumentException( &quot;Cache &#39;&quot; + getName() + &quot;&#39; is configured to not allow null values but null was provided&quot;); &#125; return userValue; &#125;&#125;3、序列化反序列化public class FastJsonRedisSerializer implements RedisSerializer &#123; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if (null &#x3D;&#x3D; bytes || bytes.length &lt;&#x3D; 0) &#123; return null; &#125; String str &#x3D; new String(bytes, DEFAULT_CHARSET); return (T) JSON.parseObject(str, clazz); &#125;&#125;4、jsonParser解析类型public class com.alibaba.fastjson.parser.DefaultJSONParser implements Closeable &#123; public final Object parseObject(final Map object, Object fieldName) &#123; 部分代码省略…… Class clazz &#x3D; null; if (object !&#x3D; null &amp;&amp; object.getClass().getName().equals(typeName)) &#123; clazz &#x3D; object.getClass(); &#125; else &#123; &#x2F;&#x2F;com.alibaba.fastjson.parser.DefaultJSONParser#config执行 clazz &#x3D; config.checkAutoType(typeName, null, lexer.getFeatures()); &#125; &#125;&#125;5、异常抛出点TypeUtils.getClassFromMapping(typeName) -》 typeName为org.springframework.cache.support.NullValuepublic Class checkAutoType(String typeName, Class expectClass, int features) &#123; if (Arrays.binarySearch(denyHashCodes, hash) &gt;&#x3D; 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) &#x3D;&#x3D; null) &#123; throw new JSONException(&quot;autoType is not support. &quot; + typeName); &#125;&#125;6、TypeUtils的getClassFromMapping方法返回null public static Class getClassFromMapping(String className)&#123; return mappings.get(className); &#125;7、TypeUtils不支持org.springframework.cache.support.NullValueprivate static ConcurrentMap&gt; mappings &#x3D; new ConcurrentHashMap&gt;(16, 0.75f, 1);&#x2F;&#x2F;mappings类型白名单private static void addBaseClassMappings()&#123; mappings.put(&quot;byte&quot;, byte.class); mappings.put(&quot;short&quot;, short.class); mappings.put(&quot;int&quot;, int.class); mappings.put(&quot;long&quot;, long.class); mappings.put(&quot;float&quot;, float.class); mappings.put(&quot;double&quot;, double.class); mappings.put(&quot;boolean&quot;, boolean.class); 部分代码省略…… fastJson官方没有支持org.springframework.cache.support.NullValue&#125; 反馈与建议 今天复出写博客，一是感觉懒了期望进步，二是为了积累知识方便copy😂。 邮箱：&#x63;&#x61;&#111;&#x63;&#x68;&#105;&#x6b;&#97;&#x69;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;","tags":[{"name":"spring","slug":"spring","permalink":"https://caochikai.github.io/tags/spring/"}]},{"title":"AndroidAdb","date":"2017-02-05T12:49:09.000Z","path":"2017/02/05/AndroidAdb/","text":"Android adb调试工具–清除锁屏密码误解@(Android)[调试工具|实用教程|adb命令] Android Studio ADB官方文档 ADB全称为 Android Debug Bridge, 是android 里的一个调试工具, 用这个工具可以直接操作管理android模拟器或者真实的andriod设备手机。如果你安装了Android SDK（或者下载adb工具包，体积小）,存放sdk的platform-tools目录下，在 命令行cmd使用需要配置路径（android_sdk/platform-tools/adb.exe ）到环境变量里。它可为各种设备操作提供便利，如安装和调试应用，例如查看android中的数据库，提供对 Unix shell（可用来在模拟器或连接的设备上运行各种命令）的访问。该工具作为一个客户端-服务器程序，包括三个组件： 客户端 ：该组件发送命令。客户端在开发计算机上运行。您可以通过发出 adb 命令从命令行终端调用客户端； 后台程序 ：该组件在设备上运行命令。后台程序在每个模拟器或设备实例上作为后台进程运行； 服务器 ：该组件管理客户端和后台程序之间的通信。服务器在开发计算机上作为后台进程运行。 关于清除解锁图案 用户相关的文件accounts.db（gmail账号管理），gesture.key（手势识别文件），password.key（密码文件）。不同品牌手机系统相关文件名也会不同,例如我的手机，华为4x文件为locksettings.db（数据库文件）。修理店里的师傅使用一个工具叫星海神器（高通平台强刷），功能超乎想象，几乎支持所有手机品牌（特别是苹果）淘宝上有卖，网上大部分加密过！小米手机叫丢失解锁神器！ 1. 破解条件 手机打开USB并连接电脑 手机被ROOT，并且ADB可以直接升级为ROOT用户 配置adb路径到环境变量或者直接在cmd命令行里面切换到adb所在路径 2. 破解步骤 *打开cmd命令行，用【adb shell】命令进入shell * 利用su命令将adb提升为root用户，如果成功，行首由$变成 #，#表示root用户 *进入data/system目录 * *ls查看当前目录 * *用ls命令查看密码文件 * 用rm命令删除密码文件，若是$（不是root），则会提示”rm failed for … Permission denied”，权限不足 12345$ adb shell $ su# cd /data/system# ls# rm locksettings.db 输入reboot或手动重启手机生效。亲测华为荣耀4X有效，删除锁屏密码后，指纹解锁自动失效，所以此方法也可以破解指纹解锁！！重新设置锁屏密码后，以前设置的指纹解锁又可以用了。 3. 注意事项看到这儿就明白了，即便手机Root+打开USB调试，也是无法通过ADB解锁手机的。因为想要想要解锁，就得删除/data/system 下的相关文件，可删除需要由Superuser或者kingroot授予ADB shell权限，而授权需要解锁打开手机后操作Superuser程序。即解锁需要用到解锁后的手机操作，就像春晚小品《开锁》中，业主黄宏要求开锁师傅林永健开锁，林永健要求黄宏出示有效证件，可证件就在锁着的箱子里头。 我进行了测试后发现，在授权过一次后，下次手机用USB数据线连接电脑，再次进行解锁，即便同台电脑，也是需要再次授权的。这就说明，即便你用你的电脑经过手机授权解锁过，过后想要在忘记密码时使用ADB方式解锁，也是不可能的。 我觉得这是高版本的安卓系统（eg. Android 4.2 Jelly Bean 安卓果冻豆）新有的安全特性，低版本的Android如安卓2.3.8是可以通过这种方法解锁的。因为我实际测试，我的固件版本为安卓2.3.8的三星S5570（已经Root，打开USB调试），执行命令rm gesture.key，无需授权，直接即可解锁。现在我有个问题，低版本安卓系统如 Android2.3.8的手机解锁屏幕锁定密码，是否的确必须Root，还是只要打开USB调试即可？我手头没有没Root的Android2.3手机，也懒得折腾了，就不管它了。 这样看来，高版本的安卓系统也就不存在被非手机所有者恶意解锁的BUG了。4. 题外话（今年好东西都挂了）收费音乐神器官网，服务器接口平台AnyListen 音乐间谍为window PC版，音乐助手Android版，Shelher微博分享出来3.3版源码百度云 ​​​​密码gria！尴尬的是朋友云免流量也不干了！","tags":[]},{"title":"SpiderWebMagic","date":"2017-01-30T12:50:27.000Z","path":"2017/01/30/SpiderWebMagic/","text":"WebMagic爬虫框架–京东图书@(爬虫)[框架|爬虫|Demo总结] WebMagic!项目代码分为核心(webmagic-core)和扩展(webmagic-extension)两部分(jar包)。Downloader、PageProcessor、Scheduler、Pipeline这四大组件对应爬虫生命周期中的下载、处理、管理和持久化等功能。 名称 功能 Downloader 基础。利用httpClient作为下载工具，下载页面内容便于后续处理解析; Page 网页内容对象。 指根据url下载到的页面内容，包括页面dom元素，css样式，javascript等; Pageprocess 爬虫的核心。 负责解析页面，抽取有用信息，可采用css(),$(),xpath()方法对特定页面元素进行抽取; Site 网站设置。设置网站domain，cookies,header,重试次数,访问间隔时间等; Scheduler 抓取页面队列。 管理待抓取的URL，以及一些去重的工作，将目标url内容push到抓取队列中; Pipeline 输出，收尾。 负责抽取结果的处理，包括计算、持久化到文件、数据库; Spider 爬虫的入口类 采用链式设计，通过它来设定多线程，页面解析器，调度以及输出方式等。 WebMagic官方链接： 官网 包含官方文档和源码,以及相应的实例； github 仓库保存最新版本； oschinamayun码云 包含所有编译好的依赖包； 爬取京东图书(https://book.jd.com/)在商品列表网页抓取如下商品信息 商品名：商品名称 商品网页：显示商品详细信息的网页地址。 市场价格：京东给出的市面价格 京东价格：京东的优惠价。 关于ajax价格链接地址格式：http://p.3.cn/prices/mgets?skuIds=J_ + 商品ID，抓取格式为json。 https://item.jd.com/12087016.html ：图书详情页； http://p.3.cn/prices/mgets?skuIds=J_12087016 （例）价格ajax请求链接； [{“id”:”J_12087016”,”p”:”60.80”,”m”:”90.00”,”op”:”60.80”}] 抓取结果 id + 京东实际价格+市场价格 代码块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import us.codecraft.webmagic.Page;import us.codecraft.webmagic.Site;import us.codecraft.webmagic.Spider;import us.codecraft.webmagic.processor.PageProcessor;import java.util.ArrayList;import java.util.List;public class JDPageProcesser implements PageProcessor &#123; private Site site = Site.me().setRetryTimes(3).setSleepTime(3000).setCharset(\"GBK\"); private static int size = 0;// 共抓取到的图书数量 //抓取商品信息集合 private static List&lt;String&gt; name = new ArrayList&lt;String&gt;();//所有的书名 private static List&lt;String&gt; author = new ArrayList&lt;String&gt;();//所有的作者 private static List&lt;Double&gt; prices = new ArrayList&lt;Double&gt;();//所有的价格 @Override public void process(Page page) &#123; //图书主页 // https://item.jd.com/12004057.html if (!page.getUrl().regex(\"https://item.jd.com/\\\\d&#123;8&#125;.html\").match()&amp;!page.getUrl().regex(\"p.3.cn/prices/mgets\").match()) &#123; // 主页中添加商品详情页到计划url List&lt;String&gt; detail = page.getHtml().links().regex(\"//item.jd.com/\\\\d&#123;8&#125;.html\").replace(\"//\", \"https://\").all(); //控制抓取商品的数量 if (detail.size()&gt;0) &#123; for (int i = 0; i &lt; 4; i++) &#123; String url = detail.get(i); System.out.println(\"url:\" + url.replace(\"https://item.jd.com\", \"\").replace(\"/\", \"http://p.3.cn/prices/mgets?skuIds=J_\").replace(\".html\", \"\")); //列队添加一条详情页后面追加一条价格ajax链接 page.addTargetRequest(url); page.addTargetRequest(url.replace(\"https://item.jd.com\", \"\").replace(\"/\", \"http://p.3.cn/prices/mgets?skuIds=J_\").replace(\".html\", \"\")); &#125; &#125; &#125; if (page.getUrl().regex(\"https://item.jd.com/\\\\d&#123;8&#125;.html\").match()) &#123; // 商品详情页 size++; name.add(page.getHtml().xpath(\"//div[@id=name]/h1/text()\").get());//添加书名 author.add(page.getHtml().xpath(\"//div[@id=p-author]/a/text()\").get());//添加作者 &#125; if (page.getUrl().regex(\"p.3.cn/prices/mgets\").match()) &#123; //ajax商品id对应价格json接口 prices.add(Double.parseDouble(page.getHtml().replace(\"&amp;quot\", \"\").regex(\"p;:;.+;,;m\").regex(\"\\\\d+\\\\.\\\\d+\").get()));//添加价格 &#125; &#125; @Override public Site getSite() &#123; return site; &#125; //获取所有信息导入DAO,持久化层待实现 private static void getAll() &#123; System.out.println(\"Size\" + name.size() + author.size() + prices.size()); for (int i = 0; i &lt; name.size(); i++) &#123; JDLog model = new JDLog(); model.setName(name.get(i)); model.setAuthor(author.get(i)); model.setPrices(prices.get(i)); System.out.println(\"书名:\" + model.getName()); System.out.println(\"作者:\" + model.getAuthor()); System.out.println(\"价格:\" + model.getPrices()); &#125; &#125; public static void main(String[] args) &#123; long startTime, endTime; System.out.println(\"【爬虫开始】请耐心等待一大波数据到你碗里来...\"); startTime = System.currentTimeMillis(); // 从京东图书开始抓，开启5个线程，启动爬虫 Spider.create(new JDPageProcesser()).addUrl(\"https://book.jd.com/\").thread(3).run(); endTime = System.currentTimeMillis(); getAll(); System.out.println(\"【爬虫结束】共抓取\" + size + \"本图书，耗时约\" + ((endTime - startTime) / 1000) + \"秒，已保存到数据库，请查收！\"); &#125;&#125; 以后将会坚持更新!反馈与建议 邮箱：&#99;&#x61;&#x6f;&#x63;&#x68;&#105;&#x6b;&#97;&#105;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;","tags":[]},{"title":"My New Post","date":"2016-12-24T13:46:06.000Z","path":"2016/12/24/First Wirte/","text":"Markdown初次使用Markdown是一门轻量级语法,仅仅需要5分钟你就能搞懂! 期末刷jsp作业心得 DAO层封装成工具类 ：持久层处理业务,尽量把变化东西采用数组遍历,约定成俗简化成配置化写； 登陆注册模块重用 ：前端样式变化,但尽量不要修改提交参数名称和个数； 单元测试类 ：使用 junit测试框架检查逻辑是否有误,方便部署调试 。 代码块1234567891011121314151617// 执行更新操作----带预编译参数public int excuteUpdate(String sql, String[] params) &#123; int result = 0; try &#123; pstmt = getCon().prepareStatement(sql); for (int i = 0; i &lt; params.length; i++) &#123; pstmt.setString(i + 1, params[i]); &#125; result = pstmt.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; pstmtClose(); conClose(); &#125; return result;&#125; ##以后将会持续更新,预告 webmagic 框架爬虫下次出 反馈与建议 邮箱：&#x63;&#97;&#x6f;&#x63;&#x68;&#x69;&#x6b;&#x61;&#105;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#x6d;","tags":[]}]